webpackHotUpdate_N_E("pages/midi",{

/***/ "./apps/shared/sound/Musical.ts":
/*!**************************************!*\
  !*** ./apps/shared/sound/Musical.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\n\n\n// musical.js\n// https://github.com/PencilCode/musical.js\nvar Musical;\n\n(function (_Musical) {\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // WAVETABLE-BUILDER\n  // wavetable is a table of names for nonstandard waveforms.\n  // The table maps names to objects that have wave: and freq:\n  // properties. The wave: property is a PeriodicWave to use\n  // for the oscillator.  The freq: property, if present,\n  // is a map from higher frequencies to more PeriodicWave\n  // objects; when a frequency higher than the given threshold\n  // is requested, the alternate PeriodicWave is used.\n  var makeWavetable = function makeWavetable(ac) {\n    return function (wavedata) {\n      function makePeriodicWave(data) {\n        var n = data.real.length,\n            real = new Float32Array(n),\n            imag = new Float32Array(n),\n            j;\n\n        for (j = 0; j < n; ++j) {\n          real[j] = data.real[j];\n          imag[j] = data.imag[j];\n        }\n\n        try {\n          // Latest API naming.\n          return ac.createPeriodicWave(real, imag);\n        } catch (e) {}\n\n        try {\n          // Earlier API naming.\n          return ac.createWaveTable(real, imag);\n        } catch (e) {}\n\n        return null;\n      }\n\n      function makeMultiple(data, mult, amt) {\n        var result = {\n          real: [],\n          imag: []\n        },\n            j,\n            n = data.real.length,\n            m;\n\n        for (j = 0; j < n; ++j) {\n          m = Math.log(mult[Math.min(j, mult.length - 1)]);\n          result.real.push(data.real[j] * Math.exp(amt * m));\n          result.imag.push(data.imag[j] * Math.exp(amt * m));\n        }\n\n        return result;\n      }\n\n      var result = {},\n          k,\n          d,\n          n,\n          j,\n          ff,\n          record,\n          wave,\n          pw;\n\n      for (k in wavedata) {\n        d = wavedata[k];\n        wave = makePeriodicWave(d);\n\n        if (!wave) {\n          continue;\n        }\n\n        record = {\n          wave: wave\n        }; // A strategy for computing higher frequency waveforms: apply\n        // multipliers to each harmonic according to d.mult.  These\n        // multipliers can be interpolated and applied at any number\n        // of transition frequencies.\n\n        if (d.mult) {\n          ff = wavedata[k].freq;\n          record.freq = {};\n\n          for (j = 0; j < ff.length; ++j) {\n            wave = makePeriodicWave(makeMultiple(d, d.mult, (j + 1) / ff.length));\n\n            if (wave) {\n              record.freq[ff[j]] = wave;\n            }\n          }\n        } // This wave has some default filter settings.\n\n\n        if (d.defs) {\n          record.defs = d.defs;\n        }\n\n        result[k] = record;\n      }\n\n      return result;\n    }({\n      // Currently the only nonstandard waveform is \"piano\".\n      // It is based on the first 32 harmonics from the example:\n      // https://github.com/GoogleChrome/web-audio-samples\n      // /blob/gh-pages/samples/audio/wave-tables/Piano\n      // That is a terrific sound for the lowest piano tones.\n      // For higher tones, interpolate to a customzed wave\n      // shape created by hand, and apply a lowpass filter.\n      piano: {\n        real: [0, 0, -0.203569, 0.5, -0.401676, 0.137128, -0.104117, 0.115965, -0.004413, 0.067884, -0.00888, 0.0793, -0.038756, 0.011882, -0.030883, 0.027608, -0.013429, 0.00393, -0.014029, 0.00972, -0.007653, 0.007866, -0.032029, 0.046127, -0.024155, 0.023095, -0.005522, 0.004511, -0.003593, 0.011248, -0.004919, 0.008505],\n        imag: [0, 0.147621, 0, 0.000007, -0.00001, 0.000005, -0.000006, 0.000009, 0, 0.000008, -0.000001, 0.000014, -0.000008, 0.000003, -0.000009, 0.000009, -0.000005, 0.000002, -0.000007, 0.000005, -0.000005, 0.000005, -0.000023, 0.000037, -0.000021, 0.000022, -0.000006, 0.000005, -0.000004, 0.000014, -0.000007, 0.000012],\n        // How to adjust the harmonics for the higest notes.\n        mult: [1, 1, 0.18, 0.016, 0.01, 0.01, 0.01, 0.004, 0.014, 0.02, 0.014, 0.004, 0.002, 0.00001],\n        // The frequencies at which to interpolate the harmonics.\n        freq: [65, 80, 100, 135, 180, 240, 620, 1360],\n        // The default filter settings to use for the piano wave.\n        // TODO: this approach attenuates low notes too much -\n        // this should be fixed.\n        defs: {\n          wave: \"piano\",\n          gain: 0.5,\n          attack: 0.002,\n          decay: 0.25,\n          sustain: 0.03,\n          release: 0.1,\n          decayfollow: 0.7,\n          cutoff: 800,\n          cutfollow: 0.1,\n          resonance: 1,\n          detune: 0.9994\n        }\n      }\n    });\n  }; // END WAVETABLE-BUILDER\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // UTILS\n\n\n  var Utils = /*#__PURE__*/function () {\n    function Utils() {\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Utils);\n    }\n\n    Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Utils, null, [{\n      key: \"isAudioPresent\",\n      // Tests for the presence of HTML5 Web Audio (or webkit's version).\n      value: function isAudioPresent() {\n        return !!(global.AudioContext || global.webkitAudioContext);\n      } // All our audio funnels through the same AudioContext with a\n      // DynamicsCompressorNode used as the main output, to compress the\n      // dynamic range of all audio.  getAudioTop sets this up.\n\n    }, {\n      key: \"getAudioTop\",\n      value: function getAudioTop() {\n        if (Utils._audioTop) {\n          return Utils._audioTop;\n        }\n\n        if (!Utils.isAudioPresent()) {\n          return null;\n        }\n\n        var ac = new (global.AudioContext || global.webkitAudioContext)();\n        Utils._audioTop = {\n          ac: ac,\n          wavetable: makeWavetable(ac),\n          out: null,\n          currentStart: null\n        };\n        Utils.resetAudio();\n        return Utils._audioTop;\n      } // When audio needs to be interrupted globally (e.g., when you press the\n      // stop button in the IDE), resetAudio does the job.\n\n    }, {\n      key: \"resetAudio\",\n      value: function resetAudio() {\n        if (Utils._audioTop) {\n          var atop = Utils._audioTop; // Disconnect the top-level node and make a new one.\n\n          if (atop.out) {\n            atop.out.disconnect();\n            atop.out = null;\n            atop.currentStart = null;\n          }\n\n          var dcn = atop.ac.createDynamicsCompressor();\n          dcn.ratio.setValueAtTime(16, 0);\n          dcn.attack.setValueAtTime(0.0005, 0); // dcn.ratio = 16; // RONYEH: .ratio is a READ ONLY property.\n          // dcn.attack = 0.0005; // RONYEH: .ratio is a READ ONLY property.\n\n          dcn.connect(atop.ac.destination);\n          atop.out = dcn;\n        }\n      } // For precise scheduling of future notes, the AudioContext currentTime is\n      // cached and is held constant until the script releases to the event loop.\n\n    }, {\n      key: \"audioCurrentStartTime\",\n      value: function audioCurrentStartTime() {\n        var atop = Utils.getAudioTop();\n\n        if (atop.currentStart != null) {\n          return atop.currentStart;\n        } // A delay could be added below to introduce a universal delay in\n        // all beginning sounds (without skewing durations for scheduled\n        // sequences).\n\n\n        atop.currentStart = Math.max(0.25, atop.ac.currentTime\n        /* + 0.0 delay */\n        );\n        setTimeout(function () {\n          atop.currentStart = null;\n        }, 0);\n        return atop.currentStart;\n      } // Converts a midi note number to a frequency in Hz.\n\n    }, {\n      key: \"midiToFrequency\",\n      value: function midiToFrequency(midi) {\n        return 440 * Math.pow(2, (midi - 69) / 12);\n      } // Some constants.\n\n    }, {\n      key: \"frequencyToMidi\",\n      // Converts a frequency in Hz to the closest midi number.\n      value: function frequencyToMidi(freq) {\n        return Math.round(69 + Math.log(freq / 440) * 12 / Math.LN2);\n      } // Converts an ABC pitch (such as \"^G,,\") to a midi note number.\n\n    }, {\n      key: \"pitchToMidi\",\n      value: function pitchToMidi(pitch) {\n        var m = /^(\\^+|_+|=|)([A-Ga-g])([,']*)$/.exec(pitch);\n\n        if (!m) {\n          return null;\n        }\n\n        var octave = m[3].replace(/,/g, \"\").length - m[3].replace(/'/g, \"\").length;\n        var semitone = Utils.noteNum[m[2]] + Utils.accSym[m[1].charAt(0)] * m[1].length + 12 * octave;\n        return semitone + 60; // 60 = midi code middle \"C\".\n      } // Converts a midi number to an ABC notation pitch.\n\n    }, {\n      key: \"midiToPitch\",\n      value: function midiToPitch(midi) {\n        var index = (midi - 72) % 12;\n\n        if (midi > 60 || index != 0) {\n          index += 12;\n        }\n\n        var octaves = Math.round((midi - index - 60) / 12),\n            result = Utils.noteName[index];\n\n        while (octaves != 0) {\n          result += octaves > 0 ? \"'\" : \",\";\n          octaves += octaves > 0 ? -1 : 1;\n        }\n\n        return result;\n      } // Converts an ABC pitch to a frequency in Hz.\n\n    }, {\n      key: \"pitchToFrequency\",\n      value: function pitchToFrequency(pitch) {\n        return Utils.midiToFrequency(Utils.pitchToMidi(pitch));\n      } // The default sound is a square wave with a pretty quick decay to zero.\n\n    }, {\n      key: \"makeTimbre\",\n      // Norrmalizes a timbre object by making a copy that has exactly\n      // the right set of timbre fields, defaulting when needed.\n      // A timbre can specify any of the fields of defaultTimbre; any\n      // unspecified fields are treated as they are set in defaultTimbre.\n      value: function makeTimbre(options, atop) {\n        if (!options) {\n          options = {};\n        }\n\n        if (typeof options == \"string\") {\n          // Abbreviation: name a wave to get a default timbre for that wave.\n          options = {\n            wave: options\n          };\n        }\n\n        var result = {},\n            key,\n            wt = atop && atop.wavetable && atop.wavetable[options.wave];\n\n        for (key in Utils.defaultTimbre) {\n          if (options.hasOwnProperty(key)) {\n            result[key] = options[key];\n          } else if (wt && wt.defs && wt.defs.hasOwnProperty(key)) {\n            result[key] = wt.defs[key];\n          } else {\n            result[key] = Utils.defaultTimbre[key];\n          }\n        }\n\n        return result;\n      }\n    }, {\n      key: \"getWhiteNoiseBuf\",\n      // cache\n      value: function getWhiteNoiseBuf() {\n        if (whiteNoiseBuf == null) {\n          var ac = Utils.getAudioTop().ac,\n              bufferSize = 2 * ac.sampleRate,\n              whiteNoiseBuf = ac.createBuffer(1, bufferSize, ac.sampleRate),\n              output = whiteNoiseBuf.getChannelData(0);\n\n          for (var i = 0; i < bufferSize; i++) {\n            output[i] = Math.random() * 2 - 1;\n          }\n        }\n\n        return whiteNoiseBuf;\n      } // This utility function creates an oscillator at the given frequency\n      // and the given wavename.  It supports lookups in a static wavetable,\n      // defined right below.\n\n    }, {\n      key: \"makeOscillator\",\n      value: function makeOscillator(atop, wavename, freq) {\n        if (wavename == \"noise\") {\n          var whiteNoise = atop.ac.createBufferSource();\n          whiteNoise.buffer = Utils.getWhiteNoiseBuf();\n          whiteNoise.loop = true;\n          return whiteNoise;\n        }\n\n        var wavetable = atop.wavetable,\n            o = atop.ac.createOscillator(),\n            k,\n            pwave,\n            bwf,\n            wf;\n\n        try {\n          if (wavetable.hasOwnProperty(wavename)) {\n            // Use a customized wavetable.\n            pwave = wavetable[wavename].wave;\n\n            if (wavetable[wavename].freq) {\n              bwf = 0; // Look for a higher-frequency variant.\n\n              for (k in wavetable[wavename].freq) {\n                wf = Number(k);\n\n                if (freq > wf && wf > bwf) {\n                  bwf = wf;\n                  pwave = wavetable[wavename].freq[bwf];\n                }\n              }\n            }\n\n            if (!o.setPeriodicWave && o.setWaveTable) {\n              // The old API name: Safari 7 still uses this.\n              o.setWaveTable(pwave);\n            } else {\n              // The new API name.\n              o.setPeriodicWave(pwave);\n            }\n          } else {\n            o.type = wavename;\n          }\n        } catch (e) {\n          if (window.console) {\n            window.console.log(e);\n          } // If unrecognized, just use square.\n          // TODO: support \"noise\" or other wave shapes.\n\n\n          o.type = \"square\";\n        } // o.frequency.value = freq; // RONYEH REMOVED DUE TO SOME BUG.\n\n\n        o.frequency.setTargetAtTime(freq, atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n        return o;\n      }\n    }]);\n\n    return Utils;\n  }(); // END UTILS\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // Parses an ABC file to an object with the following structure:\n  // {\n  //   X: value from the X: lines in header (\\n separated for multiple values)\n  //   V: value from the V:myname lines that appear before K:\n  //   (etc): for all the one-letter header-names.\n  //   K: value from the K: lines in header.\n  //   tempo: Q: line parsed as beatsecs\n  //   timbre: ... I:timbre line as parsed by makeTimbre\n  //   voice: {\n  //     myname: { // voice with id \"myname\"\n  //       V: value from the V:myname lines (from the body)\n  //       stems: [...] as parsed by parseABCstems\n  //    }\n  //  }\n  // }\n  // ABC files are idiosyncratic to parse: the written specifications\n  // do not necessarily reflect the defacto standard implemented by\n  // ABC content on the web.  This implementation is designed to be\n  // practical, working on content as it appears on the web, and only\n  // using the written standard as a guideline.\n\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"_audioTop\", null);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"noteNum\", {\n    C: 0,\n    D: 2,\n    E: 4,\n    F: 5,\n    G: 7,\n    A: 9,\n    B: 11,\n    c: 12,\n    d: 14,\n    e: 16,\n    f: 17,\n    g: 19,\n    a: 21,\n    b: 23\n  });\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"accSym\", {\n    \"^\": 1,\n    \"\": 0,\n    \"=\": 0,\n    _: -1\n  });\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"noteName\", [\"C\", \"^C\", \"D\", \"_E\", \"E\", \"F\", \"^F\", \"G\", \"_A\", \"A\", \"_B\", \"B\", \"c\", \"^c\", \"d\", \"_e\", \"e\", \"f\", \"^f\", \"g\", \"_a\", \"a\", \"_b\", \"b\"]);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"defaultTimbre\", {\n    wave: \"square\",\n    // Oscillator type.\n    gain: 0.1,\n    // Overall gain at maximum attack.\n    attack: 0.002,\n    // Attack time at the beginning of a tone.\n    decay: 0.4,\n    // Rate of exponential decay after attack.\n    decayfollow: 0,\n    // Amount of decay shortening for higher notes.\n    sustain: 0,\n    // Portion of gain to sustain indefinitely.\n    release: 0.1,\n    // Release time after a tone is done.\n    cutoff: 0,\n    // Low-pass filter cutoff frequency.\n    cutfollow: 0,\n    // Cutoff adjustment, a multiple of oscillator freq.\n    resonance: 0,\n    // Low-pass filter resonance.\n    detune: 0 // Detune factor for a second oscillator.\n\n  });\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"whiteNoiseBuf\", null);\n\n  var ABCheader = /^([A-Za-z]):\\s*(.*)$/;\n  var ABCtoken = /(?:\\[[A-Za-z]:[^\\]]*\\])|\\s+|%[^\\n]*|![^\\s!:|\\[\\]]*!|\\+[^+|!]*\\+|[_<>@^]?\"[^\"]*\"|\\[|\\]|>+|<+|(?:(?:\\^+|_+|=|)[A-Ga-g](?:,+|'+|))|\\(\\d+(?::\\d+){0,2}|\\d*\\/\\d+|\\d+\\/?|\\/+|[xzXZ]|\\[?\\|\\]?|:?\\|:?|::|./g;\n\n  function parseABCFile(str) {\n    var lines = str.split(\"\\n\"),\n        result = {},\n        context = result,\n        timbre,\n        j,\n        k,\n        header,\n        stems,\n        key = {},\n        accent = {\n      slurred: 0\n    },\n        voiceid,\n        out; // ABC files are parsed one line at a time.\n\n    for (j = 0; j < lines.length; ++j) {\n      // First, check to see if the line is a header line.\n      header = ABCheader.exec(lines[j]);\n\n      if (header) {\n        handleInformation(header[1], header[2].trim());\n      } else if (/^\\s*(?:%.*)?$/.test(lines[j])) {\n        // Skip blank and comment lines.\n        continue;\n      } else {\n        // Parse the notes.\n        parseABCNotes(lines[j]);\n      }\n    }\n\n    var infer = [\"unitnote\", \"unitbeat\", \"tempo\"];\n\n    if (result.hasOwnProperty(\"voice\") && result.voice !== null) {\n      out = [];\n\n      for (j in result.voice) {\n        if (result.voice[j].stems && result.voice[j].stems.length) {\n          // Calculate times for all the tied notes.  This happens at the end\n          // because in principle, the first note of a song could be tied all\n          // the way through to the last note.\n          processTies(result.voice[j].stems); // Bring up inferred tempo values from voices if not specified\n          // in the header.\n\n          for (k = 0; k < infer.length; ++k) {\n            if (!(infer[k] in result) && infer[k] in result.voice[j]) {\n              result[infer[k]] = result.voice[j][infer[k]];\n            }\n          } // Remove this internal state variable;\n\n\n          delete result.voice[j].accent;\n        } else {\n          out.push(j);\n        }\n      } // Delete any voices that had no stems.\n\n\n      for (j = 0; j < out.length; ++j) {\n        delete result.voice[out[j]];\n      }\n    }\n\n    return result; ////////////////////////////////////////////////////////////////////////\n    // Parsing helper functions below.\n    ////////////////////////////////////////////////////////////////////////\n    // Processes header fields such as V: voice, which may appear at the\n    // top of the ABC file, or in the ABC body in a [V:voice] directive.\n\n    function handleInformation(field, value) {\n      // The following headers are recognized and processed.\n      switch (field) {\n        case \"V\":\n          // A V: header switches voices if in the body.\n          // If in the header, then it is just advisory.\n          if (context !== result) {\n            startVoiceContext(value.split(\" \")[0]);\n          }\n\n          break;\n\n        case \"M\":\n          parseMeter(value, context);\n          break;\n\n        case \"L\":\n          parseUnitNote(value, context);\n          break;\n\n        case \"Q\":\n          parseTempo(value, context);\n          break;\n      } // All headers (including unrecognized ones) are\n      // just accumulated as properties. Repeated header\n      // lines are accumulated as multiline properties.\n\n\n      if (context.hasOwnProperty(field)) {\n        context[field] += \"\\n\" + value;\n      } else {\n        context[field] = value;\n      } // The K header is special: it should be the last one\n      // before the voices and notes begin.\n\n\n      if (field == \"K\") {\n        key = keysig(value);\n\n        if (context === result) {\n          startVoiceContext(firstVoiceName());\n        }\n      }\n    } // Shifts context to a voice with the given id given.  If no id\n    // given, then just sticks with the current voice.  If the current\n    // voice is unnamed and empty, renames the current voice.\n\n\n    function startVoiceContext(id) {\n      id = id || \"\";\n\n      if (!id && context !== result) {\n        return;\n      }\n\n      if (!result.voice) {\n        result.voice = {};\n      }\n\n      if (result.voice.hasOwnProperty(id)) {\n        // Resume a named voice.\n        context = result.voice[id];\n        accent = context.accent;\n      } else {\n        // Start a new voice.\n        context = {\n          id: id,\n          accent: {\n            slurred: 0\n          }\n        };\n        result.voice[id] = context;\n        accent = context.accent;\n      }\n    } // For picking a default voice, looks for the first voice name.\n\n\n    function firstVoiceName() {\n      if (result.V) {\n        return result.V.split(/\\s+/)[0];\n      } else {\n        return \"\";\n      }\n    } // Parses a single line of ABC notes (i.e., not a header line).\n    //\n    // We process an ABC song stream by dividing it into tokens, each of\n    // which is a pitch, duration, or special decoration symbol; then\n    // we process each decoration individually, and we process each\n    // stem as a group using parseStem.\n    // The structure of a single ABC note is something like this:\n    //\n    // NOTE -> STACCATO? PITCH DURATION? TIE?\n    //\n    // I.e., it always has a pitch, and it is prefixed by some optional\n    // decorations such as a (.) staccato marking, and it is suffixed by\n    // an optional duration and an optional tie (-) marking.\n    //\n    // A stem is either a note or a bracketed series of notes, followed\n    // by duration and tie.\n    //\n    // STEM -> NOTE   OR    '[' NOTE * ']' DURAITON? TIE?\n    //\n    // Then a song is just a sequence of stems interleaved with other\n    // decorations such as dynamics markings and measure delimiters.\n\n\n    function parseABCNotes(str) {\n      var tokens = str.match(ABCtoken),\n          parsed = null,\n          index = 0,\n          dotted = 0,\n          beatlet = null,\n          t;\n\n      if (!tokens) {\n        return null;\n      }\n\n      while (index < tokens.length) {\n        // Ignore %comments and !markings!\n        if (/^[\\s%]/.test(tokens[index])) {\n          index++;\n          continue;\n        } // Handle inline [X:...] information fields\n\n\n        if (/^\\[[A-Za-z]:[^\\]]*\\]$/.test(tokens[index])) {\n          handleInformation(tokens[index].substring(1, 2), tokens[index].substring(3, tokens[index].length - 1).trim());\n          index++;\n          continue;\n        } // Handled dotted notation abbreviations.\n\n\n        if (/</.test(tokens[index])) {\n          dotted = -tokens[index++].length;\n          continue;\n        }\n\n        if (/>/.test(tokens[index])) {\n          dotted = tokens[index++].length;\n          continue;\n        }\n\n        if (/^\\(\\d+(?::\\d+)*/.test(tokens[index])) {\n          beatlet = parseBeatlet(tokens[index++]);\n          continue;\n        }\n\n        if (/^[!+].*[!+]$/.test(tokens[index])) {\n          parseDecoration(tokens[index++], accent);\n          continue;\n        }\n\n        if (/^.?\".*\"$/.test(tokens[index])) {\n          // Ignore double-quoted tokens (chords and general text annotations).\n          index++;\n          continue;\n        }\n\n        if (/^[()]$/.test(tokens[index])) {\n          if (tokens[index++] == \"(\") {\n            accent.slurred += 1;\n          } else {\n            accent.slurred -= 1;\n\n            if (accent.slurred <= 0) {\n              accent.slurred = 0;\n\n              if (context.stems && context.stems.length >= 1) {\n                // The last notes in a slur are not slurred.\n                slurStem(context.stems[context.stems.length - 1], false);\n              }\n            }\n          }\n\n          continue;\n        } // Handle measure markings by clearing accidentals.\n\n\n        if (/\\|/.test(tokens[index])) {\n          for (t in accent) {\n            if (t.length == 1) {\n              // Single-letter accent properties are note accidentals.\n              delete accent[t];\n            }\n          }\n\n          index++;\n          continue;\n        }\n\n        parsed = parseStem(tokens, index, key, accent); // Skip unparsable bits\n\n        if (parsed === null) {\n          index++;\n          continue;\n        } // Process a parsed stem.\n\n\n        if (beatlet) {\n          scaleStem(parsed.stem, beatlet.time);\n          beatlet.count -= 1;\n\n          if (!beatlet.count) {\n            beatlet = null;\n          }\n        } // If syncopated with > or < notation, shift part of a beat\n        // between this stem and the previous one.\n\n\n        if (dotted && context.stems && context.stems.length) {\n          if (dotted > 0) {\n            t = (1 - Math.pow(0.5, dotted)) * parsed.stem.time;\n          } else {\n            t = (Math.pow(0.5, -dotted) - 1) * context.stems[context.stems.length - 1].time;\n          }\n\n          syncopateStem(context.stems[context.stems.length - 1], t);\n          syncopateStem(parsed.stem, -t);\n        }\n\n        dotted = 0; // Slur all the notes contained within a strem.\n\n        if (accent.slurred) {\n          slurStem(parsed.stem, true);\n        } // Start a default voice if we're not in a voice yet.\n\n\n        if (context === result) {\n          startVoiceContext(firstVoiceName());\n        }\n\n        if (!(\"stems\" in context)) {\n          context.stems = [];\n        } // Add the stem to the sequence of stems for this voice.\n\n\n        context.stems.push(parsed.stem); // Advance the parsing index since a stem is multiple tokens.\n\n        index = parsed.index;\n      }\n    } // Parse M: lines.  \"3/4\" is 3/4 time and \"C\" is 4/4 (common) time.\n\n\n    function parseMeter(mline, beatinfo) {\n      var d = /^C/.test(mline) ? 4 / 4 : durationToTime(mline);\n\n      if (!d) {\n        return;\n      }\n\n      if (!beatinfo.unitnote) {\n        if (d < 0.75) {\n          beatinfo.unitnote = 1 / 16;\n        } else {\n          beatinfo.unitnote = 1 / 8;\n        }\n      }\n    } // Parse L: lines, e.g., \"1/8\".\n\n\n    function parseUnitNote(lline, beatinfo) {\n      var d = durationToTime(lline);\n\n      if (!d) {\n        return;\n      }\n\n      beatinfo.unitnote = d;\n    } // Parse Q: line, e.g., \"1/4=66\".\n\n\n    function parseTempo(qline, beatinfo) {\n      var parts = qline.split(/\\s+|=/),\n          j,\n          unit = null,\n          tempo = null;\n\n      for (j = 0; j < parts.length; ++j) {\n        // It could be reversed, like \"66=1/4\", or just \"120\", so\n        // determine what is going on by looking for a slash etc.\n        if (parts[j].indexOf(\"/\") >= 0 || /^[1-4]$/.test(parts[j])) {\n          // The note-unit (e.g., 1/4).\n          unit = unit || durationToTime(parts[j]);\n        } else {\n          // The tempo-number (e.g., 120)\n          tempo = tempo || Number(parts[j]);\n        }\n      }\n\n      if (unit) {\n        beatinfo.unitbeat = unit;\n      }\n\n      if (tempo) {\n        beatinfo.tempo = tempo;\n      }\n    } // Run through all the notes, adding up time for tied notes,\n    // and marking notes that were held over with holdover = true.\n\n\n    function processTies(stems) {\n      var tied = {},\n          nextTied,\n          j,\n          k,\n          note,\n          firstNote;\n\n      for (j = 0; j < stems.length; ++j) {\n        nextTied = {};\n\n        for (k = 0; k < stems[j].notes.length; ++k) {\n          firstNote = note = stems[j].notes[k];\n\n          if (tied.hasOwnProperty(note.pitch)) {\n            // Pitch was tied from before.\n            firstNote = tied[note.pitch]; // Get the earliest note in the tie.\n\n            firstNote.time += note.time; // Extend its time.\n\n            note.holdover = true; // Silence this note as a holdover.\n          }\n\n          if (note.tie) {\n            // This note is tied with the next.\n            nextTied[note.pitch] = firstNote; // Save it away.\n          }\n        }\n\n        tied = nextTied;\n      }\n    } // Returns a map of A-G -> accidentals, according to the key signature.\n    // When n is zero, there are no accidentals (e.g., C major or A minor).\n    // When n is positive, there are n sharps (e.g., for G major, n = 1).\n    // When n is negative, there are -n flats (e.g., for F major, n = -1).\n\n\n    function accidentals(n) {\n      var sharps = \"FCGDAEB\",\n          result = {},\n          j;\n\n      if (!n) {\n        return result;\n      }\n\n      if (n > 0) {\n        // Handle sharps.\n        for (j = 0; j < n && j < 7; ++j) {\n          result[sharps.charAt(j)] = \"^\";\n        }\n      } else {\n        // Flats are in the opposite order.\n        for (j = 0; j > n && j > -7; --j) {\n          result[sharps.charAt(6 + j)] = \"_\";\n        }\n      }\n\n      return result;\n    } // Decodes the key signature line (e.g., K: C#m) at the front of an ABC tune.\n    // Supports the whole range of scale systems listed in the ABC spec.\n\n\n    function keysig(keyname) {\n      if (!keyname) {\n        return {};\n      }\n\n      var kkey,\n          sigcodes = {\n        // Major\n        \"c#\": 7,\n        \"f#\": 6,\n        b: 5,\n        e: 4,\n        a: 3,\n        d: 2,\n        g: 1,\n        c: 0,\n        f: -1,\n        bb: -2,\n        eb: -3,\n        ab: -4,\n        db: -5,\n        gb: -6,\n        cb: -7,\n        // Minor\n        \"a#m\": 7,\n        \"d#m\": 6,\n        \"g#m\": 5,\n        \"c#m\": 4,\n        \"f#m\": 3,\n        bm: 2,\n        em: 1,\n        am: 0,\n        dm: -1,\n        gm: -2,\n        cm: -3,\n        fm: -4,\n        bbm: -5,\n        ebm: -6,\n        abm: -7,\n        // Mixolydian\n        \"g#mix\": 7,\n        \"c#mix\": 6,\n        \"f#mix\": 5,\n        bmix: 4,\n        emix: 3,\n        amix: 2,\n        dmix: 1,\n        gmix: 0,\n        cmix: -1,\n        fmix: -2,\n        bbmix: -3,\n        ebmix: -4,\n        abmix: -5,\n        dbmix: -6,\n        gbmix: -7,\n        // Dorian\n        \"d#dor\": 7,\n        \"g#dor\": 6,\n        \"c#dor\": 5,\n        \"f#dor\": 4,\n        bdor: 3,\n        edor: 2,\n        ador: 1,\n        ddor: 0,\n        gdor: -1,\n        cdor: -2,\n        fdor: -3,\n        bbdor: -4,\n        ebdor: -5,\n        abdor: -6,\n        dbdor: -7,\n        // Phrygian\n        \"e#phr\": 7,\n        \"a#phr\": 6,\n        \"d#phr\": 5,\n        \"g#phr\": 4,\n        \"c#phr\": 3,\n        \"f#phr\": 2,\n        bphr: 1,\n        ephr: 0,\n        aphr: -1,\n        dphr: -2,\n        gphr: -3,\n        cphr: -4,\n        fphr: -5,\n        bbphr: -6,\n        ebphr: -7,\n        // Lydian\n        \"f#lyd\": 7,\n        blyd: 6,\n        elyd: 5,\n        alyd: 4,\n        dlyd: 3,\n        glyd: 2,\n        clyd: 1,\n        flyd: 0,\n        bblyd: -1,\n        eblyd: -2,\n        ablyd: -3,\n        dblyd: -4,\n        gblyd: -5,\n        cblyd: -6,\n        fblyd: -7,\n        // Locrian\n        \"b#loc\": 7,\n        \"e#loc\": 6,\n        \"a#loc\": 5,\n        \"d#loc\": 4,\n        \"g#loc\": 3,\n        \"c#loc\": 2,\n        \"f#loc\": 1,\n        bloc: 0,\n        eloc: -1,\n        aloc: -2,\n        dloc: -3,\n        gloc: -4,\n        cloc: -5,\n        floc: -6,\n        bbloc: -7\n      };\n      var k = keyname.replace(/\\s+/g, \"\").toLowerCase().substr(0, 5);\n      var scale = k.match(/maj|min|mix|dor|phr|lyd|loc|m/);\n\n      if (scale) {\n        if (scale == \"maj\") {\n          kkey = k.substr(0, scale.index);\n        } else if (scale == \"min\") {\n          kkey = k.substr(0, scale.index + 1);\n        } else {\n          kkey = k.substr(0, scale.index + scale[0].length);\n        }\n      } else {\n        kkey = /^[a-g][#b]?/.exec(k) || \"\";\n      }\n\n      var result = accidentals(sigcodes[kkey]);\n      var extras = keyname.substr(kkey.length).match(/(_+|=|\\^+)[a-g]/gi);\n\n      if (extras) {\n        for (var j = 0; j < extras.length; ++j) {\n          var note = extras[j].charAt(extras[j].length - 1).toUpperCase();\n\n          if (extras[j].charAt(0) == \"=\") {\n            delete result[note];\n          } else {\n            result[note] = extras[j].substr(0, extras[j].length - 1);\n          }\n        }\n      }\n\n      return result;\n    } // Additively adjusts the beats for a stem and the contained notes.\n\n\n    function syncopateStem(stem, t) {\n      var j,\n          note,\n          stemtime = stem.time,\n          newtime = stemtime + t;\n      stem.time = newtime;\n      syncopateStem;\n\n      for (j = 0; j < stem.notes.length; ++j) {\n        note = stem.notes[j]; // Only adjust a note's duration if it matched the stem's duration.\n\n        if (note.time == stemtime) {\n          note.time = newtime;\n        }\n      }\n    } // Marks everything in the stem with the slur attribute (or deletes it).\n\n\n    function slurStem(stem, addSlur) {\n      var j, note;\n\n      for (j = 0; j < stem.notes.length; ++j) {\n        note = stem.notes[j];\n\n        if (addSlur) {\n          note.slurred = true;\n        } else if (note.slurred) {\n          delete note.slurred;\n        }\n      }\n    } // Scales the beats for a stem and the contained notes.\n\n\n    function scaleStem(stem, s) {\n      var j;\n      stem.time *= s;\n\n      for (j = 0; j < stem.notes.length; ++j) {\n        stem.notes[j].time *= s;\n      }\n    } // Parses notation of the form (3 or (5:2:10, which means to do\n    // the following 3 notes in the space of 2 notes, or to do the following\n    // 10 notes at the rate of 5 notes per 2 beats.\n\n\n    function parseBeatlet(token) {\n      var m = /^\\((\\d+)(?::(\\d+)(?::(\\d+))?)?$/.exec(token);\n\n      if (!m) {\n        return null;\n      }\n\n      var count = Number(m[1]),\n          beats = Number(m[2]) || 2,\n          duration = Number(m[3]) || count;\n      return {\n        time: beats / count,\n        count: duration\n      };\n    } // Parse !ppp! markings.\n\n\n    function parseDecoration(token, accent) {\n      if (token.length < 2) {\n        return;\n      }\n\n      token = token.substring(1, token.length - 1);\n\n      switch (token) {\n        case \"pppp\":\n        case \"ppp\":\n          accent.dynamics = 0.2;\n          break;\n\n        case \"pp\":\n          accent.dynamics = 0.4;\n          break;\n\n        case \"p\":\n          accent.dynamics = 0.6;\n          break;\n\n        case \"mp\":\n          accent.dynamics = 0.8;\n          break;\n\n        case \"mf\":\n          accent.dynamics = 1.0;\n          break;\n\n        case \"f\":\n          accent.dynamics = 1.2;\n          break;\n\n        case \"ff\":\n          accent.dynamics = 1.4;\n          break;\n\n        case \"fff\":\n        case \"ffff\":\n          accent.dynamics = 1.5;\n          break;\n      }\n    } // Parses a stem, which may be a single note, or which may be\n    // a chorded note.\n\n\n    function parseStem(tokens, index, key, accent) {\n      var notes = [],\n          duration = \"\",\n          staccato = false,\n          noteDuration,\n          noteTime,\n          velocity,\n          lastNote = null,\n          minStemTime = Infinity,\n          j; // A single staccato marking applies to the entire stem.\n\n      if (index < tokens.length && \".\" == tokens[index]) {\n        staccato = true;\n        index++;\n      }\n\n      if (index < tokens.length && tokens[index] == \"[\") {\n        // Deal with [CEG] chorded notation.\n        index++; // Scan notes within the chord.\n\n        while (index < tokens.length) {\n          // Ignore and space and %comments.\n          if (/^[\\s%]/.test(tokens[index])) {\n            index++;\n            continue;\n          }\n\n          if (/[A-Ga-g]/.test(tokens[index])) {\n            // Grab a pitch.\n            lastNote = {\n              pitch: applyAccent(tokens[index++], key, accent),\n              tie: false\n            };\n            lastNote.frequency = Utils.pitchToFrequency(lastNote.pitch);\n            notes.push(lastNote);\n          } else if (/[xzXZ]/.test(tokens[index])) {\n            // Grab a rest.\n            lastNote = null;\n            index++;\n          } else if (\".\" == tokens[index]) {\n            // A staccato mark applies to the entire stem.\n            staccato = true;\n            index++;\n            continue;\n          } else {\n            // Stop parsing the stem if something is unrecognized.\n            break;\n          } // After a pitch or rest, look for a duration.\n\n\n          if (index < tokens.length && /^(?![\\s%!]).*[\\d\\/]/.test(tokens[index])) {\n            noteDuration = tokens[index++];\n            noteTime = durationToTime(noteDuration);\n          } else {\n            noteDuration = \"\";\n            noteTime = 1;\n          } // If it's a note (not a rest), store the duration\n\n\n          if (lastNote) {\n            lastNote.duration = noteDuration;\n            lastNote.time = noteTime;\n          } // When a stem has more than one duration, use the shortest\n          // one for timing. The standard says to pick the first one,\n          // but in practice, transcribed music online seems to\n          // follow the rule that the stem's duration is determined\n          // by the shortest contained duration.\n\n\n          if (noteTime && noteTime < minStemTime) {\n            duration = noteDuration;\n            minStemTime = noteTime;\n          } // After a duration, look for a tie mark.  Individual notes\n          // within a stem can be tied.\n\n\n          if (index < tokens.length && \"-\" == tokens[index]) {\n            if (lastNote) {\n              notes[notes.length - 1].tie = true;\n            }\n\n            index++;\n          }\n        } // The last thing in a chord should be a ].  If it isn't, then\n        // this doesn't look like a stem after all, and return null.\n\n\n        if (tokens[index] != \"]\") {\n          return null;\n        }\n\n        index++;\n      } else if (index < tokens.length && /[A-Ga-g]/.test(tokens[index])) {\n        // Grab a single note.\n        lastNote = {\n          pitch: applyAccent(tokens[index++], key, accent),\n          tie: false,\n          duration: \"\",\n          time: 1\n        };\n        lastNote.frequency = Utils.pitchToFrequency(lastNote.pitch);\n        notes.push(lastNote);\n      } else if (index < tokens.length && /^[xzXZ]$/.test(tokens[index])) {\n        // Grab a rest - no pitch.\n        index++;\n      } else {\n        // Something we don't recognize - not a stem.\n        return null;\n      } // Right after a [chord], note, or rest, look for a duration marking.\n\n\n      if (index < tokens.length && /^(?![\\s%!]).*[\\d\\/]/.test(tokens[index])) {\n        duration = tokens[index++];\n        noteTime = durationToTime(duration); // Apply the duration to all the ntoes in the stem.\n        // NOTE: spec suggests multiplying this duration, but that\n        // idiom is not seen (so far) in practice.\n\n        for (j = 0; j < notes.length; ++j) {\n          notes[j].duration = duration;\n          notes[j].time = noteTime;\n        }\n      } // Then look for a trailing tie marking.  Will tie every note in a chord.\n\n\n      if (index < tokens.length && \"-\" == tokens[index]) {\n        index++;\n\n        for (j = 0; j < notes.length; ++j) {\n          notes[j].tie = true;\n        }\n      }\n\n      if (accent.dynamics) {\n        velocity = accent.dynamics;\n\n        for (j = 0; j < notes.length; ++j) {\n          notes[j].velocity = velocity;\n        }\n      }\n\n      return {\n        index: index,\n        stem: {\n          notes: notes,\n          duration: duration,\n          staccato: staccato,\n          time: durationToTime(duration)\n        }\n      };\n    } // Normalizes pitch markings by stripping leading = if present.\n\n\n    function stripNatural(pitch) {\n      if (pitch.length > 0 && pitch.charAt(0) == \"=\") {\n        return pitch.substr(1);\n      }\n\n      return pitch;\n    } // Processes an accented pitch, automatically applying accidentals\n    // that have accumulated within the measure, and also saving\n    // explicit accidentals to continue to apply in the measure.\n\n\n    function applyAccent(pitch, key, accent) {\n      var m = /^(\\^+|_+|=|)([A-Ga-g])(.*)$/.exec(pitch),\n          letter;\n\n      if (!m) {\n        return pitch;\n      } // Note that an accidental in one octave applies in other octaves.\n\n\n      letter = m[2].toUpperCase();\n\n      if (m[1].length > 0) {\n        // When there is an explicit accidental, then remember it for\n        // the rest of the measure.\n        accent[letter] = m[1];\n        return stripNatural(pitch);\n      }\n\n      if (accent.hasOwnProperty(letter)) {\n        // Accidentals from this measure apply to unaccented notes.\n        return stripNatural(accent[letter] + m[2] + m[3]);\n      }\n\n      if (key.hasOwnProperty(letter)) {\n        // Key signatures apply by default.\n        return stripNatural(key[letter] + m[2] + m[3]);\n      }\n\n      return stripNatural(pitch);\n    } // Converts an ABC duration to a number (e.g., \"/3\"->0.333 or \"11/2\"->1.5).\n\n\n    function durationToTime(duration) {\n      var m = /^(\\d*)(?:\\/(\\d*))?$|^(\\/+)$/.exec(duration),\n          n,\n          d,\n          i = 0,\n          ilen;\n      if (!m) return;\n      if (m[3]) return Math.pow(0.5, m[3].length);\n      d = m[2] ? parseFloat(m[2]) : /\\//.test(duration) ? 2 : 1; // Handle mixed frations:\n\n      ilen = 0;\n      n = m[1] ? parseFloat(m[1]) : 1;\n\n      if (m[2]) {\n        while (ilen + 1 < m[1].length && n > d) {\n          ilen += 1;\n          i = parseFloat(m[1].substring(0, ilen));\n          n = parseFloat(m[1].substring(ilen));\n        }\n      }\n\n      return i + n / d;\n    }\n  } //////////////////////////////////////////////////////////////////////////////////////////////////\n  // INSTRUMENTS\n  //\n  // All further details of audio handling are encapsulated in the Instrument\n  // class, which knows how to synthesize a basic timbre; how to play and\n  // schedule a tone; and how to parse and sequence a song written in ABC\n  // notation.\n  // The constructor accepts a timbre string or object, specifying\n  // its default sound.  The main mechanisms in Instrument are for handling\n  // sequencing of a (potentially large) set of notes over a (potentially\n  // long) period of time.  The overall strategy:\n  //\n  //                       Events:      'noteon'        'noteoff'\n  //                                      |               |\n  // tone()-(quick tones)->| _startSet -->| _finishSet -->| _cleanupSet -->|\n  //   \\                   |  /           | Playing tones | Done tones     |\n  //    \\---- _queue ------|-/                                             |\n  //      of future tones  |3 secs ahead sent to WebAudio, removed when done\n  //\n  // The reason for this queuing is to reduce the complexity of the\n  // node graph sent to WebAudio: at any time, WebAudio is only\n  // responsible for about 2 seconds of music.  If a graph with too\n  // too many nodes is sent to WebAudio at once, output distorts badly.\n\n\n  var Instrument = /*#__PURE__*/function () {\n    Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Instrument, null, [{\n      key: \"pitchToMidi\",\n      // Seconds to delay all audiable timing.\n      // Seconds before an event to reexamine queue.\n      // Seconds ahead to put notes in WebAudio.\n      // Default duration of a tone.\n      // Silent time before disconnecting nodes.\n      // Accepts either an ABC pitch or a midi number and converts to midi.\n      value: function pitchToMidi(n) {\n        if (typeof n == \"string\") {\n          return Utils.pitchToMidi(n);\n        }\n\n        return n;\n      } // Accepts either an ABC pitch or a midi number and converts to ABC pitch.\n\n    }, {\n      key: \"midiToPitch\",\n      value: function midiToPitch(n) {\n        if (typeof n == \"number\") {\n          return Utils.midiToPitch(n);\n        }\n\n        return n;\n      }\n    }]);\n\n    function Instrument(options) {\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Instrument);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_out\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_atop\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_timbre\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_queue\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_minQueueTime\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_maxScheduledTime\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_unsortedQueue\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_startSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_finishSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_cleanupSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_callbackSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_handlers\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_now\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_pollTimer\", void 0);\n\n      this._atop = Utils.getAudioTop(); // Audio context.\n\n      this._timbre = Utils.makeTimbre(options, this._atop); // The instrument's timbre.\n\n      this._queue = []; // A queue of future tones to play.\n\n      this._minQueueTime = Infinity; // The earliest time in _queue.\n\n      this._maxScheduledTime = 0; // The latest time in _queue.\n\n      this._unsortedQueue = false; // True if _queue is unsorted.\n\n      this._startSet = []; // Unstarted tones already sent to WebAudio.\n\n      this._finishSet = {}; // Started tones playing in WebAudio.\n\n      this._cleanupSet = []; // Tones waiting for cleanup.\n\n      this._callbackSet = []; // A set of scheduled callbacks.\n\n      this._handlers = {}; // 'noteon' and 'noteoff' handlers.\n\n      this._now = null; // A cached current-time value.\n\n      if (Utils.isAudioPresent()) {\n        this.silence(); // Initializes top-level audio node.\n      }\n    } // Sets the default timbre for the instrument.  See defaultTimbre.\n\n\n    Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Instrument, [{\n      key: \"setTimbre\",\n      value: function setTimbre(t) {\n        this._timbre = Utils.makeTimbre(t, this._atop); // Saves a copy.\n      } // Returns the default timbre for the instrument as an object.\n\n    }, {\n      key: \"getTimbre\",\n      value: function getTimbre(t) {\n        return Utils.makeTimbre(this._timbre, this._atop); // Makes a copy.\n      } // Sets the overall volume for the instrument immediately.\n\n    }, {\n      key: \"setVolume\",\n      value: function setVolume(v) {\n        // Without an audio system, volume cannot be set.\n        if (!this._out) {\n          return;\n        }\n\n        if (!isNaN(v)) {\n          this._out.gain.value = v;\n        }\n      } // Sets the overall volume for the instrument.\n\n    }, {\n      key: \"getVolume\",\n      value: function getVolume(v) {\n        // Without an audio system, volume is stuck at zero.\n        if (!this._out) {\n          return 0.0;\n        }\n\n        return this._out.gain.value;\n      } // Silences the instrument immediately by reinitializing the audio\n      // graph for this instrument and emptying or flushing all queues in the\n      // scheduler.  Carefully notifies all notes that have started but not\n      // yet finished, and sequences that are awaiting scheduled callbacks.\n      // Does not notify notes that have not yet started.\n\n    }, {\n      key: \"silence\",\n      value: function silence() {\n        var j,\n            finished,\n            callbacks,\n            initvolume = 1; // Clear future notes.\n\n        this._queue.length = 0;\n        this._minQueueTime = Infinity;\n        this._maxScheduledTime = 0; // Don't notify notes that haven't started yet.\n\n        this._startSet.length = 0; // Flush finish callbacks that are promised.\n\n        finished = this._finishSet;\n        this._finishSet = {}; // Flush one-time callacks that are promised.\n\n        callbacks = this._callbackSet;\n        this._callbackSet = []; // Disconnect the audio graph for this instrument.\n\n        if (this._out) {\n          this._out.disconnect();\n\n          initvolume = this._out.gain.value;\n        } // Reinitialize the audio graph: all audio for the instrument\n        // multiplexes through a single gain node with a master volume.\n\n\n        this._atop = Utils.getAudioTop();\n        this._out = this._atop.ac.createGain(); // this._out.gain.value = initvolume; // RONYEH REMOVED DUE TO BUG.\n\n        this._out.gain.setTargetAtTime(initvolume, this._atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n\n        this._out.connect(this._atop.out); // As a last step, call all promised notifications.\n\n\n        for (j in finished) {\n          this._trigger(\"noteoff\", finished[j]);\n        }\n\n        for (j = 0; j < callbacks.length; ++j) {\n          callbacks[j].callback();\n        }\n      } // Future notes are scheduled relative to now(), which provides\n      // access to audioCurrentStartTime(), a time that holds steady\n      // until the script releases to the event loop.  When _now is\n      // non-null, it indicates that scheduling is already in progress.\n      // The timer-driven _doPoll function clears the cached _now.\n\n    }, {\n      key: \"now\",\n      value: function now() {\n        if (this._now != null) {\n          return this._now;\n        }\n\n        this._startPollTimer(true); // passing (true) sets this._now.\n\n\n        return this._now;\n      } // Register an event handler.  Done without jQuery to reduce dependencies.\n\n    }, {\n      key: \"on\",\n      value: function on(eventname, cb) {\n        if (!this._handlers.hasOwnProperty(eventname)) {\n          this._handlers[eventname] = [];\n        }\n\n        this._handlers[eventname].push(cb);\n      } // Unregister an event handler.  Done without jQuery to reduce dependencies.\n\n    }, {\n      key: \"off\",\n      value: function off(eventname, cb) {\n        if (this._handlers.hasOwnProperty(eventname)) {\n          if (!cb) {\n            this._handlers[eventname] = [];\n          } else {\n            var j,\n                hunt = this._handlers[eventname];\n\n            for (j = 0; j < hunt.length; ++j) {\n              if (hunt[j] === cb) {\n                hunt.splice(j, 1);\n                j -= 1;\n              }\n            }\n          }\n        }\n      } // Trigger an event, notifying any registered handlers.\n\n    }, {\n      key: \"_trigger\",\n      value: function _trigger(eventname, record) {\n        var cb = this._handlers[eventname],\n            j;\n\n        if (!cb) {\n          return;\n        }\n\n        if (cb.length == 1) {\n          // Special, common case of one handler: no copy needed.\n          cb[0](record);\n          return;\n        } // Copy the array of callbacks before iterating, because the\n        // main this._handlers copy could be changed by a handler.\n        // You get notified if-and-only-if you are registered\n        // at the starting moment of _trigger.\n\n\n        cb = cb.slice();\n\n        for (j = 0; j < cb.length; ++j) {\n          cb[j](record);\n        }\n      } // Tells the WebAudio API to play a tone (now or soon).  The passed\n      // record specifies a start time and release time, an ADSR envelope,\n      // and other timbre parameters.  This function sets up a WebAudio\n      // node graph for the tone generators and filters for the tone.\n\n    }, {\n      key: \"_makeSound\",\n      value: function _makeSound(record) {\n        var timbre = record.timbre || this._timbre,\n            starttime = record.time + Instrument.timeOffset,\n            releasetime = starttime + record.duration,\n            attacktime = Math.min(releasetime, starttime + timbre.attack),\n            decaytime = timbre.decay * Math.pow(440 / record.frequency, timbre.decayfollow),\n            decaystarttime = attacktime,\n            stoptime = releasetime + timbre.release,\n            doubled = timbre.detune && timbre.detune != 1.0,\n            amp = timbre.gain * record.velocity * (doubled ? 0.5 : 1.0),\n            ac = this._atop.ac,\n            g,\n            f,\n            o,\n            o2,\n            pwave,\n            k,\n            wf,\n            bwf; // Only hook up tone generators if it is an audible sound.\n\n        if (record.duration > 0 && record.velocity > 0) {\n          g = ac.createGain();\n          g.gain.setValueAtTime(0, starttime);\n          g.gain.linearRampToValueAtTime(amp, attacktime); // For the beginning of the decay, use linearRampToValue instead\n          // of setTargetAtTime, because it avoids http://crbug.com/254942.\n\n          while (decaystarttime < attacktime + 1 / 32 && decaystarttime + 1 / 256 < releasetime) {\n            // Just trace out the curve in increments of 1/256 sec\n            // for up to 1/32 seconds.\n            decaystarttime += 1 / 256;\n            g.gain.linearRampToValueAtTime(amp * (timbre.sustain + (1 - timbre.sustain) * Math.exp((attacktime - decaystarttime) / decaytime)), decaystarttime);\n          } // For the rest of the decay, use setTargetAtTime.\n\n\n          g.gain.setTargetAtTime(amp * timbre.sustain, decaystarttime, decaytime); // Then at release time, mark the value and ramp to zero.\n\n          g.gain.setValueAtTime(amp * (timbre.sustain + (1 - timbre.sustain) * Math.exp((attacktime - releasetime) / decaytime)), releasetime);\n          g.gain.linearRampToValueAtTime(0, stoptime);\n          g.connect(this._out); // Hook up a low-pass filter if cutoff is specified.\n\n          if (!timbre.cutoff && !timbre.cutfollow || timbre.cutoff == Infinity) {\n            f = g;\n          } else {\n            // Apply the cutoff frequency adjusted using cutfollow.\n            f = ac.createBiquadFilter(); // f.frequency.value = timbre.cutoff + record.frequency * timbre.cutfollow; // RONYEH REMOVED DUE TO BUG.\n            // f.Q.value = timbre.resonance; // RONYEH REMOVED DUE TO BUG.\n\n            f.frequency.setTargetAtTime(timbre.cutoff + record.frequency * timbre.cutfollow, this._atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n            f.Q.setTargetAtTime(timbre.resonance, this._atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n            f.connect(g);\n          } // Hook up the main oscillator.\n\n\n          o = Utils.makeOscillator(this._atop, timbre.wave, record.frequency);\n          o.connect(f);\n          o.start(starttime);\n          o.stop(stoptime); // Hook up a detuned oscillator.\n\n          if (doubled) {\n            o2 = Utils.makeOscillator(this._atop, timbre.wave, record.frequency * timbre.detune);\n            o2.connect(f);\n            o2.start(starttime);\n            o2.stop(stoptime);\n          } // Store nodes in the record so that they can be modified\n          // in case the tone is truncated later.\n\n\n          record.gainNode = g;\n          record.oscillators = [o];\n\n          if (doubled) {\n            record.oscillators.push(o2);\n          }\n\n          record.cleanuptime = stoptime;\n        } else {\n          // Inaudible sounds are scheduled: their purpose is to truncate\n          // audible tones at the same pitch.  But duration is set to zero\n          // so that they are cleaned up quickly.\n          record.duration = 0;\n        }\n\n        this._startSet.push(record);\n      } // Truncates a sound previously scheduled by _makeSound by using\n      // cancelScheduledValues and directly ramping down to zero.\n      // Can only be used to shorten a sound.\n\n    }, {\n      key: \"_truncateSound\",\n      value: function _truncateSound(record, truncatetime) {\n        if (truncatetime < record.time + record.duration) {\n          record.duration = Math.max(0, truncatetime - record.time);\n\n          if (record.gainNode) {\n            var timbre = record.timbre || this._timbre,\n                starttime = record.time + Instrument.timeOffset,\n                releasetime = truncatetime + Instrument.timeOffset,\n                attacktime = Math.min(releasetime, starttime + timbre.attack),\n                decaytime = timbre.decay * Math.pow(440 / record.frequency, timbre.decayfollow),\n                stoptime = releasetime + timbre.release,\n                cleanuptime = stoptime + Instrument.cleanupDelay,\n                doubled = timbre.detune && timbre.detune != 1.0,\n                amp = timbre.gain * record.velocity * (doubled ? 0.5 : 1.0),\n                j,\n                g = record.gainNode; // Cancel any envelope points after the new releasetime.\n\n            g.gain.cancelScheduledValues(releasetime);\n\n            if (releasetime <= starttime) {\n              // Release before start?  Totally silence the note.\n              g.gain.setValueAtTime(0, releasetime);\n            } else if (releasetime <= attacktime) {\n              // Release before attack is done?  Interrupt ramp up.\n              // g.gain.linearRampToValueAtTime((amp * (releasetime - starttime)) / (attacktime - starttime));\n              g.gain.linearRampToValueAtTime(amp * (releasetime - starttime) / (attacktime - starttime), starttime); // RONYEH ADDED SECOND PARAM \"starttime\".\n            } else {\n              // Release during decay?  Interrupt decay down.\n              g.gain.setValueAtTime(amp * (timbre.sustain + (1 - timbre.sustain) * Math.exp((attacktime - releasetime) / decaytime)), releasetime);\n            } // Then ramp down to zero according to record.release.\n\n\n            g.gain.linearRampToValueAtTime(0, stoptime); // After stoptime, stop the oscillators.  This is necessary to\n            // eliminate extra work for WebAudio for no-longer-audible notes.\n\n            if (record.oscillators) {\n              for (j = 0; j < record.oscillators.length; ++j) {\n                record.oscillators[j].stop(stoptime);\n              }\n            } // Schedule disconnect.\n\n\n            record.cleanuptime = cleanuptime;\n          }\n        }\n      } // The core scheduling loop is managed by Instrument._doPoll.  It reads\n      // the audiocontext's current time and pushes tone records from one\n      // stage to the next.\n      //\n      // 1. The first stage is the _queue, which has tones that have not\n      //    yet been given to WebAudio. This loop scans _queue to find\n      //    notes that need to begin in the next few seconds; then it\n      //    sends those to WebAduio and moves them to _startSet. Because\n      //    scheduled songs can be long, _queue can be large.\n      //\n      // 2. Second is _startSet, which has tones that have been given to\n      //    WebAudio, but whose start times have not yet elapsed. When\n      //    the time advances past the start time of a record, a 'noteon'\n      //    notification is fired for the tone, and it is moved to\n      //    _finishSet.\n      //\n      // 3. _finishSet represents the notes that are currently sounding.\n      //    The programming model for Instrument is that only one tone of\n      //    a specific frequency may be played at once within a Instrument,\n      //    so only one tone of a given frequency may exist in _finishSet\n      //    at once.  When there is a conflict, the sooner-to-end-note\n      //    is truncated.\n      //\n      // 4. After a note is released, it may have a litle release time\n      //    (depending on timbre.release), after which the nodes can\n      //    be totally disconnected and cleaned up.  _cleanupSet holds\n      //    notes for which we are awaiting cleanup.\n\n    }, {\n      key: \"_doPoll\",\n      value: function _doPoll() {\n        this._pollTimer = null;\n        this._now = null;\n\n        if (window.hasOwnProperty(\"interrupted\") && window[\"interrupted\"] === true) {\n          this.silence();\n          return;\n        } // The shortest time we can delay is 1 / 1000 secs, so if an event\n        // is within the next 0.5 ms, now is the closest moment, and we go\n        // ahead and process it.\n\n\n        var instant = this._atop.ac.currentTime + 1 / 2000,\n            callbacks = [],\n            j,\n            work,\n            when,\n            freq,\n            record,\n            conflict,\n            save,\n            cb; // Schedule a batch of notes\n\n        if (this._minQueueTime - instant <= Instrument.bufferSecs) {\n          if (this._unsortedQueue) {\n            this._queue.sort(function (a, b) {\n              if (a.time != b.time) {\n                return a.time - b.time;\n              }\n\n              if (a.duration != b.duration) {\n                return a.duration - b.duration;\n              }\n\n              return a.frequency - b.frequency;\n            });\n\n            this._unsortedQueue = false;\n          }\n\n          for (j = 0; j < this._queue.length; ++j) {\n            if (this._queue[j].time - instant > Instrument.bufferSecs) {\n              break;\n            }\n          }\n\n          if (j > 0) {\n            work = this._queue.splice(0, j);\n\n            for (j = 0; j < work.length; ++j) {\n              this._makeSound(work[j]);\n            }\n\n            this._minQueueTime = this._queue.length > 0 ? this._queue[0].time : Infinity;\n          }\n        } // Disconnect notes from the cleanup set.\n\n\n        for (j = 0; j < this._cleanupSet.length; ++j) {\n          record = this._cleanupSet[j];\n\n          if (record.cleanuptime < instant) {\n            if (record.gainNode) {\n              // This explicit disconnect is needed or else Chrome's WebAudio\n              // starts getting overloaded after a couple thousand notes.\n              record.gainNode.disconnect();\n              record.gainNode = null;\n            }\n\n            this._cleanupSet.splice(j, 1);\n\n            j -= 1;\n          }\n        } // Notify about any notes finishing.\n\n\n        for (freq in this._finishSet) {\n          record = this._finishSet[freq];\n          when = record.time + record.duration;\n\n          if (when <= instant) {\n            callbacks.push({\n              order: [when, 0],\n              f: this._trigger,\n              t: this,\n              a: [\"noteoff\", record]\n            });\n\n            if (record.cleanuptime != Infinity) {\n              this._cleanupSet.push(record);\n            }\n\n            delete this._finishSet[freq];\n          }\n        } // Call any specific one-time callbacks that were registered.\n\n\n        for (j = 0; j < this._callbackSet.length; ++j) {\n          cb = this._callbackSet[j];\n          when = cb.time;\n\n          if (when <= instant) {\n            callbacks.push({\n              order: [when, 1],\n              f: cb.callback,\n              t: null,\n              a: []\n            });\n\n            this._callbackSet.splice(j, 1);\n\n            j -= 1;\n          }\n        } // Notify about any notes starting.\n\n\n        for (j = 0; j < this._startSet.length; ++j) {\n          if (this._startSet[j].time <= instant) {\n            save = record = this._startSet[j];\n            freq = record.frequency;\n            conflict = null;\n\n            if (this._finishSet.hasOwnProperty(freq)) {\n              // If there is already a note at the same frequency playing,\n              // then release the one that starts first, immediately.\n              conflict = this._finishSet[freq];\n\n              if (conflict.time < record.time || conflict.time == record.time && conflict.duration < record.duration) {\n                // Our new sound conflicts with an old one: end the old one\n                // and notify immediately of its noteoff event.\n                this._truncateSound(conflict, record.time);\n\n                callbacks.push({\n                  order: [record.time, 0],\n                  f: this._trigger,\n                  t: this,\n                  a: [\"noteoff\", conflict]\n                });\n                delete this._finishSet[freq];\n              } else {\n                // A conflict from the future has already scheduled,\n                // so our own note shouldn't sound.  Truncate ourselves\n                // immediately, and suppress our own noteon and noteoff.\n                this._truncateSound(record, conflict.time);\n\n                conflict = record;\n              }\n            }\n\n            this._startSet.splice(j, 1);\n\n            j -= 1;\n\n            if (record.duration > 0 && record.velocity > 0 && conflict !== record) {\n              this._finishSet[freq] = record;\n              callbacks.push({\n                order: [record.time, 2],\n                f: this._trigger,\n                t: this,\n                a: [\"noteon\", record]\n              });\n            }\n          }\n        } // Schedule the next _doPoll.\n\n\n        this._startPollTimer(); // Sort callbacks according to the \"order\" tuple, so earlier events\n        // are notified first.\n\n\n        callbacks.sort(function (a, b) {\n          if (a.order[0] != b.order[0]) {\n            return a.order[0] - b.order[0];\n          } // tiebreak by notifying 'noteoff' first and 'noteon' last.\n\n\n          return a.order[1] - b.order[1];\n        }); // At the end, call all the callbacks without depending on \"this\" state.\n\n        for (j = 0; j < callbacks.length; ++j) {\n          cb = callbacks[j];\n          cb.f.apply(cb.t, cb.a);\n        }\n      } // Schedules the next _doPoll call by examining times in the various\n      // sets and determining the soonest event that needs _doPoll processing.\n\n    }, {\n      key: \"_startPollTimer\",\n      value: function _startPollTimer() {\n        var setnow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        // If we have already done a \"setnow\", then pollTimer is zero-timeout\n        // and cannot be faster.\n        if (this._pollTimer && this._now != null) {\n          return;\n        }\n\n        var self = this,\n            poll = function poll() {\n          self._doPoll();\n        },\n            earliest = Infinity,\n            j,\n            delay;\n\n        if (this._pollTimer) {\n          // Clear any old timer\n          clearTimeout(this._pollTimer);\n          this._pollTimer = null;\n        }\n\n        if (setnow) {\n          // When scheduling tones, cache _now and keep a zero-timeout poll.\n          // _now will be cleared the next time we execute _doPoll.\n          this._now = Utils.audioCurrentStartTime();\n          this._pollTimer = setTimeout(poll, 0);\n          return;\n        } // Timer due to notes starting: wake up for 'noteon' notification.\n\n\n        for (j = 0; j < this._startSet.length; ++j) {\n          earliest = Math.min(earliest, this._startSet[j].time);\n        } // Timer due to notes finishing: wake up for 'noteoff' notification.\n\n\n        for (j in this._finishSet) {\n          earliest = Math.min(earliest, this._finishSet[j].time + this._finishSet[j].duration);\n        } // Timer due to scheduled callback.\n\n\n        for (j = 0; j < this._callbackSet.length; ++j) {\n          earliest = Math.min(earliest, this._callbackSet[j].time);\n        } // Timer due to cleanup: add a second to give some time to batch up.\n\n\n        if (this._cleanupSet.length > 0) {\n          earliest = Math.min(earliest, this._cleanupSet[0].cleanuptime + 1);\n        } // Timer due to sequencer events: subtract a little time to stay ahead.\n\n\n        earliest = Math.min(earliest, this._minQueueTime - Instrument.dequeueTime);\n        delay = Math.max(0.001, earliest - this._atop.ac.currentTime); // If there are no future events, then we do not need a timer.\n\n        if (isNaN(delay) || delay == Infinity) {\n          return;\n        } // Use the Javascript timer to wake up at the right moment.\n\n\n        this._pollTimer = setTimeout(poll, Math.round(delay * 1000));\n      } // The low-level tone function.\n\n    }, {\n      key: \"tone\",\n      value: function tone(pitch, duration, velocity, delay, timbre, origin) {\n        // If audio is not present, this is a no-op.\n        if (!this._atop) {\n          return;\n        } // Called with an object instead of listed args.\n\n\n        if (typeof pitch == \"object\") {\n          if (velocity == null) velocity = pitch.velocity;\n          if (duration == null) duration = pitch.duration;\n          if (delay == null) delay = pitch.delay;\n          if (timbre == null) timbre = pitch.timbre;\n          if (origin == null) origin = pitch.origin;\n          pitch = pitch.pitch;\n        } // Convert pitch from various formats to Hz frequency and a midi num.\n\n\n        var midi, frequency;\n\n        if (!pitch) {\n          pitch = \"C\";\n        }\n\n        if (isNaN(pitch)) {\n          midi = Utils.pitchToMidi(pitch);\n          frequency = Utils.midiToFrequency(midi);\n        } else {\n          frequency = Number(pitch);\n\n          if (frequency < 0) {\n            midi = -frequency;\n            frequency = Utils.midiToFrequency(midi);\n          } else {\n            midi = Utils.frequencyToMidi(frequency);\n          }\n        }\n\n        if (!timbre) {\n          timbre = this._timbre;\n        } // If there is a custom timbre, validate and copy it.\n\n\n        if (timbre !== this._timbre) {\n          var given = timbre,\n              key;\n          timbre = {};\n\n          for (key in Utils.defaultTimbre) {\n            if (key in given) {\n              timbre[key] = given[key];\n            } else {\n              timbre[key] = Utils.defaultTimbre[key]; // RONYEH: There was a typo bug in the original Musical.js. It was caught by our TypeScript compiler.\n            }\n          }\n        } // Create the record for a tone.\n\n\n        var ac = this._atop.ac,\n            now = this.now(),\n            time = now + (delay || 0),\n            record = {\n          time: time,\n          on: false,\n          frequency: frequency,\n          midi: midi,\n          velocity: velocity == null ? 1 : velocity,\n          duration: duration == null ? Instrument.toneLength : duration,\n          timbre: timbre,\n          instrument: this,\n          gainNode: null,\n          oscillators: null,\n          cleanuptime: Infinity,\n          origin: origin // save the origin of the tone for visible feedback\n\n        };\n\n        if (time < now + Instrument.bufferSecs) {\n          // The tone starts soon!  Give it directly to WebAudio.\n          this._makeSound(record);\n        } else {\n          // The tone is later: queue it.\n          if (!this._unsortedQueue && this._queue.length && time < this._queue[this._queue.length - 1].time) {\n            this._unsortedQueue = true;\n          }\n\n          this._queue.push(record);\n\n          this._minQueueTime = Math.min(this._minQueueTime, record.time);\n        }\n      } // The low-level callback scheduling method.\n\n    }, {\n      key: \"schedule\",\n      value: function schedule(delay, callback) {\n        this._callbackSet.push({\n          time: this.now() + delay,\n          callback: callback\n        });\n      } // The high-level sequencing method.\n\n    }, {\n      key: \"play\",\n      value: function play(abcstring) {\n        var args = Array.prototype.slice.call(arguments),\n            done = null,\n            opts = {},\n            subfile,\n            abcfile,\n            argindex,\n            tempo,\n            timbre,\n            k,\n            delay,\n            maxdelay = 0,\n            attenuate,\n            voicename,\n            stems,\n            ni,\n            vn,\n            j,\n            stem,\n            note,\n            beatsecs,\n            secs,\n            v,\n            files = []; // Look for continuation as last argument.\n\n        if (args.length && \"function\" == typeof args[args.length - 1]) {\n          done = args.pop();\n        }\n\n        if (!this._atop) {\n          if (done) {\n            done();\n          }\n\n          return;\n        } // Look for options as first object.\n\n\n        argindex = 0;\n\n        if (\"object\" == typeof args[0]) {\n          // Copy own properties into an options object.\n          for (k in args[0]) {\n            if (args[0].hasOwnProperty(k)) {\n              opts[k] = args[0][k];\n            }\n          }\n\n          argindex = 1; // If a song is supplied by options object, process it.\n\n          if (opts.hasOwnProperty(\"song\")) {\n            args.push(opts[\"song\"]);\n          }\n        } // Parse any number of ABC files as input.\n\n\n        for (; argindex < args.length; ++argindex) {\n          // Handle splitting of ABC subfiles at X: lines.\n          subfile = args[argindex].split(/\\n(?=X:)/);\n\n          for (k = 0; k < subfile.length; ++k) {\n            abcfile = parseABCFile(subfile[k]);\n            if (!abcfile) continue; // Take tempo markings from the first file, and share them.\n\n            if (!opts.hasOwnProperty(\"tempo\") && abcfile.tempo) {\n              opts[\"tempo\"] = abcfile.tempo;\n\n              if (abcfile.unitbeat) {\n                opts[\"tempo\"] = opts[\"tempo\"] * abcfile.unitbeat / (abcfile.unitnote || 1);\n              }\n            } // Ignore files without songs.\n\n\n            if (!abcfile.voice) continue;\n            files.push(abcfile);\n          }\n        } // Default tempo to 120 if nothing else is specified.\n\n\n        if (!opts.hasOwnProperty(\"tempo\")) {\n          opts[\"tempo\"] = 120;\n        } // Default volume to 1 if nothing is specified.\n\n\n        if (!opts.hasOwnProperty(\"volume\")) {\n          opts[\"volume\"] = 1;\n        }\n\n        beatsecs = 60.0 / opts[\"tempo\"]; // Schedule all notes from all the files.\n\n        for (k = 0; k < files.length; ++k) {\n          abcfile = files[k]; // Each file can have multiple voices (e.g., left and right hands)\n\n          for (vn in abcfile.voice) {\n            // Each voice could have a separate timbre.\n            timbre = Utils.makeTimbre(opts[\"timbre\"] || abcfile.voice[vn].timbre || abcfile.timbre || this._timbre, this._atop); // Each voice has a series of stems (notes or chords).\n\n            stems = abcfile.voice[vn].stems;\n            if (!stems) continue; // Starting at delay zero (now), schedule all tones.\n\n            delay = 0;\n\n            for (ni = 0; ni < stems.length; ++ni) {\n              stem = stems[ni]; // Attenuate chords to reduce clipping.\n\n              attenuate = 1 / Math.sqrt(stem.notes.length); // Schedule every note inside a stem.\n\n              for (j = 0; j < stem.notes.length; ++j) {\n                note = stem.notes[j];\n\n                if (note.holdover) {\n                  // Skip holdover notes from ties.\n                  continue;\n                }\n\n                secs = (note.time || stem.time) * beatsecs;\n\n                if (stem.staccato) {\n                  // Shorten staccato notes.\n                  secs = Math.min(Math.min(secs, beatsecs / 16), timbre.attack + timbre.decay);\n                } else if (!note.slurred && secs >= 1 / 8) {\n                  // Separate unslurred notes by about a 30th of a second.\n                  secs -= 1 / 32;\n                }\n\n                v = (note.velocity || 1) * attenuate * opts[\"volume\"]; // This is innsermost part of the inner loop!\n\n                this.tone( // Play the tone:\n                note.pitch, // at the given pitch\n                secs, // for the given duration\n                v, // with the given volume\n                delay, // starting at the proper time\n                timbre, // with the selected timbre\n                note // the origin object for visual feedback\n                );\n              }\n\n              delay += stem.time * beatsecs; // Advance the sequenced time.\n            }\n\n            maxdelay = Math.max(delay, maxdelay);\n          }\n        }\n\n        this._maxScheduledTime = Math.max(this._maxScheduledTime, this.now() + maxdelay);\n\n        if (done) {\n          // Schedule a \"done\" callback after all sequencing is complete.\n          this.schedule(maxdelay, done);\n        }\n      }\n    }]);\n\n    return Instrument;\n  }(); //\n  // END INSTRUMENT\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"timeOffset\", 0.0625);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"dequeueTime\", 0.5);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"bufferSecs\", 2);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"toneLength\", 1);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"cleanupDelay\", 0.1);\n})(Musical || (Musical = {})); //////////////////////////////////////////////////////////////////////////////////////////////////\n// Musical JS\n\n\nvar _parseABCFile = parseABCFile;\n\n(function (_Musical2) {\n  var parseABCFile = _Musical2.parseABCFile = _parseABCFile;\n})(Musical || (Musical = {}));\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Musical);\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwcy9zaGFyZWQvc291bmQvTXVzaWNhbC50cz8wN2IxIl0sIm5hbWVzIjpbIm1ha2VXYXZldGFibGUiLCJhYyIsIndhdmVkYXRhIiwibWFrZVBlcmlvZGljV2F2ZSIsImRhdGEiLCJuIiwicmVhbCIsImxlbmd0aCIsIkZsb2F0MzJBcnJheSIsImltYWciLCJqIiwiY3JlYXRlUGVyaW9kaWNXYXZlIiwiZSIsImNyZWF0ZVdhdmVUYWJsZSIsIm1ha2VNdWx0aXBsZSIsIm11bHQiLCJhbXQiLCJyZXN1bHQiLCJtIiwiTWF0aCIsImxvZyIsIm1pbiIsInB1c2giLCJleHAiLCJrIiwiZCIsImZmIiwicmVjb3JkIiwid2F2ZSIsInB3IiwiZnJlcSIsImRlZnMiLCJwaWFubyIsImdhaW4iLCJhdHRhY2siLCJkZWNheSIsInN1c3RhaW4iLCJyZWxlYXNlIiwiZGVjYXlmb2xsb3ciLCJjdXRvZmYiLCJjdXRmb2xsb3ciLCJyZXNvbmFuY2UiLCJkZXR1bmUiLCJVdGlscyIsImdsb2JhbCIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsIl9hdWRpb1RvcCIsImlzQXVkaW9QcmVzZW50Iiwid2F2ZXRhYmxlIiwib3V0IiwiY3VycmVudFN0YXJ0IiwicmVzZXRBdWRpbyIsImF0b3AiLCJkaXNjb25uZWN0IiwiZGNuIiwiY3JlYXRlRHluYW1pY3NDb21wcmVzc29yIiwicmF0aW8iLCJzZXRWYWx1ZUF0VGltZSIsImNvbm5lY3QiLCJkZXN0aW5hdGlvbiIsImdldEF1ZGlvVG9wIiwibWF4IiwiY3VycmVudFRpbWUiLCJzZXRUaW1lb3V0IiwibWlkaSIsInBvdyIsInJvdW5kIiwiTE4yIiwicGl0Y2giLCJleGVjIiwib2N0YXZlIiwicmVwbGFjZSIsInNlbWl0b25lIiwibm90ZU51bSIsImFjY1N5bSIsImNoYXJBdCIsImluZGV4Iiwib2N0YXZlcyIsIm5vdGVOYW1lIiwibWlkaVRvRnJlcXVlbmN5IiwicGl0Y2hUb01pZGkiLCJvcHRpb25zIiwia2V5Iiwid3QiLCJkZWZhdWx0VGltYnJlIiwiaGFzT3duUHJvcGVydHkiLCJ3aGl0ZU5vaXNlQnVmIiwiYnVmZmVyU2l6ZSIsInNhbXBsZVJhdGUiLCJjcmVhdGVCdWZmZXIiLCJvdXRwdXQiLCJnZXRDaGFubmVsRGF0YSIsImkiLCJyYW5kb20iLCJ3YXZlbmFtZSIsIndoaXRlTm9pc2UiLCJjcmVhdGVCdWZmZXJTb3VyY2UiLCJidWZmZXIiLCJnZXRXaGl0ZU5vaXNlQnVmIiwibG9vcCIsIm8iLCJjcmVhdGVPc2NpbGxhdG9yIiwicHdhdmUiLCJid2YiLCJ3ZiIsIk51bWJlciIsInNldFBlcmlvZGljV2F2ZSIsInNldFdhdmVUYWJsZSIsInR5cGUiLCJ3aW5kb3ciLCJjb25zb2xlIiwiZnJlcXVlbmN5Iiwic2V0VGFyZ2V0QXRUaW1lIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJBIiwiQiIsImMiLCJmIiwiZyIsImEiLCJiIiwiXyIsIkFCQ2hlYWRlciIsIkFCQ3Rva2VuIiwicGFyc2VBQkNGaWxlIiwic3RyIiwibGluZXMiLCJzcGxpdCIsImNvbnRleHQiLCJ0aW1icmUiLCJoZWFkZXIiLCJzdGVtcyIsImFjY2VudCIsInNsdXJyZWQiLCJ2b2ljZWlkIiwiaGFuZGxlSW5mb3JtYXRpb24iLCJ0cmltIiwidGVzdCIsInBhcnNlQUJDTm90ZXMiLCJpbmZlciIsInZvaWNlIiwicHJvY2Vzc1RpZXMiLCJmaWVsZCIsInZhbHVlIiwic3RhcnRWb2ljZUNvbnRleHQiLCJwYXJzZU1ldGVyIiwicGFyc2VVbml0Tm90ZSIsInBhcnNlVGVtcG8iLCJrZXlzaWciLCJmaXJzdFZvaWNlTmFtZSIsImlkIiwiViIsInRva2VucyIsIm1hdGNoIiwicGFyc2VkIiwiZG90dGVkIiwiYmVhdGxldCIsInQiLCJzdWJzdHJpbmciLCJwYXJzZUJlYXRsZXQiLCJwYXJzZURlY29yYXRpb24iLCJzbHVyU3RlbSIsInBhcnNlU3RlbSIsInNjYWxlU3RlbSIsInN0ZW0iLCJ0aW1lIiwiY291bnQiLCJzeW5jb3BhdGVTdGVtIiwibWxpbmUiLCJiZWF0aW5mbyIsImR1cmF0aW9uVG9UaW1lIiwidW5pdG5vdGUiLCJsbGluZSIsInFsaW5lIiwicGFydHMiLCJ1bml0IiwidGVtcG8iLCJpbmRleE9mIiwidW5pdGJlYXQiLCJ0aWVkIiwibmV4dFRpZWQiLCJub3RlIiwiZmlyc3ROb3RlIiwibm90ZXMiLCJob2xkb3ZlciIsInRpZSIsImFjY2lkZW50YWxzIiwic2hhcnBzIiwia2V5bmFtZSIsImtrZXkiLCJzaWdjb2RlcyIsImJiIiwiZWIiLCJhYiIsImRiIiwiZ2IiLCJjYiIsImJtIiwiZW0iLCJhbSIsImRtIiwiZ20iLCJjbSIsImZtIiwiYmJtIiwiZWJtIiwiYWJtIiwiYm1peCIsImVtaXgiLCJhbWl4IiwiZG1peCIsImdtaXgiLCJjbWl4IiwiZm1peCIsImJibWl4IiwiZWJtaXgiLCJhYm1peCIsImRibWl4IiwiZ2JtaXgiLCJiZG9yIiwiZWRvciIsImFkb3IiLCJkZG9yIiwiZ2RvciIsImNkb3IiLCJmZG9yIiwiYmJkb3IiLCJlYmRvciIsImFiZG9yIiwiZGJkb3IiLCJicGhyIiwiZXBociIsImFwaHIiLCJkcGhyIiwiZ3BociIsImNwaHIiLCJmcGhyIiwiYmJwaHIiLCJlYnBociIsImJseWQiLCJlbHlkIiwiYWx5ZCIsImRseWQiLCJnbHlkIiwiY2x5ZCIsImZseWQiLCJiYmx5ZCIsImVibHlkIiwiYWJseWQiLCJkYmx5ZCIsImdibHlkIiwiY2JseWQiLCJmYmx5ZCIsImJsb2MiLCJlbG9jIiwiYWxvYyIsImRsb2MiLCJnbG9jIiwiY2xvYyIsImZsb2MiLCJiYmxvYyIsInRvTG93ZXJDYXNlIiwic3Vic3RyIiwic2NhbGUiLCJleHRyYXMiLCJ0b1VwcGVyQ2FzZSIsInN0ZW10aW1lIiwibmV3dGltZSIsImFkZFNsdXIiLCJzIiwidG9rZW4iLCJiZWF0cyIsImR1cmF0aW9uIiwiZHluYW1pY3MiLCJzdGFjY2F0byIsIm5vdGVEdXJhdGlvbiIsIm5vdGVUaW1lIiwidmVsb2NpdHkiLCJsYXN0Tm90ZSIsIm1pblN0ZW1UaW1lIiwiSW5maW5pdHkiLCJhcHBseUFjY2VudCIsInBpdGNoVG9GcmVxdWVuY3kiLCJzdHJpcE5hdHVyYWwiLCJsZXR0ZXIiLCJpbGVuIiwicGFyc2VGbG9hdCIsIkluc3RydW1lbnQiLCJtaWRpVG9QaXRjaCIsIl9hdG9wIiwiX3RpbWJyZSIsIm1ha2VUaW1icmUiLCJfcXVldWUiLCJfbWluUXVldWVUaW1lIiwiX21heFNjaGVkdWxlZFRpbWUiLCJfdW5zb3J0ZWRRdWV1ZSIsIl9zdGFydFNldCIsIl9maW5pc2hTZXQiLCJfY2xlYW51cFNldCIsIl9jYWxsYmFja1NldCIsIl9oYW5kbGVycyIsIl9ub3ciLCJzaWxlbmNlIiwidiIsIl9vdXQiLCJpc05hTiIsImZpbmlzaGVkIiwiY2FsbGJhY2tzIiwiaW5pdHZvbHVtZSIsImNyZWF0ZUdhaW4iLCJfdHJpZ2dlciIsImNhbGxiYWNrIiwiX3N0YXJ0UG9sbFRpbWVyIiwiZXZlbnRuYW1lIiwiaHVudCIsInNwbGljZSIsInNsaWNlIiwic3RhcnR0aW1lIiwidGltZU9mZnNldCIsInJlbGVhc2V0aW1lIiwiYXR0YWNrdGltZSIsImRlY2F5dGltZSIsImRlY2F5c3RhcnR0aW1lIiwic3RvcHRpbWUiLCJkb3VibGVkIiwiYW1wIiwibzIiLCJsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZSIsImNyZWF0ZUJpcXVhZEZpbHRlciIsIlEiLCJtYWtlT3NjaWxsYXRvciIsInN0YXJ0Iiwic3RvcCIsImdhaW5Ob2RlIiwib3NjaWxsYXRvcnMiLCJjbGVhbnVwdGltZSIsInRydW5jYXRldGltZSIsImNsZWFudXBEZWxheSIsImNhbmNlbFNjaGVkdWxlZFZhbHVlcyIsIl9wb2xsVGltZXIiLCJpbnN0YW50Iiwid29yayIsIndoZW4iLCJjb25mbGljdCIsInNhdmUiLCJidWZmZXJTZWNzIiwic29ydCIsIl9tYWtlU291bmQiLCJvcmRlciIsIl90cnVuY2F0ZVNvdW5kIiwiYXBwbHkiLCJzZXRub3ciLCJzZWxmIiwicG9sbCIsIl9kb1BvbGwiLCJlYXJsaWVzdCIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwiYXVkaW9DdXJyZW50U3RhcnRUaW1lIiwiZGVxdWV1ZVRpbWUiLCJvcmlnaW4iLCJmcmVxdWVuY3lUb01pZGkiLCJnaXZlbiIsIm5vdyIsIm9uIiwidG9uZUxlbmd0aCIsImluc3RydW1lbnQiLCJhYmNzdHJpbmciLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYXJndW1lbnRzIiwiZG9uZSIsIm9wdHMiLCJzdWJmaWxlIiwiYWJjZmlsZSIsImFyZ2luZGV4IiwibWF4ZGVsYXkiLCJhdHRlbnVhdGUiLCJ2b2ljZW5hbWUiLCJuaSIsInZuIiwiYmVhdHNlY3MiLCJzZWNzIiwiZmlsZXMiLCJwb3AiLCJzcXJ0IiwidG9uZSIsInNjaGVkdWxlIiwiTXVzaWNhbCIsIl9wYXJzZUFCQ0ZpbGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBOzs7O0FBR0k7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsTUFBTUEsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixDQUFVQyxFQUFWLEVBQWM7QUFDaEMsV0FBUSxVQUFVQyxRQUFWLEVBQW9CO0FBQ3hCLGVBQVNDLGdCQUFULENBQTBCQyxJQUExQixFQUFnQztBQUM1QixZQUFJQyxDQUFDLEdBQUdELElBQUksQ0FBQ0UsSUFBTCxDQUFVQyxNQUFsQjtBQUFBLFlBQ0lELElBQUksR0FBRyxJQUFJRSxZQUFKLENBQWlCSCxDQUFqQixDQURYO0FBQUEsWUFFSUksSUFBSSxHQUFHLElBQUlELFlBQUosQ0FBaUJILENBQWpCLENBRlg7QUFBQSxZQUdJSyxDQUhKOztBQUlBLGFBQUtBLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR0wsQ0FBaEIsRUFBbUIsRUFBRUssQ0FBckIsRUFBd0I7QUFDcEJKLGNBQUksQ0FBQ0ksQ0FBRCxDQUFKLEdBQVVOLElBQUksQ0FBQ0UsSUFBTCxDQUFVSSxDQUFWLENBQVY7QUFDQUQsY0FBSSxDQUFDQyxDQUFELENBQUosR0FBVU4sSUFBSSxD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LEVBQWdCc0IsUUFBaEIsQ0FBWDtBQUNIO0FBQ0o7O0FBQ0QsYUFBS3BGLGlCQUFMLEdBQXlCeFIsSUFBSSxDQUFDMkMsR0FBTCxDQUFTLEtBQUs2TyxpQkFBZCxFQUFpQyxLQUFLcUUsR0FBTCxLQUFhZSxRQUE5QyxDQUF6Qjs7QUFDQSxZQUFJTCxJQUFKLEVBQVU7QUFDTjtBQUNBLGVBQUtnQixRQUFMLENBQWNYLFFBQWQsRUFBd0JMLElBQXhCO0FBQ0g7QUFDSjs7OztPQUdMO0FBQ0E7QUFDQTs7OzBKQS93Qk10RixVLGdCQUNrQixNOzswSkFEbEJBLFUsaUJBRW1CLEc7OzBKQUZuQkEsVSxnQkFHa0IsQzs7MEpBSGxCQSxVLGdCQUlrQixDOzswSkFKbEJBLFUsa0JBS29CLEc7R0FydUNwQnVHLE8sS0FBQUEsTyxTQWkvRFY7QUFDQTs7O0FBR0EsSUFBTUMsYUFBYSxHQUFHM1EsWUFBdEI7OztBQUlXLE1BQU1BLFlBQVksNEJBQUcyUSxhQUFyQjtHQUZERCxPLEtBQUFBLE87O0FBS0tBLHNFQUFmIiwiZmlsZSI6Ii4vYXBwcy9zaGFyZWQvc291bmQvTXVzaWNhbC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIG11c2ljYWwuanNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9QZW5jaWxDb2RlL211c2ljYWwuanNcblxubmFtZXNwYWNlIE11c2ljYWwge1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gV0FWRVRBQkxFLUJVSUxERVJcblxuICAgIC8vIHdhdmV0YWJsZSBpcyBhIHRhYmxlIG9mIG5hbWVzIGZvciBub25zdGFuZGFyZCB3YXZlZm9ybXMuXG4gICAgLy8gVGhlIHRhYmxlIG1hcHMgbmFtZXMgdG8gb2JqZWN0cyB0aGF0IGhhdmUgd2F2ZTogYW5kIGZyZXE6XG4gICAgLy8gcHJvcGVydGllcy4gVGhlIHdhdmU6IHByb3BlcnR5IGlzIGEgUGVyaW9kaWNXYXZlIHRvIHVzZVxuICAgIC8vIGZvciB0aGUgb3NjaWxsYXRvci4gIFRoZSBmcmVxOiBwcm9wZXJ0eSwgaWYgcHJlc2VudCxcbiAgICAvLyBpcyBhIG1hcCBmcm9tIGhpZ2hlciBmcmVxdWVuY2llcyB0byBtb3JlIFBlcmlvZGljV2F2ZVxuICAgIC8vIG9iamVjdHM7IHdoZW4gYSBmcmVxdWVuY3kgaGlnaGVyIHRoYW4gdGhlIGdpdmVuIHRocmVzaG9sZFxuICAgIC8vIGlzIHJlcXVlc3RlZCwgdGhlIGFsdGVybmF0ZSBQZXJpb2RpY1dhdmUgaXMgdXNlZC5cblxuICAgIGNvbnN0IG1ha2VXYXZldGFibGUgPSBmdW5jdGlvbiAoYWMpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAod2F2ZWRhdGEpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIG1ha2VQZXJpb2RpY1dhdmUoZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBuID0gZGF0YS5yZWFsLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgcmVhbCA9IG5ldyBGbG9hdDMyQXJyYXkobiksXG4gICAgICAgICAgICAgICAgICAgIGltYWcgPSBuZXcgRmxvYXQzMkFycmF5KG4pLFxuICAgICAgICAgICAgICAgICAgICBqO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhbFtqXSA9IGRhdGEucmVhbFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaW1hZ1tqXSA9IGRhdGEuaW1hZ1tqXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGF0ZXN0IEFQSSBuYW1pbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhYy5jcmVhdGVQZXJpb2RpY1dhdmUocmVhbCwgaW1hZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFYXJsaWVyIEFQSSBuYW1pbmcuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhYy5jcmVhdGVXYXZlVGFibGUocmVhbCwgaW1hZyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIG1ha2VNdWx0aXBsZShkYXRhLCBtdWx0LCBhbXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0geyByZWFsOiBbXSwgaW1hZzogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICAgICAgbiA9IGRhdGEucmVhbC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG07XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgICAgICAgICAgICAgICBtID0gTWF0aC5sb2cobXVsdFtNYXRoLm1pbihqLCBtdWx0Lmxlbmd0aCAtIDEpXSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZWFsLnB1c2goZGF0YS5yZWFsW2pdICogTWF0aC5leHAoYW10ICogbSkpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuaW1hZy5wdXNoKGRhdGEuaW1hZ1tqXSAqIE1hdGguZXhwKGFtdCAqIG0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGZmLFxuICAgICAgICAgICAgICAgIHJlY29yZCxcbiAgICAgICAgICAgICAgICB3YXZlLFxuICAgICAgICAgICAgICAgIHB3O1xuICAgICAgICAgICAgZm9yIChrIGluIHdhdmVkYXRhKSB7XG4gICAgICAgICAgICAgICAgZCA9IHdhdmVkYXRhW2tdO1xuICAgICAgICAgICAgICAgIHdhdmUgPSBtYWtlUGVyaW9kaWNXYXZlKGQpO1xuICAgICAgICAgICAgICAgIGlmICghd2F2ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVjb3JkID0geyB3YXZlOiB3YXZlIH07XG4gICAgICAgICAgICAgICAgLy8gQSBzdHJhdGVneSBmb3IgY29tcHV0aW5nIGhpZ2hlciBmcmVxdWVuY3kgd2F2ZWZvcm1zOiBhcHBseVxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGxpZXJzIHRvIGVhY2ggaGFybW9uaWMgYWNjb3JkaW5nIHRvIGQubXVsdC4gIFRoZXNlXG4gICAgICAgICAgICAgICAgLy8gbXVsdGlwbGllcnMgY2FuIGJlIGludGVycG9sYXRlZCBhbmQgYXBwbGllZCBhdCBhbnkgbnVtYmVyXG4gICAgICAgICAgICAgICAgLy8gb2YgdHJhbnNpdGlvbiBmcmVxdWVuY2llcy5cbiAgICAgICAgICAgICAgICBpZiAoZC5tdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZmID0gd2F2ZWRhdGFba10uZnJlcTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmZyZXEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGZmLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YXZlID0gbWFrZVBlcmlvZGljV2F2ZShtYWtlTXVsdGlwbGUoZCwgZC5tdWx0LCAoaiArIDEpIC8gZmYubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2F2ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZC5mcmVxW2ZmW2pdXSA9IHdhdmU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3YXZlIGhhcyBzb21lIGRlZmF1bHQgZmlsdGVyIHNldHRpbmdzLlxuICAgICAgICAgICAgICAgIGlmIChkLmRlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmRlZnMgPSBkLmRlZnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdFtrXSA9IHJlY29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKHtcbiAgICAgICAgICAgIC8vIEN1cnJlbnRseSB0aGUgb25seSBub25zdGFuZGFyZCB3YXZlZm9ybSBpcyBcInBpYW5vXCIuXG4gICAgICAgICAgICAvLyBJdCBpcyBiYXNlZCBvbiB0aGUgZmlyc3QgMzIgaGFybW9uaWNzIGZyb20gdGhlIGV4YW1wbGU6XG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vR29vZ2xlQ2hyb21lL3dlYi1hdWRpby1zYW1wbGVzXG4gICAgICAgICAgICAvLyAvYmxvYi9naC1wYWdlcy9zYW1wbGVzL2F1ZGlvL3dhdmUtdGFibGVzL1BpYW5vXG4gICAgICAgICAgICAvLyBUaGF0IGlzIGEgdGVycmlmaWMgc291bmQgZm9yIHRoZSBsb3dlc3QgcGlhbm8gdG9uZXMuXG4gICAgICAgICAgICAvLyBGb3IgaGlnaGVyIHRvbmVzLCBpbnRlcnBvbGF0ZSB0byBhIGN1c3RvbXplZCB3YXZlXG4gICAgICAgICAgICAvLyBzaGFwZSBjcmVhdGVkIGJ5IGhhbmQsIGFuZCBhcHBseSBhIGxvd3Bhc3MgZmlsdGVyLlxuICAgICAgICAgICAgcGlhbm86IHtcbiAgICAgICAgICAgICAgICByZWFsOiBbXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIC0wLjIwMzU2OSxcbiAgICAgICAgICAgICAgICAgICAgMC41LFxuICAgICAgICAgICAgICAgICAgICAtMC40MDE2NzYsXG4gICAgICAgICAgICAgICAgICAgIDAuMTM3MTI4LFxuICAgICAgICAgICAgICAgICAgICAtMC4xMDQxMTcsXG4gICAgICAgICAgICAgICAgICAgIDAuMTE1OTY1LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDQ0MTMsXG4gICAgICAgICAgICAgICAgICAgIDAuMDY3ODg0LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDg4OCxcbiAgICAgICAgICAgICAgICAgICAgMC4wNzkzLFxuICAgICAgICAgICAgICAgICAgICAtMC4wMzg3NTYsXG4gICAgICAgICAgICAgICAgICAgIDAuMDExODgyLFxuICAgICAgICAgICAgICAgICAgICAtMC4wMzA4ODMsXG4gICAgICAgICAgICAgICAgICAgIDAuMDI3NjA4LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMTM0MjksXG4gICAgICAgICAgICAgICAgICAgIDAuMDAzOTMsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAxNDAyOSxcbiAgICAgICAgICAgICAgICAgICAgMC4wMDk3MixcbiAgICAgICAgICAgICAgICAgICAgLTAuMDA3NjUzLFxuICAgICAgICAgICAgICAgICAgICAwLjAwNzg2NixcbiAgICAgICAgICAgICAgICAgICAgLTAuMDMyMDI5LFxuICAgICAgICAgICAgICAgICAgICAwLjA0NjEyNyxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDI0MTU1LFxuICAgICAgICAgICAgICAgICAgICAwLjAyMzA5NSxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDA1NTIyLFxuICAgICAgICAgICAgICAgICAgICAwLjAwNDUxMSxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAzNTkzLFxuICAgICAgICAgICAgICAgICAgICAwLjAxMTI0OCxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDA0OTE5LFxuICAgICAgICAgICAgICAgICAgICAwLjAwODUwNSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGltYWc6IFtcbiAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgMC4xNDc2MjEsXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA3LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMSxcbiAgICAgICAgICAgICAgICAgICAgMC4wMDAwMDUsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAwMDAwNixcbiAgICAgICAgICAgICAgICAgICAgMC4wMDAwMDksXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA4LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDEsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDE0LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDgsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDAzLFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDksXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA5LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDUsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDAyLFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDcsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA1LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDUsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA1LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMjMsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDM3LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMjEsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDIyLFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDYsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA1LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDQsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDE0LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDcsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDEyLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgLy8gSG93IHRvIGFkanVzdCB0aGUgaGFybW9uaWNzIGZvciB0aGUgaGlnZXN0IG5vdGVzLlxuICAgICAgICAgICAgICAgIG11bHQ6IFsxLCAxLCAwLjE4LCAwLjAxNiwgMC4wMSwgMC4wMSwgMC4wMSwgMC4wMDQsIDAuMDE0LCAwLjAyLCAwLjAxNCwgMC4wMDQsIDAuMDAyLCAwLjAwMDAxXSxcbiAgICAgICAgICAgICAgICAvLyBUaGUgZnJlcXVlbmNpZXMgYXQgd2hpY2ggdG8gaW50ZXJwb2xhdGUgdGhlIGhhcm1vbmljcy5cbiAgICAgICAgICAgICAgICBmcmVxOiBbNjUsIDgwLCAxMDAsIDEzNSwgMTgwLCAyNDAsIDYyMCwgMTM2MF0sXG4gICAgICAgICAgICAgICAgLy8gVGhlIGRlZmF1bHQgZmlsdGVyIHNldHRpbmdzIHRvIHVzZSBmb3IgdGhlIHBpYW5vIHdhdmUuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBhcHByb2FjaCBhdHRlbnVhdGVzIGxvdyBub3RlcyB0b28gbXVjaCAtXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBzaG91bGQgYmUgZml4ZWQuXG4gICAgICAgICAgICAgICAgZGVmczogeyB3YXZlOiBcInBpYW5vXCIsIGdhaW46IDAuNSwgYXR0YWNrOiAwLjAwMiwgZGVjYXk6IDAuMjUsIHN1c3RhaW46IDAuMDMsIHJlbGVhc2U6IDAuMSwgZGVjYXlmb2xsb3c6IDAuNywgY3V0b2ZmOiA4MDAsIGN1dGZvbGxvdzogMC4xLCByZXNvbmFuY2U6IDEsIGRldHVuZTogMC45OTk0IH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgLy8gRU5EIFdBVkVUQUJMRS1CVUlMREVSXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gVVRJTFNcblxuICAgIGNsYXNzIFV0aWxzIHtcbiAgICAgICAgLy8gVGVzdHMgZm9yIHRoZSBwcmVzZW5jZSBvZiBIVE1MNSBXZWIgQXVkaW8gKG9yIHdlYmtpdCdzIHZlcnNpb24pLlxuICAgICAgICBzdGF0aWMgaXNBdWRpb1ByZXNlbnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gISEoZ2xvYmFsLkF1ZGlvQ29udGV4dCB8fCBnbG9iYWwud2Via2l0QXVkaW9Db250ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFsbCBvdXIgYXVkaW8gZnVubmVscyB0aHJvdWdoIHRoZSBzYW1lIEF1ZGlvQ29udGV4dCB3aXRoIGFcbiAgICAgICAgLy8gRHluYW1pY3NDb21wcmVzc29yTm9kZSB1c2VkIGFzIHRoZSBtYWluIG91dHB1dCwgdG8gY29tcHJlc3MgdGhlXG4gICAgICAgIC8vIGR5bmFtaWMgcmFuZ2Ugb2YgYWxsIGF1ZGlvLiAgZ2V0QXVkaW9Ub3Agc2V0cyB0aGlzIHVwLlxuICAgICAgICBwcml2YXRlIHN0YXRpYyBfYXVkaW9Ub3AgPSBudWxsO1xuICAgICAgICBzdGF0aWMgZ2V0QXVkaW9Ub3AoKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuX2F1ZGlvVG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLl9hdWRpb1RvcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghVXRpbHMuaXNBdWRpb1ByZXNlbnQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjID0gbmV3IChnbG9iYWwuQXVkaW9Db250ZXh0IHx8IGdsb2JhbC53ZWJraXRBdWRpb0NvbnRleHQpKCk7XG4gICAgICAgICAgICBVdGlscy5fYXVkaW9Ub3AgPSB7XG4gICAgICAgICAgICAgICAgYWM6IGFjLFxuICAgICAgICAgICAgICAgIHdhdmV0YWJsZTogbWFrZVdhdmV0YWJsZShhYyksXG4gICAgICAgICAgICAgICAgb3V0OiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdGFydDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBVdGlscy5yZXNldEF1ZGlvKCk7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuX2F1ZGlvVG9wO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2hlbiBhdWRpbyBuZWVkcyB0byBiZSBpbnRlcnJ1cHRlZCBnbG9iYWxseSAoZS5nLiwgd2hlbiB5b3UgcHJlc3MgdGhlXG4gICAgICAgIC8vIHN0b3AgYnV0dG9uIGluIHRoZSBJREUpLCByZXNldEF1ZGlvIGRvZXMgdGhlIGpvYi5cbiAgICAgICAgc3RhdGljIHJlc2V0QXVkaW8oKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuX2F1ZGlvVG9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF0b3AgPSBVdGlscy5fYXVkaW9Ub3A7XG4gICAgICAgICAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgdG9wLWxldmVsIG5vZGUgYW5kIG1ha2UgYSBuZXcgb25lLlxuICAgICAgICAgICAgICAgIGlmIChhdG9wLm91dCkge1xuICAgICAgICAgICAgICAgICAgICBhdG9wLm91dC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGF0b3Aub3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgYXRvcC5jdXJyZW50U3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgZGNuID0gYXRvcC5hYy5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcbiAgICAgICAgICAgICAgICBkY24ucmF0aW8uc2V0VmFsdWVBdFRpbWUoMTYsIDApO1xuICAgICAgICAgICAgICAgIGRjbi5hdHRhY2suc2V0VmFsdWVBdFRpbWUoMC4wMDA1LCAwKTtcbiAgICAgICAgICAgICAgICAvLyBkY24ucmF0aW8gPSAxNjsgLy8gUk9OWUVIOiAucmF0aW8gaXMgYSBSRUFEIE9OTFkgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gZGNuLmF0dGFjayA9IDAuMDAwNTsgLy8gUk9OWUVIOiAucmF0aW8gaXMgYSBSRUFEIE9OTFkgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgZGNuLmNvbm5lY3QoYXRvcC5hYy5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgYXRvcC5vdXQgPSBkY247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgcHJlY2lzZSBzY2hlZHVsaW5nIG9mIGZ1dHVyZSBub3RlcywgdGhlIEF1ZGlvQ29udGV4dCBjdXJyZW50VGltZSBpc1xuICAgICAgICAvLyBjYWNoZWQgYW5kIGlzIGhlbGQgY29uc3RhbnQgdW50aWwgdGhlIHNjcmlwdCByZWxlYXNlcyB0byB0aGUgZXZlbnQgbG9vcC5cbiAgICAgICAgc3RhdGljIGF1ZGlvQ3VycmVudFN0YXJ0VGltZSgpIHtcbiAgICAgICAgICAgIHZhciBhdG9wID0gVXRpbHMuZ2V0QXVkaW9Ub3AoKTtcbiAgICAgICAgICAgIGlmIChhdG9wLmN1cnJlbnRTdGFydCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF0b3AuY3VycmVudFN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQSBkZWxheSBjb3VsZCBiZSBhZGRlZCBiZWxvdyB0byBpbnRyb2R1Y2UgYSB1bml2ZXJzYWwgZGVsYXkgaW5cbiAgICAgICAgICAgIC8vIGFsbCBiZWdpbm5pbmcgc291bmRzICh3aXRob3V0IHNrZXdpbmcgZHVyYXRpb25zIGZvciBzY2hlZHVsZWRcbiAgICAgICAgICAgIC8vIHNlcXVlbmNlcykuXG4gICAgICAgICAgICBhdG9wLmN1cnJlbnRTdGFydCA9IE1hdGgubWF4KDAuMjUsIGF0b3AuYWMuY3VycmVudFRpbWUgLyogKyAwLjAgZGVsYXkgKi8pO1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgYXRvcC5jdXJyZW50U3RhcnQgPSBudWxsO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICByZXR1cm4gYXRvcC5jdXJyZW50U3RhcnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0cyBhIG1pZGkgbm90ZSBudW1iZXIgdG8gYSBmcmVxdWVuY3kgaW4gSHouXG4gICAgICAgIHN0YXRpYyBtaWRpVG9GcmVxdWVuY3kobWlkaSkge1xuICAgICAgICAgICAgcmV0dXJuIDQ0MCAqIE1hdGgucG93KDIsIChtaWRpIC0gNjkpIC8gMTIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU29tZSBjb25zdGFudHMuXG4gICAgICAgIHN0YXRpYyBub3RlTnVtID0geyBDOiAwLCBEOiAyLCBFOiA0LCBGOiA1LCBHOiA3LCBBOiA5LCBCOiAxMSwgYzogMTIsIGQ6IDE0LCBlOiAxNiwgZjogMTcsIGc6IDE5LCBhOiAyMSwgYjogMjMgfTtcbiAgICAgICAgc3RhdGljIGFjY1N5bSA9IHsgXCJeXCI6IDEsIFwiXCI6IDAsIFwiPVwiOiAwLCBfOiAtMSB9O1xuICAgICAgICBzdGF0aWMgbm90ZU5hbWUgPSBbXCJDXCIsIFwiXkNcIiwgXCJEXCIsIFwiX0VcIiwgXCJFXCIsIFwiRlwiLCBcIl5GXCIsIFwiR1wiLCBcIl9BXCIsIFwiQVwiLCBcIl9CXCIsIFwiQlwiLCBcImNcIiwgXCJeY1wiLCBcImRcIiwgXCJfZVwiLCBcImVcIiwgXCJmXCIsIFwiXmZcIiwgXCJnXCIsIFwiX2FcIiwgXCJhXCIsIFwiX2JcIiwgXCJiXCJdO1xuXG4gICAgICAgIC8vIENvbnZlcnRzIGEgZnJlcXVlbmN5IGluIEh6IHRvIHRoZSBjbG9zZXN0IG1pZGkgbnVtYmVyLlxuICAgICAgICBzdGF0aWMgZnJlcXVlbmN5VG9NaWRpKGZyZXEpIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKDY5ICsgKE1hdGgubG9nKGZyZXEgLyA0NDApICogMTIpIC8gTWF0aC5MTjIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydHMgYW4gQUJDIHBpdGNoIChzdWNoIGFzIFwiXkcsLFwiKSB0byBhIG1pZGkgbm90ZSBudW1iZXIuXG4gICAgICAgIHN0YXRpYyBwaXRjaFRvTWlkaShwaXRjaCkge1xuICAgICAgICAgICAgdmFyIG0gPSAvXihcXF4rfF8rfD18KShbQS1HYS1nXSkoWywnXSopJC8uZXhlYyhwaXRjaCk7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvY3RhdmUgPSBtWzNdLnJlcGxhY2UoLywvZywgXCJcIikubGVuZ3RoIC0gbVszXS5yZXBsYWNlKC8nL2csIFwiXCIpLmxlbmd0aDtcbiAgICAgICAgICAgIHZhciBzZW1pdG9uZSA9IFV0aWxzLm5vdGVOdW1bbVsyXV0gKyBVdGlscy5hY2NTeW1bbVsxXS5jaGFyQXQoMCldICogbVsxXS5sZW5ndGggKyAxMiAqIG9jdGF2ZTtcbiAgICAgICAgICAgIHJldHVybiBzZW1pdG9uZSArIDYwOyAvLyA2MCA9IG1pZGkgY29kZSBtaWRkbGUgXCJDXCIuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBDb252ZXJ0cyBhIG1pZGkgbnVtYmVyIHRvIGFuIEFCQyBub3RhdGlvbiBwaXRjaC5cbiAgICAgICAgc3RhdGljIG1pZGlUb1BpdGNoKG1pZGkpIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IChtaWRpIC0gNzIpICUgMTI7XG4gICAgICAgICAgICBpZiAobWlkaSA+IDYwIHx8IGluZGV4ICE9IDApIHtcbiAgICAgICAgICAgICAgICBpbmRleCArPSAxMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvY3RhdmVzID0gTWF0aC5yb3VuZCgobWlkaSAtIGluZGV4IC0gNjApIC8gMTIpLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IFV0aWxzLm5vdGVOYW1lW2luZGV4XTtcbiAgICAgICAgICAgIHdoaWxlIChvY3RhdmVzICE9IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gb2N0YXZlcyA+IDAgPyBcIidcIiA6IFwiLFwiO1xuICAgICAgICAgICAgICAgIG9jdGF2ZXMgKz0gb2N0YXZlcyA+IDAgPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydHMgYW4gQUJDIHBpdGNoIHRvIGEgZnJlcXVlbmN5IGluIEh6LlxuICAgICAgICBzdGF0aWMgcGl0Y2hUb0ZyZXF1ZW5jeShwaXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLm1pZGlUb0ZyZXF1ZW5jeShVdGlscy5waXRjaFRvTWlkaShwaXRjaCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGRlZmF1bHQgc291bmQgaXMgYSBzcXVhcmUgd2F2ZSB3aXRoIGEgcHJldHR5IHF1aWNrIGRlY2F5IHRvIHplcm8uXG4gICAgICAgIHN0YXRpYyBkZWZhdWx0VGltYnJlID0ge1xuICAgICAgICAgICAgd2F2ZTogXCJzcXVhcmVcIiwgLy8gT3NjaWxsYXRvciB0eXBlLlxuICAgICAgICAgICAgZ2FpbjogMC4xLCAvLyBPdmVyYWxsIGdhaW4gYXQgbWF4aW11bSBhdHRhY2suXG4gICAgICAgICAgICBhdHRhY2s6IDAuMDAyLCAvLyBBdHRhY2sgdGltZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgdG9uZS5cbiAgICAgICAgICAgIGRlY2F5OiAwLjQsIC8vIFJhdGUgb2YgZXhwb25lbnRpYWwgZGVjYXkgYWZ0ZXIgYXR0YWNrLlxuICAgICAgICAgICAgZGVjYXlmb2xsb3c6IDAsIC8vIEFtb3VudCBvZiBkZWNheSBzaG9ydGVuaW5nIGZvciBoaWdoZXIgbm90ZXMuXG4gICAgICAgICAgICBzdXN0YWluOiAwLCAvLyBQb3J0aW9uIG9mIGdhaW4gdG8gc3VzdGFpbiBpbmRlZmluaXRlbHkuXG4gICAgICAgICAgICByZWxlYXNlOiAwLjEsIC8vIFJlbGVhc2UgdGltZSBhZnRlciBhIHRvbmUgaXMgZG9uZS5cbiAgICAgICAgICAgIGN1dG9mZjogMCwgLy8gTG93LXBhc3MgZmlsdGVyIGN1dG9mZiBmcmVxdWVuY3kuXG4gICAgICAgICAgICBjdXRmb2xsb3c6IDAsIC8vIEN1dG9mZiBhZGp1c3RtZW50LCBhIG11bHRpcGxlIG9mIG9zY2lsbGF0b3IgZnJlcS5cbiAgICAgICAgICAgIHJlc29uYW5jZTogMCwgLy8gTG93LXBhc3MgZmlsdGVyIHJlc29uYW5jZS5cbiAgICAgICAgICAgIGRldHVuZTogMCwgLy8gRGV0dW5lIGZhY3RvciBmb3IgYSBzZWNvbmQgb3NjaWxsYXRvci5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBOb3JybWFsaXplcyBhIHRpbWJyZSBvYmplY3QgYnkgbWFraW5nIGEgY29weSB0aGF0IGhhcyBleGFjdGx5XG4gICAgICAgIC8vIHRoZSByaWdodCBzZXQgb2YgdGltYnJlIGZpZWxkcywgZGVmYXVsdGluZyB3aGVuIG5lZWRlZC5cbiAgICAgICAgLy8gQSB0aW1icmUgY2FuIHNwZWNpZnkgYW55IG9mIHRoZSBmaWVsZHMgb2YgZGVmYXVsdFRpbWJyZTsgYW55XG4gICAgICAgIC8vIHVuc3BlY2lmaWVkIGZpZWxkcyBhcmUgdHJlYXRlZCBhcyB0aGV5IGFyZSBzZXQgaW4gZGVmYXVsdFRpbWJyZS5cbiAgICAgICAgc3RhdGljIG1ha2VUaW1icmUob3B0aW9ucywgYXRvcCkge1xuICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBBYmJyZXZpYXRpb246IG5hbWUgYSB3YXZlIHRvIGdldCBhIGRlZmF1bHQgdGltYnJlIGZvciB0aGF0IHdhdmUuXG4gICAgICAgICAgICAgICAgb3B0aW9ucyA9IHsgd2F2ZTogb3B0aW9ucyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB3dCA9IGF0b3AgJiYgYXRvcC53YXZldGFibGUgJiYgYXRvcC53YXZldGFibGVbb3B0aW9ucy53YXZlXTtcbiAgICAgICAgICAgIGZvciAoa2V5IGluIFV0aWxzLmRlZmF1bHRUaW1icmUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAod3QgJiYgd3QuZGVmcyAmJiB3dC5kZWZzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB3dC5kZWZzW2tleV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBVdGlscy5kZWZhdWx0VGltYnJlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRpYyB3aGl0ZU5vaXNlQnVmID0gbnVsbDsgLy8gY2FjaGVcbiAgICAgICAgc3RhdGljIGdldFdoaXRlTm9pc2VCdWYoKSB7XG4gICAgICAgICAgICBpZiAod2hpdGVOb2lzZUJ1ZiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFjID0gVXRpbHMuZ2V0QXVkaW9Ub3AoKS5hYyxcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyU2l6ZSA9IDIgKiBhYy5zYW1wbGVSYXRlLFxuICAgICAgICAgICAgICAgICAgICB3aGl0ZU5vaXNlQnVmID0gYWMuY3JlYXRlQnVmZmVyKDEsIGJ1ZmZlclNpemUsIGFjLnNhbXBsZVJhdGUpLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgPSB3aGl0ZU5vaXNlQnVmLmdldENoYW5uZWxEYXRhKDApO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dFtpXSA9IE1hdGgucmFuZG9tKCkgKiAyIC0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gd2hpdGVOb2lzZUJ1ZjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoaXMgdXRpbGl0eSBmdW5jdGlvbiBjcmVhdGVzIGFuIG9zY2lsbGF0b3IgYXQgdGhlIGdpdmVuIGZyZXF1ZW5jeVxuICAgICAgICAvLyBhbmQgdGhlIGdpdmVuIHdhdmVuYW1lLiAgSXQgc3VwcG9ydHMgbG9va3VwcyBpbiBhIHN0YXRpYyB3YXZldGFibGUsXG4gICAgICAgIC8vIGRlZmluZWQgcmlnaHQgYmVsb3cuXG4gICAgICAgIHN0YXRpYyBtYWtlT3NjaWxsYXRvcihhdG9wLCB3YXZlbmFtZSwgZnJlcSkge1xuICAgICAgICAgICAgaWYgKHdhdmVuYW1lID09IFwibm9pc2VcIikge1xuICAgICAgICAgICAgICAgIHZhciB3aGl0ZU5vaXNlID0gYXRvcC5hYy5jcmVhdGVCdWZmZXJTb3VyY2UoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZU5vaXNlLmJ1ZmZlciA9IFV0aWxzLmdldFdoaXRlTm9pc2VCdWYoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZU5vaXNlLmxvb3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiB3aGl0ZU5vaXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHdhdmV0YWJsZSA9IGF0b3Aud2F2ZXRhYmxlLFxuICAgICAgICAgICAgICAgIG8gPSBhdG9wLmFjLmNyZWF0ZU9zY2lsbGF0b3IoKSxcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIHB3YXZlLFxuICAgICAgICAgICAgICAgIGJ3ZixcbiAgICAgICAgICAgICAgICB3ZjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHdhdmV0YWJsZS5oYXNPd25Qcm9wZXJ0eSh3YXZlbmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIGEgY3VzdG9taXplZCB3YXZldGFibGUuXG4gICAgICAgICAgICAgICAgICAgIHB3YXZlID0gd2F2ZXRhYmxlW3dhdmVuYW1lXS53YXZlO1xuICAgICAgICAgICAgICAgICAgICBpZiAod2F2ZXRhYmxlW3dhdmVuYW1lXS5mcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBid2YgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTG9vayBmb3IgYSBoaWdoZXItZnJlcXVlbmN5IHZhcmlhbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgaW4gd2F2ZXRhYmxlW3dhdmVuYW1lXS5mcmVxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2YgPSBOdW1iZXIoayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyZXEgPiB3ZiAmJiB3ZiA+IGJ3Zikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBid2YgPSB3ZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHdhdmUgPSB3YXZldGFibGVbd2F2ZW5hbWVdLmZyZXFbYndmXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvLnNldFBlcmlvZGljV2F2ZSAmJiBvLnNldFdhdmVUYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9sZCBBUEkgbmFtZTogU2FmYXJpIDcgc3RpbGwgdXNlcyB0aGlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgby5zZXRXYXZlVGFibGUocHdhdmUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldyBBUEkgbmFtZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIG8uc2V0UGVyaW9kaWNXYXZlKHB3YXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG8udHlwZSA9IHdhdmVuYW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB1bnJlY29nbml6ZWQsIGp1c3QgdXNlIHNxdWFyZS5cbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBzdXBwb3J0IFwibm9pc2VcIiBvciBvdGhlciB3YXZlIHNoYXBlcy5cbiAgICAgICAgICAgICAgICBvLnR5cGUgPSBcInNxdWFyZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gby5mcmVxdWVuY3kudmFsdWUgPSBmcmVxOyAvLyBST05ZRUggUkVNT1ZFRCBEVUUgVE8gU09NRSBCVUcuXG4gICAgICAgICAgICBvLmZyZXF1ZW5jeS5zZXRUYXJnZXRBdFRpbWUoZnJlcSwgYXRvcC5hYy5jdXJyZW50VGltZSwgMC4wMDEpOyAvLyBST05ZRUggQURERURcbiAgICAgICAgICAgIHJldHVybiBvO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gRU5EIFVUSUxTXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvLyBQYXJzZXMgYW4gQUJDIGZpbGUgdG8gYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBzdHJ1Y3R1cmU6XG4gICAgLy8ge1xuICAgIC8vICAgWDogdmFsdWUgZnJvbSB0aGUgWDogbGluZXMgaW4gaGVhZGVyIChcXG4gc2VwYXJhdGVkIGZvciBtdWx0aXBsZSB2YWx1ZXMpXG4gICAgLy8gICBWOiB2YWx1ZSBmcm9tIHRoZSBWOm15bmFtZSBsaW5lcyB0aGF0IGFwcGVhciBiZWZvcmUgSzpcbiAgICAvLyAgIChldGMpOiBmb3IgYWxsIHRoZSBvbmUtbGV0dGVyIGhlYWRlci1uYW1lcy5cbiAgICAvLyAgIEs6IHZhbHVlIGZyb20gdGhlIEs6IGxpbmVzIGluIGhlYWRlci5cbiAgICAvLyAgIHRlbXBvOiBROiBsaW5lIHBhcnNlZCBhcyBiZWF0c2Vjc1xuICAgIC8vICAgdGltYnJlOiAuLi4gSTp0aW1icmUgbGluZSBhcyBwYXJzZWQgYnkgbWFrZVRpbWJyZVxuICAgIC8vICAgdm9pY2U6IHtcbiAgICAvLyAgICAgbXluYW1lOiB7IC8vIHZvaWNlIHdpdGggaWQgXCJteW5hbWVcIlxuICAgIC8vICAgICAgIFY6IHZhbHVlIGZyb20gdGhlIFY6bXluYW1lIGxpbmVzIChmcm9tIHRoZSBib2R5KVxuICAgIC8vICAgICAgIHN0ZW1zOiBbLi4uXSBhcyBwYXJzZWQgYnkgcGFyc2VBQkNzdGVtc1xuICAgIC8vICAgIH1cbiAgICAvLyAgfVxuICAgIC8vIH1cbiAgICAvLyBBQkMgZmlsZXMgYXJlIGlkaW9zeW5jcmF0aWMgdG8gcGFyc2U6IHRoZSB3cml0dGVuIHNwZWNpZmljYXRpb25zXG4gICAgLy8gZG8gbm90IG5lY2Vzc2FyaWx5IHJlZmxlY3QgdGhlIGRlZmFjdG8gc3RhbmRhcmQgaW1wbGVtZW50ZWQgYnlcbiAgICAvLyBBQkMgY29udGVudCBvbiB0aGUgd2ViLiAgVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBkZXNpZ25lZCB0byBiZVxuICAgIC8vIHByYWN0aWNhbCwgd29ya2luZyBvbiBjb250ZW50IGFzIGl0IGFwcGVhcnMgb24gdGhlIHdlYiwgYW5kIG9ubHlcbiAgICAvLyB1c2luZyB0aGUgd3JpdHRlbiBzdGFuZGFyZCBhcyBhIGd1aWRlbGluZS5cblxuICAgIHZhciBBQkNoZWFkZXIgPSAvXihbQS1aYS16XSk6XFxzKiguKikkLztcbiAgICB2YXIgQUJDdG9rZW4gPSAvKD86XFxbW0EtWmEtel06W15cXF1dKlxcXSl8XFxzK3wlW15cXG5dKnwhW15cXHMhOnxcXFtcXF1dKiF8XFwrW14rfCFdKlxcK3xbXzw+QF5dP1wiW15cIl0qXCJ8XFxbfFxcXXw+K3w8K3woPzooPzpcXF4rfF8rfD18KVtBLUdhLWddKD86LCt8Jyt8KSl8XFwoXFxkKyg/OjpcXGQrKXswLDJ9fFxcZCpcXC9cXGQrfFxcZCtcXC8/fFxcLyt8W3h6WFpdfFxcWz9cXHxcXF0/fDo/XFx8Oj98Ojp8Li9nO1xuXG4gICAgZnVuY3Rpb24gcGFyc2VBQkNGaWxlKHN0cikge1xuICAgICAgICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoXCJcXG5cIiksXG4gICAgICAgICAgICByZXN1bHQ6IGFueSA9IHt9LFxuICAgICAgICAgICAgY29udGV4dCA9IHJlc3VsdCxcbiAgICAgICAgICAgIHRpbWJyZSxcbiAgICAgICAgICAgIGosXG4gICAgICAgICAgICBrLFxuICAgICAgICAgICAgaGVhZGVyLFxuICAgICAgICAgICAgc3RlbXMsXG4gICAgICAgICAgICBrZXkgPSB7fSxcbiAgICAgICAgICAgIGFjY2VudCA9IHsgc2x1cnJlZDogMCB9LFxuICAgICAgICAgICAgdm9pY2VpZCxcbiAgICAgICAgICAgIG91dDtcbiAgICAgICAgLy8gQUJDIGZpbGVzIGFyZSBwYXJzZWQgb25lIGxpbmUgYXQgYSB0aW1lLlxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgIC8vIEZpcnN0LCBjaGVjayB0byBzZWUgaWYgdGhlIGxpbmUgaXMgYSBoZWFkZXIgbGluZS5cbiAgICAgICAgICAgIGhlYWRlciA9IEFCQ2hlYWRlci5leGVjKGxpbmVzW2pdKTtcbiAgICAgICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVJbmZvcm1hdGlvbihoZWFkZXJbMV0sIGhlYWRlclsyXS50cmltKCkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgvXlxccyooPzolLiopPyQvLnRlc3QobGluZXNbal0pKSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCBibGFuayBhbmQgY29tbWVudCBsaW5lcy5cbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIG5vdGVzLlxuICAgICAgICAgICAgICAgIHBhcnNlQUJDTm90ZXMobGluZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBpbmZlciA9IFtcInVuaXRub3RlXCIsIFwidW5pdGJlYXRcIiwgXCJ0ZW1wb1wiXTtcbiAgICAgICAgaWYgKHJlc3VsdC5oYXNPd25Qcm9wZXJ0eShcInZvaWNlXCIpICYmIHJlc3VsdC52b2ljZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb3V0ID0gW107XG4gICAgICAgICAgICBmb3IgKGogaW4gcmVzdWx0LnZvaWNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52b2ljZVtqXS5zdGVtcyAmJiByZXN1bHQudm9pY2Vbal0uc3RlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aW1lcyBmb3IgYWxsIHRoZSB0aWVkIG5vdGVzLiAgVGhpcyBoYXBwZW5zIGF0IHRoZSBlbmRcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVjYXVzZSBpbiBwcmluY2lwbGUsIHRoZSBmaXJzdCBub3RlIG9mIGEgc29uZyBjb3VsZCBiZSB0aWVkIGFsbFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgd2F5IHRocm91Z2ggdG8gdGhlIGxhc3Qgbm90ZS5cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc1RpZXMocmVzdWx0LnZvaWNlW2pdLnN0ZW1zKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnJpbmcgdXAgaW5mZXJyZWQgdGVtcG8gdmFsdWVzIGZyb20gdm9pY2VzIGlmIG5vdCBzcGVjaWZpZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gdGhlIGhlYWRlci5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGluZmVyLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbmZlcltrXSBpbiByZXN1bHQpICYmIGluZmVyW2tdIGluIHJlc3VsdC52b2ljZVtqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtpbmZlcltrXV0gPSByZXN1bHQudm9pY2Vbal1baW5mZXJba11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGludGVybmFsIHN0YXRlIHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnZvaWNlW2pdLmFjY2VudDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXQucHVzaChqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWxldGUgYW55IHZvaWNlcyB0aGF0IGhhZCBubyBzdGVtcy5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBvdXQubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcmVzdWx0LnZvaWNlW291dFtqXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gUGFyc2luZyBoZWxwZXIgZnVuY3Rpb25zIGJlbG93LlxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAgICAgICAvLyBQcm9jZXNzZXMgaGVhZGVyIGZpZWxkcyBzdWNoIGFzIFY6IHZvaWNlLCB3aGljaCBtYXkgYXBwZWFyIGF0IHRoZVxuICAgICAgICAvLyB0b3Agb2YgdGhlIEFCQyBmaWxlLCBvciBpbiB0aGUgQUJDIGJvZHkgaW4gYSBbVjp2b2ljZV0gZGlyZWN0aXZlLlxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVJbmZvcm1hdGlvbihmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgaGVhZGVycyBhcmUgcmVjb2duaXplZCBhbmQgcHJvY2Vzc2VkLlxuICAgICAgICAgICAgc3dpdGNoIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJWXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgVjogaGVhZGVyIHN3aXRjaGVzIHZvaWNlcyBpZiBpbiB0aGUgYm9keS5cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaW4gdGhlIGhlYWRlciwgdGhlbiBpdCBpcyBqdXN0IGFkdmlzb3J5LlxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAhPT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFydFZvaWNlQ29udGV4dCh2YWx1ZS5zcGxpdChcIiBcIilbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJNXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlTWV0ZXIodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiTFwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVVuaXROb3RlKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlFcIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VUZW1wbyh2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWxsIGhlYWRlcnMgKGluY2x1ZGluZyB1bnJlY29nbml6ZWQgb25lcykgYXJlXG4gICAgICAgICAgICAvLyBqdXN0IGFjY3VtdWxhdGVkIGFzIHByb3BlcnRpZXMuIFJlcGVhdGVkIGhlYWRlclxuICAgICAgICAgICAgLy8gbGluZXMgYXJlIGFjY3VtdWxhdGVkIGFzIG11bHRpbGluZSBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgaWYgKGNvbnRleHQuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dFtmaWVsZF0gKz0gXCJcXG5cIiArIHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0W2ZpZWxkXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIEsgaGVhZGVyIGlzIHNwZWNpYWw6IGl0IHNob3VsZCBiZSB0aGUgbGFzdCBvbmVcbiAgICAgICAgICAgIC8vIGJlZm9yZSB0aGUgdm9pY2VzIGFuZCBub3RlcyBiZWdpbi5cbiAgICAgICAgICAgIGlmIChmaWVsZCA9PSBcIktcIikge1xuICAgICAgICAgICAgICAgIGtleSA9IGtleXNpZyh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZvaWNlQ29udGV4dChmaXJzdFZvaWNlTmFtZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTaGlmdHMgY29udGV4dCB0byBhIHZvaWNlIHdpdGggdGhlIGdpdmVuIGlkIGdpdmVuLiAgSWYgbm8gaWRcbiAgICAgICAgLy8gZ2l2ZW4sIHRoZW4ganVzdCBzdGlja3Mgd2l0aCB0aGUgY3VycmVudCB2b2ljZS4gIElmIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHZvaWNlIGlzIHVubmFtZWQgYW5kIGVtcHR5LCByZW5hbWVzIHRoZSBjdXJyZW50IHZvaWNlLlxuICAgICAgICBmdW5jdGlvbiBzdGFydFZvaWNlQ29udGV4dChpZCkge1xuICAgICAgICAgICAgaWQgPSBpZCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKCFpZCAmJiBjb250ZXh0ICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC52b2ljZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC52b2ljZSA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdC52b2ljZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXN1bWUgYSBuYW1lZCB2b2ljZS5cbiAgICAgICAgICAgICAgICBjb250ZXh0ID0gcmVzdWx0LnZvaWNlW2lkXTtcbiAgICAgICAgICAgICAgICBhY2NlbnQgPSBjb250ZXh0LmFjY2VudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgdm9pY2UuXG4gICAgICAgICAgICAgICAgY29udGV4dCA9IHsgaWQ6IGlkLCBhY2NlbnQ6IHsgc2x1cnJlZDogMCB9IH07XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZvaWNlW2lkXSA9IGNvbnRleHQ7XG4gICAgICAgICAgICAgICAgYWNjZW50ID0gY29udGV4dC5hY2NlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGb3IgcGlja2luZyBhIGRlZmF1bHQgdm9pY2UsIGxvb2tzIGZvciB0aGUgZmlyc3Qgdm9pY2UgbmFtZS5cbiAgICAgICAgZnVuY3Rpb24gZmlyc3RWb2ljZU5hbWUoKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LlYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LlYuc3BsaXQoL1xccysvKVswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZXMgYSBzaW5nbGUgbGluZSBvZiBBQkMgbm90ZXMgKGkuZS4sIG5vdCBhIGhlYWRlciBsaW5lKS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgcHJvY2VzcyBhbiBBQkMgc29uZyBzdHJlYW0gYnkgZGl2aWRpbmcgaXQgaW50byB0b2tlbnMsIGVhY2ggb2ZcbiAgICAgICAgLy8gd2hpY2ggaXMgYSBwaXRjaCwgZHVyYXRpb24sIG9yIHNwZWNpYWwgZGVjb3JhdGlvbiBzeW1ib2w7IHRoZW5cbiAgICAgICAgLy8gd2UgcHJvY2VzcyBlYWNoIGRlY29yYXRpb24gaW5kaXZpZHVhbGx5LCBhbmQgd2UgcHJvY2VzcyBlYWNoXG4gICAgICAgIC8vIHN0ZW0gYXMgYSBncm91cCB1c2luZyBwYXJzZVN0ZW0uXG4gICAgICAgIC8vIFRoZSBzdHJ1Y3R1cmUgb2YgYSBzaW5nbGUgQUJDIG5vdGUgaXMgc29tZXRoaW5nIGxpa2UgdGhpczpcbiAgICAgICAgLy9cbiAgICAgICAgLy8gTk9URSAtPiBTVEFDQ0FUTz8gUElUQ0ggRFVSQVRJT04/IFRJRT9cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSS5lLiwgaXQgYWx3YXlzIGhhcyBhIHBpdGNoLCBhbmQgaXQgaXMgcHJlZml4ZWQgYnkgc29tZSBvcHRpb25hbFxuICAgICAgICAvLyBkZWNvcmF0aW9ucyBzdWNoIGFzIGEgKC4pIHN0YWNjYXRvIG1hcmtpbmcsIGFuZCBpdCBpcyBzdWZmaXhlZCBieVxuICAgICAgICAvLyBhbiBvcHRpb25hbCBkdXJhdGlvbiBhbmQgYW4gb3B0aW9uYWwgdGllICgtKSBtYXJraW5nLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBIHN0ZW0gaXMgZWl0aGVyIGEgbm90ZSBvciBhIGJyYWNrZXRlZCBzZXJpZXMgb2Ygbm90ZXMsIGZvbGxvd2VkXG4gICAgICAgIC8vIGJ5IGR1cmF0aW9uIGFuZCB0aWUuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFNURU0gLT4gTk9URSAgIE9SICAgICdbJyBOT1RFICogJ10nIERVUkFJVE9OPyBUSUU/XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZW4gYSBzb25nIGlzIGp1c3QgYSBzZXF1ZW5jZSBvZiBzdGVtcyBpbnRlcmxlYXZlZCB3aXRoIG90aGVyXG4gICAgICAgIC8vIGRlY29yYXRpb25zIHN1Y2ggYXMgZHluYW1pY3MgbWFya2luZ3MgYW5kIG1lYXN1cmUgZGVsaW1pdGVycy5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VBQkNOb3RlcyhzdHIpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbnMgPSBzdHIubWF0Y2goQUJDdG9rZW4pLFxuICAgICAgICAgICAgICAgIHBhcnNlZCA9IG51bGwsXG4gICAgICAgICAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIGRvdHRlZCA9IDAsXG4gICAgICAgICAgICAgICAgYmVhdGxldCA9IG51bGwsXG4gICAgICAgICAgICAgICAgdDtcbiAgICAgICAgICAgIGlmICghdG9rZW5zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlICVjb21tZW50cyBhbmQgIW1hcmtpbmdzIVxuICAgICAgICAgICAgICAgIGlmICgvXltcXHMlXS8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGlubGluZSBbWDouLi5dIGluZm9ybWF0aW9uIGZpZWxkc1xuICAgICAgICAgICAgICAgIGlmICgvXlxcW1tBLVphLXpdOlteXFxdXSpcXF0kLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUluZm9ybWF0aW9uKHRva2Vuc1tpbmRleF0uc3Vic3RyaW5nKDEsIDIpLCB0b2tlbnNbaW5kZXhdLnN1YnN0cmluZygzLCB0b2tlbnNbaW5kZXhdLmxlbmd0aCAtIDEpLnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGVkIGRvdHRlZCBub3RhdGlvbiBhYmJyZXZpYXRpb25zLlxuICAgICAgICAgICAgICAgIGlmICgvPC8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICBkb3R0ZWQgPSAtdG9rZW5zW2luZGV4KytdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvPi8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICBkb3R0ZWQgPSB0b2tlbnNbaW5kZXgrK10ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9eXFwoXFxkKyg/OjpcXGQrKSovLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVhdGxldCA9IHBhcnNlQmVhdGxldCh0b2tlbnNbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9eWyErXS4qWyErXSQvLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VEZWNvcmF0aW9uKHRva2Vuc1tpbmRleCsrXSwgYWNjZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvXi4/XCIuKlwiJC8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZ25vcmUgZG91YmxlLXF1b3RlZCB0b2tlbnMgKGNob3JkcyBhbmQgZ2VuZXJhbCB0ZXh0IGFubm90YXRpb25zKS5cbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgvXlsoKV0kLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbnNbaW5kZXgrK10gPT0gXCIoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VudC5zbHVycmVkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NlbnQuc2x1cnJlZCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjY2VudC5zbHVycmVkIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2NlbnQuc2x1cnJlZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuc3RlbXMgJiYgY29udGV4dC5zdGVtcy5sZW5ndGggPj0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbGFzdCBub3RlcyBpbiBhIHNsdXIgYXJlIG5vdCBzbHVycmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbHVyU3RlbShjb250ZXh0LnN0ZW1zW2NvbnRleHQuc3RlbXMubGVuZ3RoIC0gMV0sIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBtZWFzdXJlIG1hcmtpbmdzIGJ5IGNsZWFyaW5nIGFjY2lkZW50YWxzLlxuICAgICAgICAgICAgICAgIGlmICgvXFx8Ly50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodCBpbiBhY2NlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2luZ2xlLWxldHRlciBhY2NlbnQgcHJvcGVydGllcyBhcmUgbm90ZSBhY2NpZGVudGFscy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYWNjZW50W3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZWQgPSBwYXJzZVN0ZW0odG9rZW5zLCBpbmRleCwga2V5LCBhY2NlbnQpO1xuICAgICAgICAgICAgICAgIC8vIFNraXAgdW5wYXJzYWJsZSBiaXRzXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gUHJvY2VzcyBhIHBhcnNlZCBzdGVtLlxuICAgICAgICAgICAgICAgIGlmIChiZWF0bGV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNjYWxlU3RlbShwYXJzZWQuc3RlbSwgYmVhdGxldC50aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgYmVhdGxldC5jb3VudCAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJlYXRsZXQuY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlYXRsZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHN5bmNvcGF0ZWQgd2l0aCA+IG9yIDwgbm90YXRpb24sIHNoaWZ0IHBhcnQgb2YgYSBiZWF0XG4gICAgICAgICAgICAgICAgLy8gYmV0d2VlbiB0aGlzIHN0ZW0gYW5kIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgICAgICAgICAgaWYgKGRvdHRlZCAmJiBjb250ZXh0LnN0ZW1zICYmIGNvbnRleHQuc3RlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb3R0ZWQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ID0gKDEgLSBNYXRoLnBvdygwLjUsIGRvdHRlZCkpICogcGFyc2VkLnN0ZW0udGltZTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoTWF0aC5wb3coMC41LCAtZG90dGVkKSAtIDEpICogY29udGV4dC5zdGVtc1tjb250ZXh0LnN0ZW1zLmxlbmd0aCAtIDFdLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3luY29wYXRlU3RlbShjb250ZXh0LnN0ZW1zW2NvbnRleHQuc3RlbXMubGVuZ3RoIC0gMV0sIHQpO1xuICAgICAgICAgICAgICAgICAgICBzeW5jb3BhdGVTdGVtKHBhcnNlZC5zdGVtLCAtdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRvdHRlZCA9IDA7XG4gICAgICAgICAgICAgICAgLy8gU2x1ciBhbGwgdGhlIG5vdGVzIGNvbnRhaW5lZCB3aXRoaW4gYSBzdHJlbS5cbiAgICAgICAgICAgICAgICBpZiAoYWNjZW50LnNsdXJyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2x1clN0ZW0ocGFyc2VkLnN0ZW0sIHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTdGFydCBhIGRlZmF1bHQgdm9pY2UgaWYgd2UncmUgbm90IGluIGEgdm9pY2UgeWV0LlxuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWb2ljZUNvbnRleHQoZmlyc3RWb2ljZU5hbWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghKFwic3RlbXNcIiBpbiBjb250ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN0ZW1zID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgc3RlbSB0byB0aGUgc2VxdWVuY2Ugb2Ygc3RlbXMgZm9yIHRoaXMgdm9pY2UuXG4gICAgICAgICAgICAgICAgY29udGV4dC5zdGVtcy5wdXNoKHBhcnNlZC5zdGVtKTtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBwYXJzaW5nIGluZGV4IHNpbmNlIGEgc3RlbSBpcyBtdWx0aXBsZSB0b2tlbnMuXG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXJzZWQuaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBQYXJzZSBNOiBsaW5lcy4gIFwiMy80XCIgaXMgMy80IHRpbWUgYW5kIFwiQ1wiIGlzIDQvNCAoY29tbW9uKSB0aW1lLlxuICAgICAgICBmdW5jdGlvbiBwYXJzZU1ldGVyKG1saW5lLCBiZWF0aW5mbykge1xuICAgICAgICAgICAgdmFyIGQgPSAvXkMvLnRlc3QobWxpbmUpID8gNCAvIDQgOiBkdXJhdGlvblRvVGltZShtbGluZSk7XG4gICAgICAgICAgICBpZiAoIWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWJlYXRpbmZvLnVuaXRub3RlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQgPCAwLjc1KSB7XG4gICAgICAgICAgICAgICAgICAgIGJlYXRpbmZvLnVuaXRub3RlID0gMSAvIDE2O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJlYXRpbmZvLnVuaXRub3RlID0gMSAvIDg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlIEw6IGxpbmVzLCBlLmcuLCBcIjEvOFwiLlxuICAgICAgICBmdW5jdGlvbiBwYXJzZVVuaXROb3RlKGxsaW5lLCBiZWF0aW5mbykge1xuICAgICAgICAgICAgdmFyIGQgPSBkdXJhdGlvblRvVGltZShsbGluZSk7XG4gICAgICAgICAgICBpZiAoIWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiZWF0aW5mby51bml0bm90ZSA9IGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgUTogbGluZSwgZS5nLiwgXCIxLzQ9NjZcIi5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VUZW1wbyhxbGluZSwgYmVhdGluZm8pIHtcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHFsaW5lLnNwbGl0KC9cXHMrfD0vKSxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIHVuaXQgPSBudWxsLFxuICAgICAgICAgICAgICAgIHRlbXBvID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBwYXJ0cy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIC8vIEl0IGNvdWxkIGJlIHJldmVyc2VkLCBsaWtlIFwiNjY9MS80XCIsIG9yIGp1c3QgXCIxMjBcIiwgc29cbiAgICAgICAgICAgICAgICAvLyBkZXRlcm1pbmUgd2hhdCBpcyBnb2luZyBvbiBieSBsb29raW5nIGZvciBhIHNsYXNoIGV0Yy5cbiAgICAgICAgICAgICAgICBpZiAocGFydHNbal0uaW5kZXhPZihcIi9cIikgPj0gMCB8fCAvXlsxLTRdJC8udGVzdChwYXJ0c1tqXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5vdGUtdW5pdCAoZS5nLiwgMS80KS5cbiAgICAgICAgICAgICAgICAgICAgdW5pdCA9IHVuaXQgfHwgZHVyYXRpb25Ub1RpbWUocGFydHNbal0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSB0ZW1wby1udW1iZXIgKGUuZy4sIDEyMClcbiAgICAgICAgICAgICAgICAgICAgdGVtcG8gPSB0ZW1wbyB8fCBOdW1iZXIocGFydHNbal0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bml0KSB7XG4gICAgICAgICAgICAgICAgYmVhdGluZm8udW5pdGJlYXQgPSB1bml0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRlbXBvKSB7XG4gICAgICAgICAgICAgICAgYmVhdGluZm8udGVtcG8gPSB0ZW1wbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSdW4gdGhyb3VnaCBhbGwgdGhlIG5vdGVzLCBhZGRpbmcgdXAgdGltZSBmb3IgdGllZCBub3RlcyxcbiAgICAgICAgLy8gYW5kIG1hcmtpbmcgbm90ZXMgdGhhdCB3ZXJlIGhlbGQgb3ZlciB3aXRoIGhvbGRvdmVyID0gdHJ1ZS5cbiAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc1RpZXMoc3RlbXMpIHtcbiAgICAgICAgICAgIHZhciB0aWVkID0ge30sXG4gICAgICAgICAgICAgICAgbmV4dFRpZWQsXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBrLFxuICAgICAgICAgICAgICAgIG5vdGUsXG4gICAgICAgICAgICAgICAgZmlyc3ROb3RlO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0ZW1zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgbmV4dFRpZWQgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgc3RlbXNbal0ubm90ZXMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3ROb3RlID0gbm90ZSA9IHN0ZW1zW2pdLm5vdGVzW2tdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGllZC5oYXNPd25Qcm9wZXJ0eShub3RlLnBpdGNoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGl0Y2ggd2FzIHRpZWQgZnJvbSBiZWZvcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdE5vdGUgPSB0aWVkW25vdGUucGl0Y2hdOyAvLyBHZXQgdGhlIGVhcmxpZXN0IG5vdGUgaW4gdGhlIHRpZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm90ZS50aW1lICs9IG5vdGUudGltZTsgLy8gRXh0ZW5kIGl0cyB0aW1lLlxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZS5ob2xkb3ZlciA9IHRydWU7IC8vIFNpbGVuY2UgdGhpcyBub3RlIGFzIGEgaG9sZG92ZXIuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGUudGllKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIG5vdGUgaXMgdGllZCB3aXRoIHRoZSBuZXh0LlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFRpZWRbbm90ZS5waXRjaF0gPSBmaXJzdE5vdGU7IC8vIFNhdmUgaXQgYXdheS5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aWVkID0gbmV4dFRpZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJucyBhIG1hcCBvZiBBLUcgLT4gYWNjaWRlbnRhbHMsIGFjY29yZGluZyB0byB0aGUga2V5IHNpZ25hdHVyZS5cbiAgICAgICAgLy8gV2hlbiBuIGlzIHplcm8sIHRoZXJlIGFyZSBubyBhY2NpZGVudGFscyAoZS5nLiwgQyBtYWpvciBvciBBIG1pbm9yKS5cbiAgICAgICAgLy8gV2hlbiBuIGlzIHBvc2l0aXZlLCB0aGVyZSBhcmUgbiBzaGFycHMgKGUuZy4sIGZvciBHIG1ham9yLCBuID0gMSkuXG4gICAgICAgIC8vIFdoZW4gbiBpcyBuZWdhdGl2ZSwgdGhlcmUgYXJlIC1uIGZsYXRzIChlLmcuLCBmb3IgRiBtYWpvciwgbiA9IC0xKS5cbiAgICAgICAgZnVuY3Rpb24gYWNjaWRlbnRhbHMobikge1xuICAgICAgICAgICAgdmFyIHNoYXJwcyA9IFwiRkNHREFFQlwiLFxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9LFxuICAgICAgICAgICAgICAgIGo7XG4gICAgICAgICAgICBpZiAoIW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIHNoYXJwcy5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbiAmJiBqIDwgNzsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtzaGFycHMuY2hhckF0KGopXSA9IFwiXlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmxhdHMgYXJlIGluIHRoZSBvcHBvc2l0ZSBvcmRlci5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqID4gbiAmJiBqID4gLTc7IC0taikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbc2hhcnBzLmNoYXJBdCg2ICsgaildID0gXCJfXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWNvZGVzIHRoZSBrZXkgc2lnbmF0dXJlIGxpbmUgKGUuZy4sIEs6IEMjbSkgYXQgdGhlIGZyb250IG9mIGFuIEFCQyB0dW5lLlxuICAgICAgICAvLyBTdXBwb3J0cyB0aGUgd2hvbGUgcmFuZ2Ugb2Ygc2NhbGUgc3lzdGVtcyBsaXN0ZWQgaW4gdGhlIEFCQyBzcGVjLlxuICAgICAgICBmdW5jdGlvbiBrZXlzaWcoa2V5bmFtZSkge1xuICAgICAgICAgICAgaWYgKCFrZXluYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtrZXksXG4gICAgICAgICAgICAgICAgc2lnY29kZXMgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ham9yXG4gICAgICAgICAgICAgICAgICAgIFwiYyNcIjogNyxcbiAgICAgICAgICAgICAgICAgICAgXCJmI1wiOiA2LFxuICAgICAgICAgICAgICAgICAgICBiOiA1LFxuICAgICAgICAgICAgICAgICAgICBlOiA0LFxuICAgICAgICAgICAgICAgICAgICBhOiAzLFxuICAgICAgICAgICAgICAgICAgICBkOiAyLFxuICAgICAgICAgICAgICAgICAgICBnOiAxLFxuICAgICAgICAgICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgICAgICAgICBmOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgYmI6IC0yLFxuICAgICAgICAgICAgICAgICAgICBlYjogLTMsXG4gICAgICAgICAgICAgICAgICAgIGFiOiAtNCxcbiAgICAgICAgICAgICAgICAgICAgZGI6IC01LFxuICAgICAgICAgICAgICAgICAgICBnYjogLTYsXG4gICAgICAgICAgICAgICAgICAgIGNiOiAtNyxcbiAgICAgICAgICAgICAgICAgICAgLy8gTWlub3JcbiAgICAgICAgICAgICAgICAgICAgXCJhI21cIjogNyxcbiAgICAgICAgICAgICAgICAgICAgXCJkI21cIjogNixcbiAgICAgICAgICAgICAgICAgICAgXCJnI21cIjogNSxcbiAgICAgICAgICAgICAgICAgICAgXCJjI21cIjogNCxcbiAgICAgICAgICAgICAgICAgICAgXCJmI21cIjogMyxcbiAgICAgICAgICAgICAgICAgICAgYm06IDIsXG4gICAgICAgICAgICAgICAgICAgIGVtOiAxLFxuICAgICAgICAgICAgICAgICAgICBhbTogMCxcbiAgICAgICAgICAgICAgICAgICAgZG06IC0xLFxuICAgICAgICAgICAgICAgICAgICBnbTogLTIsXG4gICAgICAgICAgICAgICAgICAgIGNtOiAtMyxcbiAgICAgICAgICAgICAgICAgICAgZm06IC00LFxuICAgICAgICAgICAgICAgICAgICBiYm06IC01LFxuICAgICAgICAgICAgICAgICAgICBlYm06IC02LFxuICAgICAgICAgICAgICAgICAgICBhYm06IC03LFxuICAgICAgICAgICAgICAgICAgICAvLyBNaXhvbHlkaWFuXG4gICAgICAgICAgICAgICAgICAgIFwiZyNtaXhcIjogNyxcbiAgICAgICAgICAgICAgICAgICAgXCJjI21peFwiOiA2LFxuICAgICAgICAgICAgICAgICAgICBcImYjbWl4XCI6IDUsXG4gICAgICAgICAgICAgICAgICAgIGJtaXg6IDQsXG4gICAgICAgICAgICAgICAgICAgIGVtaXg6IDMsXG4gICAgICAgICAgICAgICAgICAgIGFtaXg6IDIsXG4gICAgICAgICAgICAgICAgICAgIGRtaXg6IDEsXG4gICAgICAgICAgICAgICAgICAgIGdtaXg6IDAsXG4gICAgICAgICAgICAgICAgICAgIGNtaXg6IC0xLFxuICAgICAgICAgICAgICAgICAgICBmbWl4OiAtMixcbiAgICAgICAgICAgICAgICAgICAgYmJtaXg6IC0zLFxuICAgICAgICAgICAgICAgICAgICBlYm1peDogLTQsXG4gICAgICAgICAgICAgICAgICAgIGFibWl4OiAtNSxcbiAgICAgICAgICAgICAgICAgICAgZGJtaXg6IC02LFxuICAgICAgICAgICAgICAgICAgICBnYm1peDogLTcsXG4gICAgICAgICAgICAgICAgICAgIC8vIERvcmlhblxuICAgICAgICAgICAgICAgICAgICBcImQjZG9yXCI6IDcsXG4gICAgICAgICAgICAgICAgICAgIFwiZyNkb3JcIjogNixcbiAgICAgICAgICAgICAgICAgICAgXCJjI2RvclwiOiA1LFxuICAgICAgICAgICAgICAgICAgICBcImYjZG9yXCI6IDQsXG4gICAgICAgICAgICAgICAgICAgIGJkb3I6IDMsXG4gICAgICAgICAgICAgICAgICAgIGVkb3I6IDIsXG4gICAgICAgICAgICAgICAgICAgIGFkb3I6IDEsXG4gICAgICAgICAgICAgICAgICAgIGRkb3I6IDAsXG4gICAgICAgICAgICAgICAgICAgIGdkb3I6IC0xLFxuICAgICAgICAgICAgICAgICAgICBjZG9yOiAtMixcbiAgICAgICAgICAgICAgICAgICAgZmRvcjogLTMsXG4gICAgICAgICAgICAgICAgICAgIGJiZG9yOiAtNCxcbiAgICAgICAgICAgICAgICAgICAgZWJkb3I6IC01LFxuICAgICAgICAgICAgICAgICAgICBhYmRvcjogLTYsXG4gICAgICAgICAgICAgICAgICAgIGRiZG9yOiAtNyxcbiAgICAgICAgICAgICAgICAgICAgLy8gUGhyeWdpYW5cbiAgICAgICAgICAgICAgICAgICAgXCJlI3BoclwiOiA3LFxuICAgICAgICAgICAgICAgICAgICBcImEjcGhyXCI6IDYsXG4gICAgICAgICAgICAgICAgICAgIFwiZCNwaHJcIjogNSxcbiAgICAgICAgICAgICAgICAgICAgXCJnI3BoclwiOiA0LFxuICAgICAgICAgICAgICAgICAgICBcImMjcGhyXCI6IDMsXG4gICAgICAgICAgICAgICAgICAgIFwiZiNwaHJcIjogMixcbiAgICAgICAgICAgICAgICAgICAgYnBocjogMSxcbiAgICAgICAgICAgICAgICAgICAgZXBocjogMCxcbiAgICAgICAgICAgICAgICAgICAgYXBocjogLTEsXG4gICAgICAgICAgICAgICAgICAgIGRwaHI6IC0yLFxuICAgICAgICAgICAgICAgICAgICBncGhyOiAtMyxcbiAgICAgICAgICAgICAgICAgICAgY3BocjogLTQsXG4gICAgICAgICAgICAgICAgICAgIGZwaHI6IC01LFxuICAgICAgICAgICAgICAgICAgICBiYnBocjogLTYsXG4gICAgICAgICAgICAgICAgICAgIGVicGhyOiAtNyxcbiAgICAgICAgICAgICAgICAgICAgLy8gTHlkaWFuXG4gICAgICAgICAgICAgICAgICAgIFwiZiNseWRcIjogNyxcbiAgICAgICAgICAgICAgICAgICAgYmx5ZDogNixcbiAgICAgICAgICAgICAgICAgICAgZWx5ZDogNSxcbiAgICAgICAgICAgICAgICAgICAgYWx5ZDogNCxcbiAgICAgICAgICAgICAgICAgICAgZGx5ZDogMyxcbiAgICAgICAgICAgICAgICAgICAgZ2x5ZDogMixcbiAgICAgICAgICAgICAgICAgICAgY2x5ZDogMSxcbiAgICAgICAgICAgICAgICAgICAgZmx5ZDogMCxcbiAgICAgICAgICAgICAgICAgICAgYmJseWQ6IC0xLFxuICAgICAgICAgICAgICAgICAgICBlYmx5ZDogLTIsXG4gICAgICAgICAgICAgICAgICAgIGFibHlkOiAtMyxcbiAgICAgICAgICAgICAgICAgICAgZGJseWQ6IC00LFxuICAgICAgICAgICAgICAgICAgICBnYmx5ZDogLTUsXG4gICAgICAgICAgICAgICAgICAgIGNibHlkOiAtNixcbiAgICAgICAgICAgICAgICAgICAgZmJseWQ6IC03LFxuICAgICAgICAgICAgICAgICAgICAvLyBMb2NyaWFuXG4gICAgICAgICAgICAgICAgICAgIFwiYiNsb2NcIjogNyxcbiAgICAgICAgICAgICAgICAgICAgXCJlI2xvY1wiOiA2LFxuICAgICAgICAgICAgICAgICAgICBcImEjbG9jXCI6IDUsXG4gICAgICAgICAgICAgICAgICAgIFwiZCNsb2NcIjogNCxcbiAgICAgICAgICAgICAgICAgICAgXCJnI2xvY1wiOiAzLFxuICAgICAgICAgICAgICAgICAgICBcImMjbG9jXCI6IDIsXG4gICAgICAgICAgICAgICAgICAgIFwiZiNsb2NcIjogMSxcbiAgICAgICAgICAgICAgICAgICAgYmxvYzogMCxcbiAgICAgICAgICAgICAgICAgICAgZWxvYzogLTEsXG4gICAgICAgICAgICAgICAgICAgIGFsb2M6IC0yLFxuICAgICAgICAgICAgICAgICAgICBkbG9jOiAtMyxcbiAgICAgICAgICAgICAgICAgICAgZ2xvYzogLTQsXG4gICAgICAgICAgICAgICAgICAgIGNsb2M6IC01LFxuICAgICAgICAgICAgICAgICAgICBmbG9jOiAtNixcbiAgICAgICAgICAgICAgICAgICAgYmJsb2M6IC03LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgayA9IGtleW5hbWUucmVwbGFjZSgvXFxzKy9nLCBcIlwiKS50b0xvd2VyQ2FzZSgpLnN1YnN0cigwLCA1KTtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IGsubWF0Y2goL21hanxtaW58bWl4fGRvcnxwaHJ8bHlkfGxvY3xtLyk7XG4gICAgICAgICAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2NhbGUgPT0gXCJtYWpcIikge1xuICAgICAgICAgICAgICAgICAgICBra2V5ID0gay5zdWJzdHIoMCwgc2NhbGUuaW5kZXgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2NhbGUgPT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgICAgICBra2V5ID0gay5zdWJzdHIoMCwgc2NhbGUuaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBra2V5ID0gay5zdWJzdHIoMCwgc2NhbGUuaW5kZXggKyBzY2FsZVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAga2tleSA9IC9eW2EtZ11bI2JdPy8uZXhlYyhrKSB8fCBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGFjY2lkZW50YWxzKHNpZ2NvZGVzW2trZXldKTtcbiAgICAgICAgICAgIHZhciBleHRyYXMgPSBrZXluYW1lLnN1YnN0cihra2V5Lmxlbmd0aCkubWF0Y2goLyhfK3w9fFxcXispW2EtZ10vZ2kpO1xuICAgICAgICAgICAgaWYgKGV4dHJhcykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZXh0cmFzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBub3RlID0gZXh0cmFzW2pdLmNoYXJBdChleHRyYXNbal0ubGVuZ3RoIC0gMSkudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dHJhc1tqXS5jaGFyQXQoMCkgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHRbbm90ZV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbbm90ZV0gPSBleHRyYXNbal0uc3Vic3RyKDAsIGV4dHJhc1tqXS5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkaXRpdmVseSBhZGp1c3RzIHRoZSBiZWF0cyBmb3IgYSBzdGVtIGFuZCB0aGUgY29udGFpbmVkIG5vdGVzLlxuICAgICAgICBmdW5jdGlvbiBzeW5jb3BhdGVTdGVtKHN0ZW0sIHQpIHtcbiAgICAgICAgICAgIHZhciBqLFxuICAgICAgICAgICAgICAgIG5vdGUsXG4gICAgICAgICAgICAgICAgc3RlbXRpbWUgPSBzdGVtLnRpbWUsXG4gICAgICAgICAgICAgICAgbmV3dGltZSA9IHN0ZW10aW1lICsgdDtcbiAgICAgICAgICAgIHN0ZW0udGltZSA9IG5ld3RpbWU7XG4gICAgICAgICAgICBzeW5jb3BhdGVTdGVtO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0ZW0ubm90ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBub3RlID0gc3RlbS5ub3Rlc1tqXTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFkanVzdCBhIG5vdGUncyBkdXJhdGlvbiBpZiBpdCBtYXRjaGVkIHRoZSBzdGVtJ3MgZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKG5vdGUudGltZSA9PSBzdGVtdGltZSkge1xuICAgICAgICAgICAgICAgICAgICBub3RlLnRpbWUgPSBuZXd0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYXJrcyBldmVyeXRoaW5nIGluIHRoZSBzdGVtIHdpdGggdGhlIHNsdXIgYXR0cmlidXRlIChvciBkZWxldGVzIGl0KS5cbiAgICAgICAgZnVuY3Rpb24gc2x1clN0ZW0oc3RlbSwgYWRkU2x1cikge1xuICAgICAgICAgICAgdmFyIGosIG5vdGU7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RlbS5ub3Rlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIG5vdGUgPSBzdGVtLm5vdGVzW2pdO1xuICAgICAgICAgICAgICAgIGlmIChhZGRTbHVyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGUuc2x1cnJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub3RlLnNsdXJyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG5vdGUuc2x1cnJlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2NhbGVzIHRoZSBiZWF0cyBmb3IgYSBzdGVtIGFuZCB0aGUgY29udGFpbmVkIG5vdGVzLlxuICAgICAgICBmdW5jdGlvbiBzY2FsZVN0ZW0oc3RlbSwgcykge1xuICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICBzdGVtLnRpbWUgKj0gcztcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGVtLm5vdGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgc3RlbS5ub3Rlc1tqXS50aW1lICo9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2VzIG5vdGF0aW9uIG9mIHRoZSBmb3JtICgzIG9yICg1OjI6MTAsIHdoaWNoIG1lYW5zIHRvIGRvXG4gICAgICAgIC8vIHRoZSBmb2xsb3dpbmcgMyBub3RlcyBpbiB0aGUgc3BhY2Ugb2YgMiBub3Rlcywgb3IgdG8gZG8gdGhlIGZvbGxvd2luZ1xuICAgICAgICAvLyAxMCBub3RlcyBhdCB0aGUgcmF0ZSBvZiA1IG5vdGVzIHBlciAyIGJlYXRzLlxuICAgICAgICBmdW5jdGlvbiBwYXJzZUJlYXRsZXQodG9rZW4pIHtcbiAgICAgICAgICAgIHZhciBtID0gL15cXCgoXFxkKykoPzo6KFxcZCspKD86OihcXGQrKSk/KT8kLy5leGVjKHRva2VuKTtcbiAgICAgICAgICAgIGlmICghbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGNvdW50ID0gTnVtYmVyKG1bMV0pLFxuICAgICAgICAgICAgICAgIGJlYXRzID0gTnVtYmVyKG1bMl0pIHx8IDIsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBOdW1iZXIobVszXSkgfHwgY291bnQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRpbWU6IGJlYXRzIC8gY291bnQsXG4gICAgICAgICAgICAgICAgY291bnQ6IGR1cmF0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSAhcHBwISBtYXJraW5ncy5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VEZWNvcmF0aW9uKHRva2VuLCBhY2NlbnQpIHtcbiAgICAgICAgICAgIGlmICh0b2tlbi5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbi5zdWJzdHJpbmcoMSwgdG9rZW4ubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBwcHBcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwicHBwXCI6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VudC5keW5hbWljcyA9IDAuMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBwXCI6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VudC5keW5hbWljcyA9IDAuNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInBcIjpcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50LmR5bmFtaWNzID0gMC42O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibXBcIjpcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50LmR5bmFtaWNzID0gMC44O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWZcIjpcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50LmR5bmFtaWNzID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgICAgICAgICAgICBhY2NlbnQuZHluYW1pY3MgPSAxLjI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmZlwiOlxuICAgICAgICAgICAgICAgICAgICBhY2NlbnQuZHluYW1pY3MgPSAxLjQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmZmZcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmZmZlwiOlxuICAgICAgICAgICAgICAgICAgICBhY2NlbnQuZHluYW1pY3MgPSAxLjU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlcyBhIHN0ZW0sIHdoaWNoIG1heSBiZSBhIHNpbmdsZSBub3RlLCBvciB3aGljaCBtYXkgYmVcbiAgICAgICAgLy8gYSBjaG9yZGVkIG5vdGUuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlU3RlbSh0b2tlbnMsIGluZGV4LCBrZXksIGFjY2VudCkge1xuICAgICAgICAgICAgdmFyIG5vdGVzID0gW10sXG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBcIlwiLFxuICAgICAgICAgICAgICAgIHN0YWNjYXRvID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgbm90ZUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIG5vdGVUaW1lLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5LFxuICAgICAgICAgICAgICAgIGxhc3ROb3RlID0gbnVsbCxcbiAgICAgICAgICAgICAgICBtaW5TdGVtVGltZSA9IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGo7XG4gICAgICAgICAgICAvLyBBIHNpbmdsZSBzdGFjY2F0byBtYXJraW5nIGFwcGxpZXMgdG8gdGhlIGVudGlyZSBzdGVtLlxuICAgICAgICAgICAgaWYgKGluZGV4IDwgdG9rZW5zLmxlbmd0aCAmJiBcIi5cIiA9PSB0b2tlbnNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgc3RhY2NhdG8gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tpbmRleF0gPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBEZWFsIHdpdGggW0NFR10gY2hvcmRlZCBub3RhdGlvbi5cbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIC8vIFNjYW4gbm90ZXMgd2l0aGluIHRoZSBjaG9yZC5cbiAgICAgICAgICAgICAgICB3aGlsZSAoaW5kZXggPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBhbmQgc3BhY2UgYW5kICVjb21tZW50cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eW1xccyVdLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9bQS1HYS1nXS8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR3JhYiBhIHBpdGNoLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGl0Y2g6IGFwcGx5QWNjZW50KHRva2Vuc1tpbmRleCsrXSwga2V5LCBhY2NlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vdGUuZnJlcXVlbmN5ID0gVXRpbHMucGl0Y2hUb0ZyZXF1ZW5jeShsYXN0Tm90ZS5waXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3Rlcy5wdXNoKGxhc3ROb3RlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvW3h6WFpdLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHcmFiIGEgcmVzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb3RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoXCIuXCIgPT0gdG9rZW5zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBzdGFjY2F0byBtYXJrIGFwcGxpZXMgdG8gdGhlIGVudGlyZSBzdGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2NhdG8gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3RvcCBwYXJzaW5nIHRoZSBzdGVtIGlmIHNvbWV0aGluZyBpcyB1bnJlY29nbml6ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBhIHBpdGNoIG9yIHJlc3QsIGxvb2sgZm9yIGEgZHVyYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRva2Vucy5sZW5ndGggJiYgL14oPyFbXFxzJSFdKS4qW1xcZFxcL10vLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVEdXJhdGlvbiA9IHRva2Vuc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVUaW1lID0gZHVyYXRpb25Ub1RpbWUobm90ZUR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVEdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlVGltZSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyBhIG5vdGUgKG5vdCBhIHJlc3QpLCBzdG9yZSB0aGUgZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3ROb3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Tm90ZS5kdXJhdGlvbiA9IG5vdGVEdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb3RlLnRpbWUgPSBub3RlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGEgc3RlbSBoYXMgbW9yZSB0aGFuIG9uZSBkdXJhdGlvbiwgdXNlIHRoZSBzaG9ydGVzdFxuICAgICAgICAgICAgICAgICAgICAvLyBvbmUgZm9yIHRpbWluZy4gVGhlIHN0YW5kYXJkIHNheXMgdG8gcGljayB0aGUgZmlyc3Qgb25lLFxuICAgICAgICAgICAgICAgICAgICAvLyBidXQgaW4gcHJhY3RpY2UsIHRyYW5zY3JpYmVkIG11c2ljIG9ubGluZSBzZWVtcyB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBmb2xsb3cgdGhlIHJ1bGUgdGhhdCB0aGUgc3RlbSdzIGR1cmF0aW9uIGlzIGRldGVybWluZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gYnkgdGhlIHNob3J0ZXN0IGNvbnRhaW5lZCBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vdGVUaW1lICYmIG5vdGVUaW1lIDwgbWluU3RlbVRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gbm90ZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluU3RlbVRpbWUgPSBub3RlVGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBhIGR1cmF0aW9uLCBsb29rIGZvciBhIHRpZSBtYXJrLiAgSW5kaXZpZHVhbCBub3Rlc1xuICAgICAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYSBzdGVtIGNhbiBiZSB0aWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0b2tlbnMubGVuZ3RoICYmIFwiLVwiID09IHRva2Vuc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0Tm90ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVzW25vdGVzLmxlbmd0aCAtIDFdLnRpZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IHRoaW5nIGluIGEgY2hvcmQgc2hvdWxkIGJlIGEgXS4gIElmIGl0IGlzbid0LCB0aGVuXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBkb2Vzbid0IGxvb2sgbGlrZSBhIHN0ZW0gYWZ0ZXIgYWxsLCBhbmQgcmV0dXJuIG51bGwuXG4gICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tpbmRleF0gIT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluZGV4IDwgdG9rZW5zLmxlbmd0aCAmJiAvW0EtR2EtZ10vLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAvLyBHcmFiIGEgc2luZ2xlIG5vdGUuXG4gICAgICAgICAgICAgICAgbGFzdE5vdGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBpdGNoOiBhcHBseUFjY2VudCh0b2tlbnNbaW5kZXgrK10sIGtleSwgYWNjZW50KSxcbiAgICAgICAgICAgICAgICAgICAgdGllOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IDEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBsYXN0Tm90ZS5mcmVxdWVuY3kgPSBVdGlscy5waXRjaFRvRnJlcXVlbmN5KGxhc3ROb3RlLnBpdGNoKTtcbiAgICAgICAgICAgICAgICBub3Rlcy5wdXNoKGxhc3ROb3RlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCB0b2tlbnMubGVuZ3RoICYmIC9eW3h6WFpdJC8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIC8vIEdyYWIgYSByZXN0IC0gbm8gcGl0Y2guXG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZXRoaW5nIHdlIGRvbid0IHJlY29nbml6ZSAtIG5vdCBhIHN0ZW0uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSaWdodCBhZnRlciBhIFtjaG9yZF0sIG5vdGUsIG9yIHJlc3QsIGxvb2sgZm9yIGEgZHVyYXRpb24gbWFya2luZy5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRva2Vucy5sZW5ndGggJiYgL14oPyFbXFxzJSFdKS4qW1xcZFxcL10vLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IHRva2Vuc1tpbmRleCsrXTtcbiAgICAgICAgICAgICAgICBub3RlVGltZSA9IGR1cmF0aW9uVG9UaW1lKGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgZHVyYXRpb24gdG8gYWxsIHRoZSBudG9lcyBpbiB0aGUgc3RlbS5cbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBzcGVjIHN1Z2dlc3RzIG11bHRpcGx5aW5nIHRoaXMgZHVyYXRpb24sIGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgLy8gaWRpb20gaXMgbm90IHNlZW4gKHNvIGZhcikgaW4gcHJhY3RpY2UuXG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vdGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzW2pdLmR1cmF0aW9uID0gZHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzW2pdLnRpbWUgPSBub3RlVGltZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGVuIGxvb2sgZm9yIGEgdHJhaWxpbmcgdGllIG1hcmtpbmcuICBXaWxsIHRpZSBldmVyeSBub3RlIGluIGEgY2hvcmQuXG4gICAgICAgICAgICBpZiAoaW5kZXggPCB0b2tlbnMubGVuZ3RoICYmIFwiLVwiID09IHRva2Vuc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub3Rlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBub3Rlc1tqXS50aWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2NlbnQuZHluYW1pY3MpIHtcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eSA9IGFjY2VudC5keW5hbWljcztcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm90ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXNbal0udmVsb2NpdHkgPSB2ZWxvY2l0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICBzdGVtOiB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzOiBub3RlcyxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBzdGFjY2F0bzogc3RhY2NhdG8sXG4gICAgICAgICAgICAgICAgICAgIHRpbWU6IGR1cmF0aW9uVG9UaW1lKGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemVzIHBpdGNoIG1hcmtpbmdzIGJ5IHN0cmlwcGluZyBsZWFkaW5nID0gaWYgcHJlc2VudC5cbiAgICAgICAgZnVuY3Rpb24gc3RyaXBOYXR1cmFsKHBpdGNoKSB7XG4gICAgICAgICAgICBpZiAocGl0Y2gubGVuZ3RoID4gMCAmJiBwaXRjaC5jaGFyQXQoMCkgPT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl0Y2guc3Vic3RyKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBpdGNoO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3NlcyBhbiBhY2NlbnRlZCBwaXRjaCwgYXV0b21hdGljYWxseSBhcHBseWluZyBhY2NpZGVudGFsc1xuICAgICAgICAvLyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgd2l0aGluIHRoZSBtZWFzdXJlLCBhbmQgYWxzbyBzYXZpbmdcbiAgICAgICAgLy8gZXhwbGljaXQgYWNjaWRlbnRhbHMgdG8gY29udGludWUgdG8gYXBwbHkgaW4gdGhlIG1lYXN1cmUuXG4gICAgICAgIGZ1bmN0aW9uIGFwcGx5QWNjZW50KHBpdGNoLCBrZXksIGFjY2VudCkge1xuICAgICAgICAgICAgdmFyIG0gPSAvXihcXF4rfF8rfD18KShbQS1HYS1nXSkoLiopJC8uZXhlYyhwaXRjaCksXG4gICAgICAgICAgICAgICAgbGV0dGVyO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBpdGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGFuIGFjY2lkZW50YWwgaW4gb25lIG9jdGF2ZSBhcHBsaWVzIGluIG90aGVyIG9jdGF2ZXMuXG4gICAgICAgICAgICBsZXR0ZXIgPSBtWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAobVsxXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGVyZSBpcyBhbiBleHBsaWNpdCBhY2NpZGVudGFsLCB0aGVuIHJlbWVtYmVyIGl0IGZvclxuICAgICAgICAgICAgICAgIC8vIHRoZSByZXN0IG9mIHRoZSBtZWFzdXJlLlxuICAgICAgICAgICAgICAgIGFjY2VudFtsZXR0ZXJdID0gbVsxXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXBOYXR1cmFsKHBpdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY2NlbnQuaGFzT3duUHJvcGVydHkobGV0dGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIEFjY2lkZW50YWxzIGZyb20gdGhpcyBtZWFzdXJlIGFwcGx5IHRvIHVuYWNjZW50ZWQgbm90ZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwTmF0dXJhbChhY2NlbnRbbGV0dGVyXSArIG1bMl0gKyBtWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrZXkuaGFzT3duUHJvcGVydHkobGV0dGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIEtleSBzaWduYXR1cmVzIGFwcGx5IGJ5IGRlZmF1bHQuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmlwTmF0dXJhbChrZXlbbGV0dGVyXSArIG1bMl0gKyBtWzNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHJpcE5hdHVyYWwocGl0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIGFuIEFCQyBkdXJhdGlvbiB0byBhIG51bWJlciAoZS5nLiwgXCIvM1wiLT4wLjMzMyBvciBcIjExLzJcIi0+MS41KS5cbiAgICAgICAgZnVuY3Rpb24gZHVyYXRpb25Ub1RpbWUoZHVyYXRpb24pIHtcbiAgICAgICAgICAgIHZhciBtID0gL14oXFxkKikoPzpcXC8oXFxkKikpPyR8XihcXC8rKSQvLmV4ZWMoZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICAgICBpID0gMCxcbiAgICAgICAgICAgICAgICBpbGVuO1xuICAgICAgICAgICAgaWYgKCFtKSByZXR1cm47XG4gICAgICAgICAgICBpZiAobVszXSkgcmV0dXJuIE1hdGgucG93KDAuNSwgbVszXS5sZW5ndGgpO1xuICAgICAgICAgICAgZCA9IG1bMl0gPyBwYXJzZUZsb2F0KG1bMl0pIDogL1xcLy8udGVzdChkdXJhdGlvbikgPyAyIDogMTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBtaXhlZCBmcmF0aW9uczpcbiAgICAgICAgICAgIGlsZW4gPSAwO1xuICAgICAgICAgICAgbiA9IG1bMV0gPyBwYXJzZUZsb2F0KG1bMV0pIDogMTtcbiAgICAgICAgICAgIGlmIChtWzJdKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGlsZW4gKyAxIDwgbVsxXS5sZW5ndGggJiYgbiA+IGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWxlbiArPSAxO1xuICAgICAgICAgICAgICAgICAgICBpID0gcGFyc2VGbG9hdChtWzFdLnN1YnN0cmluZygwLCBpbGVuKSk7XG4gICAgICAgICAgICAgICAgICAgIG4gPSBwYXJzZUZsb2F0KG1bMV0uc3Vic3RyaW5nKGlsZW4pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaSArIG4gLyBkO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBJTlNUUlVNRU5UU1xuICAgIC8vXG4gICAgLy8gQWxsIGZ1cnRoZXIgZGV0YWlscyBvZiBhdWRpbyBoYW5kbGluZyBhcmUgZW5jYXBzdWxhdGVkIGluIHRoZSBJbnN0cnVtZW50XG4gICAgLy8gY2xhc3MsIHdoaWNoIGtub3dzIGhvdyB0byBzeW50aGVzaXplIGEgYmFzaWMgdGltYnJlOyBob3cgdG8gcGxheSBhbmRcbiAgICAvLyBzY2hlZHVsZSBhIHRvbmU7IGFuZCBob3cgdG8gcGFyc2UgYW5kIHNlcXVlbmNlIGEgc29uZyB3cml0dGVuIGluIEFCQ1xuICAgIC8vIG5vdGF0aW9uLlxuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIGFjY2VwdHMgYSB0aW1icmUgc3RyaW5nIG9yIG9iamVjdCwgc3BlY2lmeWluZ1xuICAgIC8vIGl0cyBkZWZhdWx0IHNvdW5kLiAgVGhlIG1haW4gbWVjaGFuaXNtcyBpbiBJbnN0cnVtZW50IGFyZSBmb3IgaGFuZGxpbmdcbiAgICAvLyBzZXF1ZW5jaW5nIG9mIGEgKHBvdGVudGlhbGx5IGxhcmdlKSBzZXQgb2Ygbm90ZXMgb3ZlciBhIChwb3RlbnRpYWxseVxuICAgIC8vIGxvbmcpIHBlcmlvZCBvZiB0aW1lLiAgVGhlIG92ZXJhbGwgc3RyYXRlZ3k6XG4gICAgLy9cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgRXZlbnRzOiAgICAgICdub3Rlb24nICAgICAgICAnbm90ZW9mZidcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgIHxcbiAgICAvLyB0b25lKCktKHF1aWNrIHRvbmVzKS0+fCBfc3RhcnRTZXQgLS0+fCBfZmluaXNoU2V0IC0tPnwgX2NsZWFudXBTZXQgLS0+fFxuICAgIC8vICAgXFwgICAgICAgICAgICAgICAgICAgfCAgLyAgICAgICAgICAgfCBQbGF5aW5nIHRvbmVzIHwgRG9uZSB0b25lcyAgICAgfFxuICAgIC8vICAgIFxcLS0tLSBfcXVldWUgLS0tLS0tfC0vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxuICAgIC8vICAgICAgb2YgZnV0dXJlIHRvbmVzICB8MyBzZWNzIGFoZWFkIHNlbnQgdG8gV2ViQXVkaW8sIHJlbW92ZWQgd2hlbiBkb25lXG4gICAgLy9cbiAgICAvLyBUaGUgcmVhc29uIGZvciB0aGlzIHF1ZXVpbmcgaXMgdG8gcmVkdWNlIHRoZSBjb21wbGV4aXR5IG9mIHRoZVxuICAgIC8vIG5vZGUgZ3JhcGggc2VudCB0byBXZWJBdWRpbzogYXQgYW55IHRpbWUsIFdlYkF1ZGlvIGlzIG9ubHlcbiAgICAvLyByZXNwb25zaWJsZSBmb3IgYWJvdXQgMiBzZWNvbmRzIG9mIG11c2ljLiAgSWYgYSBncmFwaCB3aXRoIHRvb1xuICAgIC8vIHRvbyBtYW55IG5vZGVzIGlzIHNlbnQgdG8gV2ViQXVkaW8gYXQgb25jZSwgb3V0cHV0IGRpc3RvcnRzIGJhZGx5LlxuXG4gICAgY2xhc3MgSW5zdHJ1bWVudCB7XG4gICAgICAgIHN0YXRpYyB0aW1lT2Zmc2V0ID0gMC4wNjI1OyAvLyBTZWNvbmRzIHRvIGRlbGF5IGFsbCBhdWRpYWJsZSB0aW1pbmcuXG4gICAgICAgIHN0YXRpYyBkZXF1ZXVlVGltZSA9IDAuNTsgLy8gU2Vjb25kcyBiZWZvcmUgYW4gZXZlbnQgdG8gcmVleGFtaW5lIHF1ZXVlLlxuICAgICAgICBzdGF0aWMgYnVmZmVyU2VjcyA9IDI7IC8vIFNlY29uZHMgYWhlYWQgdG8gcHV0IG5vdGVzIGluIFdlYkF1ZGlvLlxuICAgICAgICBzdGF0aWMgdG9uZUxlbmd0aCA9IDE7IC8vIERlZmF1bHQgZHVyYXRpb24gb2YgYSB0b25lLlxuICAgICAgICBzdGF0aWMgY2xlYW51cERlbGF5ID0gMC4xOyAvLyBTaWxlbnQgdGltZSBiZWZvcmUgZGlzY29ubmVjdGluZyBub2Rlcy5cblxuICAgICAgICAvLyBBY2NlcHRzIGVpdGhlciBhbiBBQkMgcGl0Y2ggb3IgYSBtaWRpIG51bWJlciBhbmQgY29udmVydHMgdG8gbWlkaS5cbiAgICAgICAgc3RhdGljIHBpdGNoVG9NaWRpKG4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnBpdGNoVG9NaWRpKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY2NlcHRzIGVpdGhlciBhbiBBQkMgcGl0Y2ggb3IgYSBtaWRpIG51bWJlciBhbmQgY29udmVydHMgdG8gQUJDIHBpdGNoLlxuICAgICAgICBzdGF0aWMgbWlkaVRvUGl0Y2gobikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMubWlkaVRvUGl0Y2gobik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vdXQ7XG4gICAgICAgIF9hdG9wO1xuICAgICAgICBfdGltYnJlO1xuICAgICAgICBfcXVldWU7XG4gICAgICAgIF9taW5RdWV1ZVRpbWU7XG4gICAgICAgIF9tYXhTY2hlZHVsZWRUaW1lO1xuICAgICAgICBfdW5zb3J0ZWRRdWV1ZTtcbiAgICAgICAgX3N0YXJ0U2V0O1xuICAgICAgICBfZmluaXNoU2V0O1xuICAgICAgICBfY2xlYW51cFNldDtcbiAgICAgICAgX2NhbGxiYWNrU2V0O1xuICAgICAgICBfaGFuZGxlcnM7XG4gICAgICAgIF9ub3c7XG4gICAgICAgIF9wb2xsVGltZXI7XG5cbiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucz86IGFueSkge1xuICAgICAgICAgICAgdGhpcy5fYXRvcCA9IFV0aWxzLmdldEF1ZGlvVG9wKCk7IC8vIEF1ZGlvIGNvbnRleHQuXG4gICAgICAgICAgICB0aGlzLl90aW1icmUgPSBVdGlscy5tYWtlVGltYnJlKG9wdGlvbnMsIHRoaXMuX2F0b3ApOyAvLyBUaGUgaW5zdHJ1bWVudCdzIHRpbWJyZS5cbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gW107IC8vIEEgcXVldWUgb2YgZnV0dXJlIHRvbmVzIHRvIHBsYXkuXG4gICAgICAgICAgICB0aGlzLl9taW5RdWV1ZVRpbWUgPSBJbmZpbml0eTsgLy8gVGhlIGVhcmxpZXN0IHRpbWUgaW4gX3F1ZXVlLlxuICAgICAgICAgICAgdGhpcy5fbWF4U2NoZWR1bGVkVGltZSA9IDA7IC8vIFRoZSBsYXRlc3QgdGltZSBpbiBfcXVldWUuXG4gICAgICAgICAgICB0aGlzLl91bnNvcnRlZFF1ZXVlID0gZmFsc2U7IC8vIFRydWUgaWYgX3F1ZXVlIGlzIHVuc29ydGVkLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRTZXQgPSBbXTsgLy8gVW5zdGFydGVkIHRvbmVzIGFscmVhZHkgc2VudCB0byBXZWJBdWRpby5cbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaFNldCA9IHt9OyAvLyBTdGFydGVkIHRvbmVzIHBsYXlpbmcgaW4gV2ViQXVkaW8uXG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwU2V0ID0gW107IC8vIFRvbmVzIHdhaXRpbmcgZm9yIGNsZWFudXAuXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja1NldCA9IFtdOyAvLyBBIHNldCBvZiBzY2hlZHVsZWQgY2FsbGJhY2tzLlxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTsgLy8gJ25vdGVvbicgYW5kICdub3Rlb2ZmJyBoYW5kbGVycy5cbiAgICAgICAgICAgIHRoaXMuX25vdyA9IG51bGw7IC8vIEEgY2FjaGVkIGN1cnJlbnQtdGltZSB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChVdGlscy5pc0F1ZGlvUHJlc2VudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWxlbmNlKCk7IC8vIEluaXRpYWxpemVzIHRvcC1sZXZlbCBhdWRpbyBub2RlLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgZGVmYXVsdCB0aW1icmUgZm9yIHRoZSBpbnN0cnVtZW50LiAgU2VlIGRlZmF1bHRUaW1icmUuXG4gICAgICAgIHNldFRpbWJyZSh0KSB7XG4gICAgICAgICAgICB0aGlzLl90aW1icmUgPSBVdGlscy5tYWtlVGltYnJlKHQsIHRoaXMuX2F0b3ApOyAvLyBTYXZlcyBhIGNvcHkuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBkZWZhdWx0IHRpbWJyZSBmb3IgdGhlIGluc3RydW1lbnQgYXMgYW4gb2JqZWN0LlxuICAgICAgICBnZXRUaW1icmUodCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLm1ha2VUaW1icmUodGhpcy5fdGltYnJlLCB0aGlzLl9hdG9wKTsgLy8gTWFrZXMgYSBjb3B5LlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgb3ZlcmFsbCB2b2x1bWUgZm9yIHRoZSBpbnN0cnVtZW50IGltbWVkaWF0ZWx5LlxuICAgICAgICBzZXRWb2x1bWUodikge1xuICAgICAgICAgICAgLy8gV2l0aG91dCBhbiBhdWRpbyBzeXN0ZW0sIHZvbHVtZSBjYW5ub3QgYmUgc2V0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0LmdhaW4udmFsdWUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgb3ZlcmFsbCB2b2x1bWUgZm9yIHRoZSBpbnN0cnVtZW50LlxuICAgICAgICBnZXRWb2x1bWUodikge1xuICAgICAgICAgICAgLy8gV2l0aG91dCBhbiBhdWRpbyBzeXN0ZW0sIHZvbHVtZSBpcyBzdHVjayBhdCB6ZXJvLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX291dC5nYWluLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lsZW5jZXMgdGhlIGluc3RydW1lbnQgaW1tZWRpYXRlbHkgYnkgcmVpbml0aWFsaXppbmcgdGhlIGF1ZGlvXG4gICAgICAgIC8vIGdyYXBoIGZvciB0aGlzIGluc3RydW1lbnQgYW5kIGVtcHR5aW5nIG9yIGZsdXNoaW5nIGFsbCBxdWV1ZXMgaW4gdGhlXG4gICAgICAgIC8vIHNjaGVkdWxlci4gIENhcmVmdWxseSBub3RpZmllcyBhbGwgbm90ZXMgdGhhdCBoYXZlIHN0YXJ0ZWQgYnV0IG5vdFxuICAgICAgICAvLyB5ZXQgZmluaXNoZWQsIGFuZCBzZXF1ZW5jZXMgdGhhdCBhcmUgYXdhaXRpbmcgc2NoZWR1bGVkIGNhbGxiYWNrcy5cbiAgICAgICAgLy8gRG9lcyBub3Qgbm90aWZ5IG5vdGVzIHRoYXQgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQuXG4gICAgICAgIHNpbGVuY2UoKSB7XG4gICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCxcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgaW5pdHZvbHVtZSA9IDE7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIGZ1dHVyZSBub3Rlcy5cbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9taW5RdWV1ZVRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMuX21heFNjaGVkdWxlZFRpbWUgPSAwO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBub3RpZnkgbm90ZXMgdGhhdCBoYXZlbid0IHN0YXJ0ZWQgeWV0LlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRTZXQubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgLy8gRmx1c2ggZmluaXNoIGNhbGxiYWNrcyB0aGF0IGFyZSBwcm9taXNlZC5cbiAgICAgICAgICAgIGZpbmlzaGVkID0gdGhpcy5fZmluaXNoU2V0O1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoU2V0ID0ge307XG5cbiAgICAgICAgICAgIC8vIEZsdXNoIG9uZS10aW1lIGNhbGxhY2tzIHRoYXQgYXJlIHByb21pc2VkLlxuICAgICAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tTZXQ7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja1NldCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSBhdWRpbyBncmFwaCBmb3IgdGhpcyBpbnN0cnVtZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX291dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgaW5pdHZvbHVtZSA9IHRoaXMuX291dC5nYWluLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWluaXRpYWxpemUgdGhlIGF1ZGlvIGdyYXBoOiBhbGwgYXVkaW8gZm9yIHRoZSBpbnN0cnVtZW50XG4gICAgICAgICAgICAvLyBtdWx0aXBsZXhlcyB0aHJvdWdoIGEgc2luZ2xlIGdhaW4gbm9kZSB3aXRoIGEgbWFzdGVyIHZvbHVtZS5cbiAgICAgICAgICAgIHRoaXMuX2F0b3AgPSBVdGlscy5nZXRBdWRpb1RvcCgpO1xuICAgICAgICAgICAgdGhpcy5fb3V0ID0gdGhpcy5fYXRvcC5hYy5jcmVhdGVHYWluKCk7XG4gICAgICAgICAgICAvLyB0aGlzLl9vdXQuZ2Fpbi52YWx1ZSA9IGluaXR2b2x1bWU7IC8vIFJPTllFSCBSRU1PVkVEIERVRSBUTyBCVUcuXG4gICAgICAgICAgICB0aGlzLl9vdXQuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUoaW5pdHZvbHVtZSwgdGhpcy5fYXRvcC5hYy5jdXJyZW50VGltZSwgMC4wMDEpOyAvLyBST05ZRUggQURERURcbiAgICAgICAgICAgIHRoaXMuX291dC5jb25uZWN0KHRoaXMuX2F0b3Aub3V0KTtcblxuICAgICAgICAgICAgLy8gQXMgYSBsYXN0IHN0ZXAsIGNhbGwgYWxsIHByb21pc2VkIG5vdGlmaWNhdGlvbnMuXG4gICAgICAgICAgICBmb3IgKGogaW4gZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwibm90ZW9mZlwiLCBmaW5pc2hlZFtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2pdLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGdXR1cmUgbm90ZXMgYXJlIHNjaGVkdWxlZCByZWxhdGl2ZSB0byBub3coKSwgd2hpY2ggcHJvdmlkZXNcbiAgICAgICAgLy8gYWNjZXNzIHRvIGF1ZGlvQ3VycmVudFN0YXJ0VGltZSgpLCBhIHRpbWUgdGhhdCBob2xkcyBzdGVhZHlcbiAgICAgICAgLy8gdW50aWwgdGhlIHNjcmlwdCByZWxlYXNlcyB0byB0aGUgZXZlbnQgbG9vcC4gIFdoZW4gX25vdyBpc1xuICAgICAgICAvLyBub24tbnVsbCwgaXQgaW5kaWNhdGVzIHRoYXQgc2NoZWR1bGluZyBpcyBhbHJlYWR5IGluIHByb2dyZXNzLlxuICAgICAgICAvLyBUaGUgdGltZXItZHJpdmVuIF9kb1BvbGwgZnVuY3Rpb24gY2xlYXJzIHRoZSBjYWNoZWQgX25vdy5cbiAgICAgICAgbm93KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UG9sbFRpbWVyKHRydWUpOyAvLyBwYXNzaW5nICh0cnVlKSBzZXRzIHRoaXMuX25vdy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3c7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyLiAgRG9uZSB3aXRob3V0IGpRdWVyeSB0byByZWR1Y2UgZGVwZW5kZW5jaWVzLlxuICAgICAgICBvbihldmVudG5hbWUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50bmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudG5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudG5hbWVdLnB1c2goY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5yZWdpc3RlciBhbiBldmVudCBoYW5kbGVyLiAgRG9uZSB3aXRob3V0IGpRdWVyeSB0byByZWR1Y2UgZGVwZW5kZW5jaWVzLlxuICAgICAgICBvZmYoZXZlbnRuYW1lLCBjYikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50bmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50bmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bnQgPSB0aGlzLl9oYW5kbGVyc1tldmVudG5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaHVudC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh1bnRbal0gPT09IGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVudC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpZ2dlciBhbiBldmVudCwgbm90aWZ5aW5nIGFueSByZWdpc3RlcmVkIGhhbmRsZXJzLlxuICAgICAgICBfdHJpZ2dlcihldmVudG5hbWUsIHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIGNiID0gdGhpcy5faGFuZGxlcnNbZXZlbnRuYW1lXSxcbiAgICAgICAgICAgICAgICBqO1xuICAgICAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYi5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwsIGNvbW1vbiBjYXNlIG9mIG9uZSBoYW5kbGVyOiBubyBjb3B5IG5lZWRlZC5cbiAgICAgICAgICAgICAgICBjYlswXShyZWNvcmQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGFycmF5IG9mIGNhbGxiYWNrcyBiZWZvcmUgaXRlcmF0aW5nLCBiZWNhdXNlIHRoZVxuICAgICAgICAgICAgLy8gbWFpbiB0aGlzLl9oYW5kbGVycyBjb3B5IGNvdWxkIGJlIGNoYW5nZWQgYnkgYSBoYW5kbGVyLlxuICAgICAgICAgICAgLy8gWW91IGdldCBub3RpZmllZCBpZi1hbmQtb25seS1pZiB5b3UgYXJlIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBzdGFydGluZyBtb21lbnQgb2YgX3RyaWdnZXIuXG4gICAgICAgICAgICBjYiA9IGNiLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY2IubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYltqXShyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVsbHMgdGhlIFdlYkF1ZGlvIEFQSSB0byBwbGF5IGEgdG9uZSAobm93IG9yIHNvb24pLiAgVGhlIHBhc3NlZFxuICAgICAgICAvLyByZWNvcmQgc3BlY2lmaWVzIGEgc3RhcnQgdGltZSBhbmQgcmVsZWFzZSB0aW1lLCBhbiBBRFNSIGVudmVsb3BlLFxuICAgICAgICAvLyBhbmQgb3RoZXIgdGltYnJlIHBhcmFtZXRlcnMuICBUaGlzIGZ1bmN0aW9uIHNldHMgdXAgYSBXZWJBdWRpb1xuICAgICAgICAvLyBub2RlIGdyYXBoIGZvciB0aGUgdG9uZSBnZW5lcmF0b3JzIGFuZCBmaWx0ZXJzIGZvciB0aGUgdG9uZS5cbiAgICAgICAgX21ha2VTb3VuZChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB0aW1icmUgPSByZWNvcmQudGltYnJlIHx8IHRoaXMuX3RpbWJyZSxcbiAgICAgICAgICAgICAgICBzdGFydHRpbWUgPSByZWNvcmQudGltZSArIEluc3RydW1lbnQudGltZU9mZnNldCxcbiAgICAgICAgICAgICAgICByZWxlYXNldGltZSA9IHN0YXJ0dGltZSArIHJlY29yZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBhdHRhY2t0aW1lID0gTWF0aC5taW4ocmVsZWFzZXRpbWUsIHN0YXJ0dGltZSArIHRpbWJyZS5hdHRhY2spLFxuICAgICAgICAgICAgICAgIGRlY2F5dGltZSA9IHRpbWJyZS5kZWNheSAqIE1hdGgucG93KDQ0MCAvIHJlY29yZC5mcmVxdWVuY3ksIHRpbWJyZS5kZWNheWZvbGxvdyksXG4gICAgICAgICAgICAgICAgZGVjYXlzdGFydHRpbWUgPSBhdHRhY2t0aW1lLFxuICAgICAgICAgICAgICAgIHN0b3B0aW1lID0gcmVsZWFzZXRpbWUgKyB0aW1icmUucmVsZWFzZSxcbiAgICAgICAgICAgICAgICBkb3VibGVkID0gdGltYnJlLmRldHVuZSAmJiB0aW1icmUuZGV0dW5lICE9IDEuMCxcbiAgICAgICAgICAgICAgICBhbXAgPSB0aW1icmUuZ2FpbiAqIHJlY29yZC52ZWxvY2l0eSAqIChkb3VibGVkID8gMC41IDogMS4wKSxcbiAgICAgICAgICAgICAgICBhYyA9IHRoaXMuX2F0b3AuYWMsXG4gICAgICAgICAgICAgICAgZyxcbiAgICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgbzIsXG4gICAgICAgICAgICAgICAgcHdhdmUsXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB3ZixcbiAgICAgICAgICAgICAgICBid2Y7XG4gICAgICAgICAgICAvLyBPbmx5IGhvb2sgdXAgdG9uZSBnZW5lcmF0b3JzIGlmIGl0IGlzIGFuIGF1ZGlibGUgc291bmQuXG4gICAgICAgICAgICBpZiAocmVjb3JkLmR1cmF0aW9uID4gMCAmJiByZWNvcmQudmVsb2NpdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZyA9IGFjLmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgICAgICAgICBnLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgc3RhcnR0aW1lKTtcbiAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoYW1wLCBhdHRhY2t0aW1lKTtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIGJlZ2lubmluZyBvZiB0aGUgZGVjYXksIHVzZSBsaW5lYXJSYW1wVG9WYWx1ZSBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgLy8gb2Ygc2V0VGFyZ2V0QXRUaW1lLCBiZWNhdXNlIGl0IGF2b2lkcyBodHRwOi8vY3JidWcuY29tLzI1NDk0Mi5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZGVjYXlzdGFydHRpbWUgPCBhdHRhY2t0aW1lICsgMSAvIDMyICYmIGRlY2F5c3RhcnR0aW1lICsgMSAvIDI1NiA8IHJlbGVhc2V0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgdHJhY2Ugb3V0IHRoZSBjdXJ2ZSBpbiBpbmNyZW1lbnRzIG9mIDEvMjU2IHNlY1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdXAgdG8gMS8zMiBzZWNvbmRzLlxuICAgICAgICAgICAgICAgICAgICBkZWNheXN0YXJ0dGltZSArPSAxIC8gMjU2O1xuICAgICAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoYW1wICogKHRpbWJyZS5zdXN0YWluICsgKDEgLSB0aW1icmUuc3VzdGFpbikgKiBNYXRoLmV4cCgoYXR0YWNrdGltZSAtIGRlY2F5c3RhcnR0aW1lKSAvIGRlY2F5dGltZSkpLCBkZWNheXN0YXJ0dGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgcmVzdCBvZiB0aGUgZGVjYXksIHVzZSBzZXRUYXJnZXRBdFRpbWUuXG4gICAgICAgICAgICAgICAgZy5nYWluLnNldFRhcmdldEF0VGltZShhbXAgKiB0aW1icmUuc3VzdGFpbiwgZGVjYXlzdGFydHRpbWUsIGRlY2F5dGltZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlbiBhdCByZWxlYXNlIHRpbWUsIG1hcmsgdGhlIHZhbHVlIGFuZCByYW1wIHRvIHplcm8uXG4gICAgICAgICAgICAgICAgZy5nYWluLnNldFZhbHVlQXRUaW1lKGFtcCAqICh0aW1icmUuc3VzdGFpbiArICgxIC0gdGltYnJlLnN1c3RhaW4pICogTWF0aC5leHAoKGF0dGFja3RpbWUgLSByZWxlYXNldGltZSkgLyBkZWNheXRpbWUpKSwgcmVsZWFzZXRpbWUpO1xuICAgICAgICAgICAgICAgIGcuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBzdG9wdGltZSk7XG4gICAgICAgICAgICAgICAgZy5jb25uZWN0KHRoaXMuX291dCk7XG4gICAgICAgICAgICAgICAgLy8gSG9vayB1cCBhIGxvdy1wYXNzIGZpbHRlciBpZiBjdXRvZmYgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmICgoIXRpbWJyZS5jdXRvZmYgJiYgIXRpbWJyZS5jdXRmb2xsb3cpIHx8IHRpbWJyZS5jdXRvZmYgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGN1dG9mZiBmcmVxdWVuY3kgYWRqdXN0ZWQgdXNpbmcgY3V0Zm9sbG93LlxuICAgICAgICAgICAgICAgICAgICBmID0gYWMuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGYuZnJlcXVlbmN5LnZhbHVlID0gdGltYnJlLmN1dG9mZiArIHJlY29yZC5mcmVxdWVuY3kgKiB0aW1icmUuY3V0Zm9sbG93OyAvLyBST05ZRUggUkVNT1ZFRCBEVUUgVE8gQlVHLlxuICAgICAgICAgICAgICAgICAgICAvLyBmLlEudmFsdWUgPSB0aW1icmUucmVzb25hbmNlOyAvLyBST05ZRUggUkVNT1ZFRCBEVUUgVE8gQlVHLlxuICAgICAgICAgICAgICAgICAgICBmLmZyZXF1ZW5jeS5zZXRUYXJnZXRBdFRpbWUodGltYnJlLmN1dG9mZiArIHJlY29yZC5mcmVxdWVuY3kgKiB0aW1icmUuY3V0Zm9sbG93LCB0aGlzLl9hdG9wLmFjLmN1cnJlbnRUaW1lLCAwLjAwMSk7IC8vIFJPTllFSCBBRERFRFxuICAgICAgICAgICAgICAgICAgICBmLlEuc2V0VGFyZ2V0QXRUaW1lKHRpbWJyZS5yZXNvbmFuY2UsIHRoaXMuX2F0b3AuYWMuY3VycmVudFRpbWUsIDAuMDAxKTsgLy8gUk9OWUVIIEFEREVEXG4gICAgICAgICAgICAgICAgICAgIGYuY29ubmVjdChnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSG9vayB1cCB0aGUgbWFpbiBvc2NpbGxhdG9yLlxuICAgICAgICAgICAgICAgIG8gPSBVdGlscy5tYWtlT3NjaWxsYXRvcih0aGlzLl9hdG9wLCB0aW1icmUud2F2ZSwgcmVjb3JkLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgby5jb25uZWN0KGYpO1xuICAgICAgICAgICAgICAgIG8uc3RhcnQoc3RhcnR0aW1lKTtcbiAgICAgICAgICAgICAgICBvLnN0b3Aoc3RvcHRpbWUpO1xuICAgICAgICAgICAgICAgIC8vIEhvb2sgdXAgYSBkZXR1bmVkIG9zY2lsbGF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGRvdWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbzIgPSBVdGlscy5tYWtlT3NjaWxsYXRvcih0aGlzLl9hdG9wLCB0aW1icmUud2F2ZSwgcmVjb3JkLmZyZXF1ZW5jeSAqIHRpbWJyZS5kZXR1bmUpO1xuICAgICAgICAgICAgICAgICAgICBvMi5jb25uZWN0KGYpO1xuICAgICAgICAgICAgICAgICAgICBvMi5zdGFydChzdGFydHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBvMi5zdG9wKHN0b3B0aW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgbm9kZXMgaW4gdGhlIHJlY29yZCBzbyB0aGF0IHRoZXkgY2FuIGJlIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdG9uZSBpcyB0cnVuY2F0ZWQgbGF0ZXIuXG4gICAgICAgICAgICAgICAgcmVjb3JkLmdhaW5Ob2RlID0gZztcbiAgICAgICAgICAgICAgICByZWNvcmQub3NjaWxsYXRvcnMgPSBbb107XG4gICAgICAgICAgICAgICAgaWYgKGRvdWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLm9zY2lsbGF0b3JzLnB1c2gobzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNvcmQuY2xlYW51cHRpbWUgPSBzdG9wdGltZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5hdWRpYmxlIHNvdW5kcyBhcmUgc2NoZWR1bGVkOiB0aGVpciBwdXJwb3NlIGlzIHRvIHRydW5jYXRlXG4gICAgICAgICAgICAgICAgLy8gYXVkaWJsZSB0b25lcyBhdCB0aGUgc2FtZSBwaXRjaC4gIEJ1dCBkdXJhdGlvbiBpcyBzZXQgdG8gemVyb1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSBhcmUgY2xlYW5lZCB1cCBxdWlja2x5LlxuICAgICAgICAgICAgICAgIHJlY29yZC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGFydFNldC5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ1bmNhdGVzIGEgc291bmQgcHJldmlvdXNseSBzY2hlZHVsZWQgYnkgX21ha2VTb3VuZCBieSB1c2luZ1xuICAgICAgICAvLyBjYW5jZWxTY2hlZHVsZWRWYWx1ZXMgYW5kIGRpcmVjdGx5IHJhbXBpbmcgZG93biB0byB6ZXJvLlxuICAgICAgICAvLyBDYW4gb25seSBiZSB1c2VkIHRvIHNob3J0ZW4gYSBzb3VuZC5cbiAgICAgICAgX3RydW5jYXRlU291bmQocmVjb3JkLCB0cnVuY2F0ZXRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0cnVuY2F0ZXRpbWUgPCByZWNvcmQudGltZSArIHJlY29yZC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJlY29yZC5kdXJhdGlvbiA9IE1hdGgubWF4KDAsIHRydW5jYXRldGltZSAtIHJlY29yZC50aW1lKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmdhaW5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1icmUgPSByZWNvcmQudGltYnJlIHx8IHRoaXMuX3RpbWJyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0dGltZSA9IHJlY29yZC50aW1lICsgSW5zdHJ1bWVudC50aW1lT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXRpbWUgPSB0cnVuY2F0ZXRpbWUgKyBJbnN0cnVtZW50LnRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2t0aW1lID0gTWF0aC5taW4ocmVsZWFzZXRpbWUsIHN0YXJ0dGltZSArIHRpbWJyZS5hdHRhY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjYXl0aW1lID0gdGltYnJlLmRlY2F5ICogTWF0aC5wb3coNDQwIC8gcmVjb3JkLmZyZXF1ZW5jeSwgdGltYnJlLmRlY2F5Zm9sbG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3B0aW1lID0gcmVsZWFzZXRpbWUgKyB0aW1icmUucmVsZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXB0aW1lID0gc3RvcHRpbWUgKyBJbnN0cnVtZW50LmNsZWFudXBEZWxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZWQgPSB0aW1icmUuZGV0dW5lICYmIHRpbWJyZS5kZXR1bmUgIT0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1wID0gdGltYnJlLmdhaW4gKiByZWNvcmQudmVsb2NpdHkgKiAoZG91YmxlZCA/IDAuNSA6IDEuMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHJlY29yZC5nYWluTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGFueSBlbnZlbG9wZSBwb2ludHMgYWZ0ZXIgdGhlIG5ldyByZWxlYXNldGltZS5cbiAgICAgICAgICAgICAgICAgICAgZy5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhyZWxlYXNldGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxlYXNldGltZSA8PSBzdGFydHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2UgYmVmb3JlIHN0YXJ0PyAgVG90YWxseSBzaWxlbmNlIHRoZSBub3RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZy5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHJlbGVhc2V0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWxlYXNldGltZSA8PSBhdHRhY2t0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIGJlZm9yZSBhdHRhY2sgaXMgZG9uZT8gIEludGVycnVwdCByYW1wIHVwLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZy5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKChhbXAgKiAocmVsZWFzZXRpbWUgLSBzdGFydHRpbWUpKSAvIChhdHRhY2t0aW1lIC0gc3RhcnR0aW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoKGFtcCAqIChyZWxlYXNldGltZSAtIHN0YXJ0dGltZSkpIC8gKGF0dGFja3RpbWUgLSBzdGFydHRpbWUpLCBzdGFydHRpbWUpOyAvLyBST05ZRUggQURERUQgU0VDT05EIFBBUkFNIFwic3RhcnR0aW1lXCIuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIGR1cmluZyBkZWNheT8gIEludGVycnVwdCBkZWNheSBkb3duLlxuICAgICAgICAgICAgICAgICAgICAgICAgZy5nYWluLnNldFZhbHVlQXRUaW1lKGFtcCAqICh0aW1icmUuc3VzdGFpbiArICgxIC0gdGltYnJlLnN1c3RhaW4pICogTWF0aC5leHAoKGF0dGFja3RpbWUgLSByZWxlYXNldGltZSkgLyBkZWNheXRpbWUpKSwgcmVsZWFzZXRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gcmFtcCBkb3duIHRvIHplcm8gYWNjb3JkaW5nIHRvIHJlY29yZC5yZWxlYXNlLlxuICAgICAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgc3RvcHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBzdG9wdGltZSwgc3RvcCB0aGUgb3NjaWxsYXRvcnMuICBUaGlzIGlzIG5lY2Vzc2FyeSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGltaW5hdGUgZXh0cmEgd29yayBmb3IgV2ViQXVkaW8gZm9yIG5vLWxvbmdlci1hdWRpYmxlIG5vdGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLm9zY2lsbGF0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmVjb3JkLm9zY2lsbGF0b3JzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLm9zY2lsbGF0b3JzW2pdLnN0b3Aoc3RvcHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGRpc2Nvbm5lY3QuXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5jbGVhbnVwdGltZSA9IGNsZWFudXB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY29yZSBzY2hlZHVsaW5nIGxvb3AgaXMgbWFuYWdlZCBieSBJbnN0cnVtZW50Ll9kb1BvbGwuICBJdCByZWFkc1xuICAgICAgICAvLyB0aGUgYXVkaW9jb250ZXh0J3MgY3VycmVudCB0aW1lIGFuZCBwdXNoZXMgdG9uZSByZWNvcmRzIGZyb20gb25lXG4gICAgICAgIC8vIHN0YWdlIHRvIHRoZSBuZXh0LlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgZmlyc3Qgc3RhZ2UgaXMgdGhlIF9xdWV1ZSwgd2hpY2ggaGFzIHRvbmVzIHRoYXQgaGF2ZSBub3RcbiAgICAgICAgLy8gICAgeWV0IGJlZW4gZ2l2ZW4gdG8gV2ViQXVkaW8uIFRoaXMgbG9vcCBzY2FucyBfcXVldWUgdG8gZmluZFxuICAgICAgICAvLyAgICBub3RlcyB0aGF0IG5lZWQgdG8gYmVnaW4gaW4gdGhlIG5leHQgZmV3IHNlY29uZHM7IHRoZW4gaXRcbiAgICAgICAgLy8gICAgc2VuZHMgdGhvc2UgdG8gV2ViQWR1aW8gYW5kIG1vdmVzIHRoZW0gdG8gX3N0YXJ0U2V0LiBCZWNhdXNlXG4gICAgICAgIC8vICAgIHNjaGVkdWxlZCBzb25ncyBjYW4gYmUgbG9uZywgX3F1ZXVlIGNhbiBiZSBsYXJnZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gMi4gU2Vjb25kIGlzIF9zdGFydFNldCwgd2hpY2ggaGFzIHRvbmVzIHRoYXQgaGF2ZSBiZWVuIGdpdmVuIHRvXG4gICAgICAgIC8vICAgIFdlYkF1ZGlvLCBidXQgd2hvc2Ugc3RhcnQgdGltZXMgaGF2ZSBub3QgeWV0IGVsYXBzZWQuIFdoZW5cbiAgICAgICAgLy8gICAgdGhlIHRpbWUgYWR2YW5jZXMgcGFzdCB0aGUgc3RhcnQgdGltZSBvZiBhIHJlY29yZCwgYSAnbm90ZW9uJ1xuICAgICAgICAvLyAgICBub3RpZmljYXRpb24gaXMgZmlyZWQgZm9yIHRoZSB0b25lLCBhbmQgaXQgaXMgbW92ZWQgdG9cbiAgICAgICAgLy8gICAgX2ZpbmlzaFNldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gMy4gX2ZpbmlzaFNldCByZXByZXNlbnRzIHRoZSBub3RlcyB0aGF0IGFyZSBjdXJyZW50bHkgc291bmRpbmcuXG4gICAgICAgIC8vICAgIFRoZSBwcm9ncmFtbWluZyBtb2RlbCBmb3IgSW5zdHJ1bWVudCBpcyB0aGF0IG9ubHkgb25lIHRvbmUgb2ZcbiAgICAgICAgLy8gICAgYSBzcGVjaWZpYyBmcmVxdWVuY3kgbWF5IGJlIHBsYXllZCBhdCBvbmNlIHdpdGhpbiBhIEluc3RydW1lbnQsXG4gICAgICAgIC8vICAgIHNvIG9ubHkgb25lIHRvbmUgb2YgYSBnaXZlbiBmcmVxdWVuY3kgbWF5IGV4aXN0IGluIF9maW5pc2hTZXRcbiAgICAgICAgLy8gICAgYXQgb25jZS4gIFdoZW4gdGhlcmUgaXMgYSBjb25mbGljdCwgdGhlIHNvb25lci10by1lbmQtbm90ZVxuICAgICAgICAvLyAgICBpcyB0cnVuY2F0ZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDQuIEFmdGVyIGEgbm90ZSBpcyByZWxlYXNlZCwgaXQgbWF5IGhhdmUgYSBsaXRsZSByZWxlYXNlIHRpbWVcbiAgICAgICAgLy8gICAgKGRlcGVuZGluZyBvbiB0aW1icmUucmVsZWFzZSksIGFmdGVyIHdoaWNoIHRoZSBub2RlcyBjYW5cbiAgICAgICAgLy8gICAgYmUgdG90YWxseSBkaXNjb25uZWN0ZWQgYW5kIGNsZWFuZWQgdXAuICBfY2xlYW51cFNldCBob2xkc1xuICAgICAgICAvLyAgICBub3RlcyBmb3Igd2hpY2ggd2UgYXJlIGF3YWl0aW5nIGNsZWFudXAuXG4gICAgICAgIF9kb1BvbGwoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2xsVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbm93ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJpbnRlcnJ1cHRlZFwiKSAmJiB3aW5kb3dbXCJpbnRlcnJ1cHRlZFwiXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lsZW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBzaG9ydGVzdCB0aW1lIHdlIGNhbiBkZWxheSBpcyAxIC8gMTAwMCBzZWNzLCBzbyBpZiBhbiBldmVudFxuICAgICAgICAgICAgLy8gaXMgd2l0aGluIHRoZSBuZXh0IDAuNSBtcywgbm93IGlzIHRoZSBjbG9zZXN0IG1vbWVudCwgYW5kIHdlIGdvXG4gICAgICAgICAgICAvLyBhaGVhZCBhbmQgcHJvY2VzcyBpdC5cbiAgICAgICAgICAgIHZhciBpbnN0YW50ID0gdGhpcy5fYXRvcC5hYy5jdXJyZW50VGltZSArIDEgLyAyMDAwLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IFtdLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgd29yayxcbiAgICAgICAgICAgICAgICB3aGVuLFxuICAgICAgICAgICAgICAgIGZyZXEsXG4gICAgICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgICAgIGNvbmZsaWN0LFxuICAgICAgICAgICAgICAgIHNhdmUsXG4gICAgICAgICAgICAgICAgY2I7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGJhdGNoIG9mIG5vdGVzXG4gICAgICAgICAgICBpZiAodGhpcy5fbWluUXVldWVUaW1lIC0gaW5zdGFudCA8PSBJbnN0cnVtZW50LmJ1ZmZlclNlY3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdW5zb3J0ZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS50aW1lICE9IGIudGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5kdXJhdGlvbiAhPSBiLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZHVyYXRpb24gLSBiLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZnJlcXVlbmN5IC0gYi5mcmVxdWVuY3k7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNvcnRlZFF1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9xdWV1ZS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcXVldWVbal0udGltZSAtIGluc3RhbnQgPiBJbnN0cnVtZW50LmJ1ZmZlclNlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrID0gdGhpcy5fcXVldWUuc3BsaWNlKDAsIGopO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgd29yay5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZVNvdW5kKHdvcmtbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21pblF1ZXVlVGltZSA9IHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgPyB0aGlzLl9xdWV1ZVswXS50aW1lIDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBub3RlcyBmcm9tIHRoZSBjbGVhbnVwIHNldC5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9jbGVhbnVwU2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fY2xlYW51cFNldFtqXTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmNsZWFudXB0aW1lIDwgaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmdhaW5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGV4cGxpY2l0IGRpc2Nvbm5lY3QgaXMgbmVlZGVkIG9yIGVsc2UgQ2hyb21lJ3MgV2ViQXVkaW9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0cyBnZXR0aW5nIG92ZXJsb2FkZWQgYWZ0ZXIgYSBjb3VwbGUgdGhvdXNhbmQgbm90ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmdhaW5Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwU2V0LnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaiAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGlmeSBhYm91dCBhbnkgbm90ZXMgZmluaXNoaW5nLlxuICAgICAgICAgICAgZm9yIChmcmVxIGluIHRoaXMuX2ZpbmlzaFNldCkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX2ZpbmlzaFNldFtmcmVxXTtcbiAgICAgICAgICAgICAgICB3aGVuID0gcmVjb3JkLnRpbWUgKyByZWNvcmQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHdoZW4gPD0gaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogW3doZW4sIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZjogdGhpcy5fdHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhOiBbXCJub3Rlb2ZmXCIsIHJlY29yZF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmNsZWFudXB0aW1lICE9IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwU2V0LnB1c2gocmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmluaXNoU2V0W2ZyZXFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgYW55IHNwZWNpZmljIG9uZS10aW1lIGNhbGxiYWNrcyB0aGF0IHdlcmUgcmVnaXN0ZXJlZC5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9jYWxsYmFja1NldC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNiID0gdGhpcy5fY2FsbGJhY2tTZXRbal07XG4gICAgICAgICAgICAgICAgd2hlbiA9IGNiLnRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHdoZW4gPD0gaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogW3doZW4sIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZjogY2IuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYTogW10sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja1NldC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RpZnkgYWJvdXQgYW55IG5vdGVzIHN0YXJ0aW5nLlxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuX3N0YXJ0U2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0U2V0W2pdLnRpbWUgPD0gaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzYXZlID0gcmVjb3JkID0gdGhpcy5fc3RhcnRTZXRbal07XG4gICAgICAgICAgICAgICAgICAgIGZyZXEgPSByZWNvcmQuZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgICAgICBjb25mbGljdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maW5pc2hTZXQuaGFzT3duUHJvcGVydHkoZnJlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub3RlIGF0IHRoZSBzYW1lIGZyZXF1ZW5jeSBwbGF5aW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiByZWxlYXNlIHRoZSBvbmUgdGhhdCBzdGFydHMgZmlyc3QsIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3QgPSB0aGlzLl9maW5pc2hTZXRbZnJlcV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3QudGltZSA8IHJlY29yZC50aW1lIHx8IChjb25mbGljdC50aW1lID09IHJlY29yZC50aW1lICYmIGNvbmZsaWN0LmR1cmF0aW9uIDwgcmVjb3JkLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91ciBuZXcgc291bmQgY29uZmxpY3RzIHdpdGggYW4gb2xkIG9uZTogZW5kIHRoZSBvbGQgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG5vdGlmeSBpbW1lZGlhdGVseSBvZiBpdHMgbm90ZW9mZiBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cnVuY2F0ZVNvdW5kKGNvbmZsaWN0LCByZWNvcmQudGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogW3JlY29yZC50aW1lLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjogdGhpcy5fdHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogW1wibm90ZW9mZlwiLCBjb25mbGljdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZpbmlzaFNldFtmcmVxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBjb25mbGljdCBmcm9tIHRoZSBmdXR1cmUgaGFzIGFscmVhZHkgc2NoZWR1bGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIG91ciBvd24gbm90ZSBzaG91bGRuJ3Qgc291bmQuICBUcnVuY2F0ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgYW5kIHN1cHByZXNzIG91ciBvd24gbm90ZW9uIGFuZCBub3Rlb2ZmLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RydW5jYXRlU291bmQocmVjb3JkLCBjb25mbGljdC50aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFNldC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5kdXJhdGlvbiA+IDAgJiYgcmVjb3JkLnZlbG9jaXR5ID4gMCAmJiBjb25mbGljdCAhPT0gcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hTZXRbZnJlcV0gPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IFtyZWNvcmQudGltZSwgMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZjogdGhpcy5fdHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IFtcIm5vdGVvblwiLCByZWNvcmRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgbmV4dCBfZG9Qb2xsLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRQb2xsVGltZXIoKTtcblxuICAgICAgICAgICAgLy8gU29ydCBjYWxsYmFja3MgYWNjb3JkaW5nIHRvIHRoZSBcIm9yZGVyXCIgdHVwbGUsIHNvIGVhcmxpZXIgZXZlbnRzXG4gICAgICAgICAgICAvLyBhcmUgbm90aWZpZWQgZmlyc3QuXG4gICAgICAgICAgICBjYWxsYmFja3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhLm9yZGVyWzBdICE9IGIub3JkZXJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEub3JkZXJbMF0gLSBiLm9yZGVyWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aWVicmVhayBieSBub3RpZnlpbmcgJ25vdGVvZmYnIGZpcnN0IGFuZCAnbm90ZW9uJyBsYXN0LlxuICAgICAgICAgICAgICAgIHJldHVybiBhLm9yZGVyWzFdIC0gYi5vcmRlclsxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXQgdGhlIGVuZCwgY2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRob3V0IGRlcGVuZGluZyBvbiBcInRoaXNcIiBzdGF0ZS5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYiA9IGNhbGxiYWNrc1tqXTtcbiAgICAgICAgICAgICAgICBjYi5mLmFwcGx5KGNiLnQsIGNiLmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNjaGVkdWxlcyB0aGUgbmV4dCBfZG9Qb2xsIGNhbGwgYnkgZXhhbWluaW5nIHRpbWVzIGluIHRoZSB2YXJpb3VzXG4gICAgICAgIC8vIHNldHMgYW5kIGRldGVybWluaW5nIHRoZSBzb29uZXN0IGV2ZW50IHRoYXQgbmVlZHMgX2RvUG9sbCBwcm9jZXNzaW5nLlxuICAgICAgICBfc3RhcnRQb2xsVGltZXIoc2V0bm93OiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYWxyZWFkeSBkb25lIGEgXCJzZXRub3dcIiwgdGhlbiBwb2xsVGltZXIgaXMgemVyby10aW1lb3V0XG4gICAgICAgICAgICAvLyBhbmQgY2Fubm90IGJlIGZhc3Rlci5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2xsVGltZXIgJiYgdGhpcy5fbm93ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9Qb2xsKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlYXJsaWVzdCA9IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgZGVsYXk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9sbFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgYW55IG9sZCB0aW1lclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wb2xsVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGxUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0bm93KSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY2hlZHVsaW5nIHRvbmVzLCBjYWNoZSBfbm93IGFuZCBrZWVwIGEgemVyby10aW1lb3V0IHBvbGwuXG4gICAgICAgICAgICAgICAgLy8gX25vdyB3aWxsIGJlIGNsZWFyZWQgdGhlIG5leHQgdGltZSB3ZSBleGVjdXRlIF9kb1BvbGwuXG4gICAgICAgICAgICAgICAgdGhpcy5fbm93ID0gVXRpbHMuYXVkaW9DdXJyZW50U3RhcnRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbFRpbWVyID0gc2V0VGltZW91dChwb2xsLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lciBkdWUgdG8gbm90ZXMgc3RhcnRpbmc6IHdha2UgdXAgZm9yICdub3Rlb24nIG5vdGlmaWNhdGlvbi5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9zdGFydFNldC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGVhcmxpZXN0ID0gTWF0aC5taW4oZWFybGllc3QsIHRoaXMuX3N0YXJ0U2V0W2pdLnRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGltZXIgZHVlIHRvIG5vdGVzIGZpbmlzaGluZzogd2FrZSB1cCBmb3IgJ25vdGVvZmYnIG5vdGlmaWNhdGlvbi5cbiAgICAgICAgICAgIGZvciAoaiBpbiB0aGlzLl9maW5pc2hTZXQpIHtcbiAgICAgICAgICAgICAgICBlYXJsaWVzdCA9IE1hdGgubWluKGVhcmxpZXN0LCB0aGlzLl9maW5pc2hTZXRbal0udGltZSArIHRoaXMuX2ZpbmlzaFNldFtqXS5kdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lciBkdWUgdG8gc2NoZWR1bGVkIGNhbGxiYWNrLlxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuX2NhbGxiYWNrU2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgZWFybGllc3QgPSBNYXRoLm1pbihlYXJsaWVzdCwgdGhpcy5fY2FsbGJhY2tTZXRbal0udGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lciBkdWUgdG8gY2xlYW51cDogYWRkIGEgc2Vjb25kIHRvIGdpdmUgc29tZSB0aW1lIHRvIGJhdGNoIHVwLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2NsZWFudXBTZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVhcmxpZXN0ID0gTWF0aC5taW4oZWFybGllc3QsIHRoaXMuX2NsZWFudXBTZXRbMF0uY2xlYW51cHRpbWUgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRpbWVyIGR1ZSB0byBzZXF1ZW5jZXIgZXZlbnRzOiBzdWJ0cmFjdCBhIGxpdHRsZSB0aW1lIHRvIHN0YXkgYWhlYWQuXG4gICAgICAgICAgICBlYXJsaWVzdCA9IE1hdGgubWluKGVhcmxpZXN0LCB0aGlzLl9taW5RdWV1ZVRpbWUgLSBJbnN0cnVtZW50LmRlcXVldWVUaW1lKTtcblxuICAgICAgICAgICAgZGVsYXkgPSBNYXRoLm1heCgwLjAwMSwgZWFybGllc3QgLSB0aGlzLl9hdG9wLmFjLmN1cnJlbnRUaW1lKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGZ1dHVyZSBldmVudHMsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSB0aW1lci5cbiAgICAgICAgICAgIGlmIChpc05hTihkZWxheSkgfHwgZGVsYXkgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgSmF2YXNjcmlwdCB0aW1lciB0byB3YWtlIHVwIGF0IHRoZSByaWdodCBtb21lbnQuXG4gICAgICAgICAgICB0aGlzLl9wb2xsVGltZXIgPSBzZXRUaW1lb3V0KHBvbGwsIE1hdGgucm91bmQoZGVsYXkgKiAxMDAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbG93LWxldmVsIHRvbmUgZnVuY3Rpb24uXG4gICAgICAgIHRvbmUocGl0Y2gsIGR1cmF0aW9uLCB2ZWxvY2l0eSwgZGVsYXksIHRpbWJyZSwgb3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBJZiBhdWRpbyBpcyBub3QgcHJlc2VudCwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsZWQgd2l0aCBhbiBvYmplY3QgaW5zdGVhZCBvZiBsaXN0ZWQgYXJncy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGl0Y2ggPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmICh2ZWxvY2l0eSA9PSBudWxsKSB2ZWxvY2l0eSA9IHBpdGNoLnZlbG9jaXR5O1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSBkdXJhdGlvbiA9IHBpdGNoLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChkZWxheSA9PSBudWxsKSBkZWxheSA9IHBpdGNoLmRlbGF5O1xuICAgICAgICAgICAgICAgIGlmICh0aW1icmUgPT0gbnVsbCkgdGltYnJlID0gcGl0Y2gudGltYnJlO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gbnVsbCkgb3JpZ2luID0gcGl0Y2gub3JpZ2luO1xuICAgICAgICAgICAgICAgIHBpdGNoID0gcGl0Y2gucGl0Y2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgcGl0Y2ggZnJvbSB2YXJpb3VzIGZvcm1hdHMgdG8gSHogZnJlcXVlbmN5IGFuZCBhIG1pZGkgbnVtLlxuICAgICAgICAgICAgdmFyIG1pZGksIGZyZXF1ZW5jeTtcbiAgICAgICAgICAgIGlmICghcGl0Y2gpIHtcbiAgICAgICAgICAgICAgICBwaXRjaCA9IFwiQ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKHBpdGNoKSkge1xuICAgICAgICAgICAgICAgIG1pZGkgPSBVdGlscy5waXRjaFRvTWlkaShwaXRjaCk7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5ID0gVXRpbHMubWlkaVRvRnJlcXVlbmN5KG1pZGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3kgPSBOdW1iZXIocGl0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChmcmVxdWVuY3kgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pZGkgPSAtZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3kgPSBVdGlscy5taWRpVG9GcmVxdWVuY3kobWlkaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWlkaSA9IFV0aWxzLmZyZXF1ZW5jeVRvTWlkaShmcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aW1icmUpIHtcbiAgICAgICAgICAgICAgICB0aW1icmUgPSB0aGlzLl90aW1icmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGN1c3RvbSB0aW1icmUsIHZhbGlkYXRlIGFuZCBjb3B5IGl0LlxuICAgICAgICAgICAgaWYgKHRpbWJyZSAhPT0gdGhpcy5fdGltYnJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdpdmVuID0gdGltYnJlLFxuICAgICAgICAgICAgICAgICAgICBrZXk7XG4gICAgICAgICAgICAgICAgdGltYnJlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gVXRpbHMuZGVmYXVsdFRpbWJyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGdpdmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1icmVba2V5XSA9IGdpdmVuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1icmVba2V5XSA9IFV0aWxzLmRlZmF1bHRUaW1icmVba2V5XTsgLy8gUk9OWUVIOiBUaGVyZSB3YXMgYSB0eXBvIGJ1ZyBpbiB0aGUgb3JpZ2luYWwgTXVzaWNhbC5qcy4gSXQgd2FzIGNhdWdodCBieSBvdXIgVHlwZVNjcmlwdCBjb21waWxlci5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSByZWNvcmQgZm9yIGEgdG9uZS5cbiAgICAgICAgICAgIHZhciBhYyA9IHRoaXMuX2F0b3AuYWMsXG4gICAgICAgICAgICAgICAgbm93ID0gdGhpcy5ub3coKSxcbiAgICAgICAgICAgICAgICB0aW1lID0gbm93ICsgKGRlbGF5IHx8IDApLFxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IGZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgbWlkaTogbWlkaSxcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHk6IHZlbG9jaXR5ID09IG51bGwgPyAxIDogdmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiA9PSBudWxsID8gSW5zdHJ1bWVudC50b25lTGVuZ3RoIDogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRpbWJyZTogdGltYnJlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBnYWluTm9kZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3NjaWxsYXRvcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXB0aW1lOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sIC8vIHNhdmUgdGhlIG9yaWdpbiBvZiB0aGUgdG9uZSBmb3IgdmlzaWJsZSBmZWVkYmFja1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aW1lIDwgbm93ICsgSW5zdHJ1bWVudC5idWZmZXJTZWNzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRvbmUgc3RhcnRzIHNvb24hICBHaXZlIGl0IGRpcmVjdGx5IHRvIFdlYkF1ZGlvLlxuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTb3VuZChyZWNvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdG9uZSBpcyBsYXRlcjogcXVldWUgaXQuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl91bnNvcnRlZFF1ZXVlICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCAmJiB0aW1lIDwgdGhpcy5fcXVldWVbdGhpcy5fcXVldWUubGVuZ3RoIC0gMV0udGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNvcnRlZFF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pblF1ZXVlVGltZSA9IE1hdGgubWluKHRoaXMuX21pblF1ZXVlVGltZSwgcmVjb3JkLnRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsb3ctbGV2ZWwgY2FsbGJhY2sgc2NoZWR1bGluZyBtZXRob2QuXG4gICAgICAgIHNjaGVkdWxlKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tTZXQucHVzaCh7IHRpbWU6IHRoaXMubm93KCkgKyBkZWxheSwgY2FsbGJhY2s6IGNhbGxiYWNrIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBoaWdoLWxldmVsIHNlcXVlbmNpbmcgbWV0aG9kLlxuICAgICAgICBwbGF5KGFiY3N0cmluZykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBudWxsLFxuICAgICAgICAgICAgICAgIG9wdHMgPSB7fSxcbiAgICAgICAgICAgICAgICBzdWJmaWxlLFxuICAgICAgICAgICAgICAgIGFiY2ZpbGUsXG4gICAgICAgICAgICAgICAgYXJnaW5kZXgsXG4gICAgICAgICAgICAgICAgdGVtcG8sXG4gICAgICAgICAgICAgICAgdGltYnJlLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICAgICAgbWF4ZGVsYXkgPSAwLFxuICAgICAgICAgICAgICAgIGF0dGVudWF0ZSxcbiAgICAgICAgICAgICAgICB2b2ljZW5hbWUsXG4gICAgICAgICAgICAgICAgc3RlbXMsXG4gICAgICAgICAgICAgICAgbmksXG4gICAgICAgICAgICAgICAgdm4sXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBzdGVtLFxuICAgICAgICAgICAgICAgIG5vdGUsXG4gICAgICAgICAgICAgICAgYmVhdHNlY3MsXG4gICAgICAgICAgICAgICAgc2VjcyxcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIGZpbGVzID0gW107XG4gICAgICAgICAgICAvLyBMb29rIGZvciBjb250aW51YXRpb24gYXMgbGFzdCBhcmd1bWVudC5cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb29rIGZvciBvcHRpb25zIGFzIGZpcnN0IG9iamVjdC5cbiAgICAgICAgICAgIGFyZ2luZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBvd24gcHJvcGVydGllcyBpbnRvIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGZvciAoayBpbiBhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1swXS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1trXSA9IGFyZ3NbMF1ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdpbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBzb25nIGlzIHN1cHBsaWVkIGJ5IG9wdGlvbnMgb2JqZWN0LCBwcm9jZXNzIGl0LlxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KFwic29uZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0c1tcInNvbmdcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIGFueSBudW1iZXIgb2YgQUJDIGZpbGVzIGFzIGlucHV0LlxuICAgICAgICAgICAgZm9yICg7IGFyZ2luZGV4IDwgYXJncy5sZW5ndGg7ICsrYXJnaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3BsaXR0aW5nIG9mIEFCQyBzdWJmaWxlcyBhdCBYOiBsaW5lcy5cbiAgICAgICAgICAgICAgICBzdWJmaWxlID0gYXJnc1thcmdpbmRleF0uc3BsaXQoL1xcbig/PVg6KS8pO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBzdWJmaWxlLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiY2ZpbGUgPSBwYXJzZUFCQ0ZpbGUoc3ViZmlsZVtrXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWJjZmlsZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRha2UgdGVtcG8gbWFya2luZ3MgZnJvbSB0aGUgZmlyc3QgZmlsZSwgYW5kIHNoYXJlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0cy5oYXNPd25Qcm9wZXJ0eShcInRlbXBvXCIpICYmIGFiY2ZpbGUudGVtcG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbXCJ0ZW1wb1wiXSA9IGFiY2ZpbGUudGVtcG87XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJjZmlsZS51bml0YmVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbXCJ0ZW1wb1wiXSA9IChvcHRzW1widGVtcG9cIl0gKiBhYmNmaWxlLnVuaXRiZWF0KSAvIChhYmNmaWxlLnVuaXRub3RlIHx8IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBmaWxlcyB3aXRob3V0IHNvbmdzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFiY2ZpbGUudm9pY2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGFiY2ZpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdGVtcG8gdG8gMTIwIGlmIG5vdGhpbmcgZWxzZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICBpZiAoIW9wdHMuaGFzT3duUHJvcGVydHkoXCJ0ZW1wb1wiKSkge1xuICAgICAgICAgICAgICAgIG9wdHNbXCJ0ZW1wb1wiXSA9IDEyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdm9sdW1lIHRvIDEgaWYgbm90aGluZyBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICBpZiAoIW9wdHMuaGFzT3duUHJvcGVydHkoXCJ2b2x1bWVcIikpIHtcbiAgICAgICAgICAgICAgICBvcHRzW1widm9sdW1lXCJdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlYXRzZWNzID0gNjAuMCAvIG9wdHNbXCJ0ZW1wb1wiXTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFsbCBub3RlcyBmcm9tIGFsbCB0aGUgZmlsZXMuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZmlsZXMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICBhYmNmaWxlID0gZmlsZXNba107XG4gICAgICAgICAgICAgICAgLy8gRWFjaCBmaWxlIGNhbiBoYXZlIG11bHRpcGxlIHZvaWNlcyAoZS5nLiwgbGVmdCBhbmQgcmlnaHQgaGFuZHMpXG4gICAgICAgICAgICAgICAgZm9yICh2biBpbiBhYmNmaWxlLnZvaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggdm9pY2UgY291bGQgaGF2ZSBhIHNlcGFyYXRlIHRpbWJyZS5cbiAgICAgICAgICAgICAgICAgICAgdGltYnJlID0gVXRpbHMubWFrZVRpbWJyZShvcHRzW1widGltYnJlXCJdIHx8IGFiY2ZpbGUudm9pY2Vbdm5dLnRpbWJyZSB8fCBhYmNmaWxlLnRpbWJyZSB8fCB0aGlzLl90aW1icmUsIHRoaXMuX2F0b3ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHZvaWNlIGhhcyBhIHNlcmllcyBvZiBzdGVtcyAobm90ZXMgb3IgY2hvcmRzKS5cbiAgICAgICAgICAgICAgICAgICAgc3RlbXMgPSBhYmNmaWxlLnZvaWNlW3ZuXS5zdGVtcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGVtcykgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGF0IGRlbGF5IHplcm8gKG5vdyksIHNjaGVkdWxlIGFsbCB0b25lcy5cbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5pID0gMDsgbmkgPCBzdGVtcy5sZW5ndGg7ICsrbmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW0gPSBzdGVtc1tuaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbnVhdGUgY2hvcmRzIHRvIHJlZHVjZSBjbGlwcGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVudWF0ZSA9IDEgLyBNYXRoLnNxcnQoc3RlbS5ub3Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgZXZlcnkgbm90ZSBpbnNpZGUgYSBzdGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0ZW0ubm90ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RlID0gc3RlbS5ub3Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90ZS5ob2xkb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGhvbGRvdmVyIG5vdGVzIGZyb20gdGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3MgPSAobm90ZS50aW1lIHx8IHN0ZW0udGltZSkgKiBiZWF0c2VjcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RlbS5zdGFjY2F0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGVuIHN0YWNjYXRvIG5vdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNzID0gTWF0aC5taW4oTWF0aC5taW4oc2VjcywgYmVhdHNlY3MgLyAxNiksIHRpbWJyZS5hdHRhY2sgKyB0aW1icmUuZGVjYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5vdGUuc2x1cnJlZCAmJiBzZWNzID49IDEgLyA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRlIHVuc2x1cnJlZCBub3RlcyBieSBhYm91dCBhIDMwdGggb2YgYSBzZWNvbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3MgLT0gMSAvIDMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gKG5vdGUudmVsb2NpdHkgfHwgMSkgKiBhdHRlbnVhdGUgKiBvcHRzW1widm9sdW1lXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgaW5uc2VybW9zdCBwYXJ0IG9mIHRoZSBpbm5lciBsb29wIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9uZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxheSB0aGUgdG9uZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZS5waXRjaCwgLy8gYXQgdGhlIGdpdmVuIHBpdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3MsIC8vIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiwgLy8gd2l0aCB0aGUgZ2l2ZW4gdm9sdW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5LCAvLyBzdGFydGluZyBhdCB0aGUgcHJvcGVyIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltYnJlLCAvLyB3aXRoIHRoZSBzZWxlY3RlZCB0aW1icmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZSAvLyB0aGUgb3JpZ2luIG9iamVjdCBmb3IgdmlzdWFsIGZlZWRiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ICs9IHN0ZW0udGltZSAqIGJlYXRzZWNzOyAvLyBBZHZhbmNlIHRoZSBzZXF1ZW5jZWQgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXhkZWxheSA9IE1hdGgubWF4KGRlbGF5LCBtYXhkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF4U2NoZWR1bGVkVGltZSA9IE1hdGgubWF4KHRoaXMuX21heFNjaGVkdWxlZFRpbWUsIHRoaXMubm93KCkgKyBtYXhkZWxheSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgXCJkb25lXCIgY2FsbGJhY2sgYWZ0ZXIgYWxsIHNlcXVlbmNpbmcgaXMgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZShtYXhkZWxheSwgZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEVORCBJTlNUUlVNRU5UXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBNdXNpY2FsIEpTXG5cbnR5cGUgX0luc3RydW1lbnQgPSBJbnN0cnVtZW50O1xuY29uc3QgX3BhcnNlQUJDRmlsZSA9IHBhcnNlQUJDRmlsZTtcblxubmFtZXNwYWNlIE11c2ljYWwge1xuICAgIGV4cG9ydCB0eXBlIEluc3RydW1lbnQgPSBfSW5zdHJ1bWVudDtcbiAgICBleHBvcnQgY29uc3QgcGFyc2VBQkNGaWxlID0gX3BhcnNlQUJDRmlsZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgTXVzaWNhbDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./apps/shared/sound/Musical.ts\n");

/***/ })

})