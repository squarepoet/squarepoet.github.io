webpackHotUpdate_N_E("pages/piano/v2",{

/***/ "./apps/shared/sound/Musical.ts":
/*!**************************************!*\
  !*** ./apps/shared/sound/Musical.ts ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global, module) {/* harmony import */ var _Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////\n// musical.js\n// https://github.com/PencilCode/musical.js\nvar Musical;\n\n(function (_Musical) {\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // WAVETABLE-BUILDER\n  // wavetable is a table of names for nonstandard waveforms.\n  // The table maps names to objects that have wave: and freq:\n  // properties. The wave: property is a PeriodicWave to use\n  // for the oscillator.  The freq: property, if present,\n  // is a map from higher frequencies to more PeriodicWave\n  // objects; when a frequency higher than the given threshold\n  // is requested, the alternate PeriodicWave is used.\n  var makeWavetable = function makeWavetable(ac) {\n    return function (wavedata) {\n      function makePeriodicWave(data) {\n        var n = data.real.length,\n            real = new Float32Array(n),\n            imag = new Float32Array(n),\n            j;\n\n        for (j = 0; j < n; ++j) {\n          real[j] = data.real[j];\n          imag[j] = data.imag[j];\n        }\n\n        try {\n          // Latest API naming.\n          return ac.createPeriodicWave(real, imag);\n        } catch (e) {}\n\n        try {\n          // Earlier API naming.\n          return ac.createWaveTable(real, imag);\n        } catch (e) {}\n\n        return null;\n      }\n\n      function makeMultiple(data, mult, amt) {\n        var result = {\n          real: [],\n          imag: []\n        },\n            j,\n            n = data.real.length,\n            m;\n\n        for (j = 0; j < n; ++j) {\n          m = Math.log(mult[Math.min(j, mult.length - 1)]);\n          result.real.push(data.real[j] * Math.exp(amt * m));\n          result.imag.push(data.imag[j] * Math.exp(amt * m));\n        }\n\n        return result;\n      }\n\n      var result = {},\n          k,\n          d,\n          n,\n          j,\n          ff,\n          record,\n          wave,\n          pw;\n\n      for (k in wavedata) {\n        d = wavedata[k];\n        wave = makePeriodicWave(d);\n\n        if (!wave) {\n          continue;\n        }\n\n        record = {\n          wave: wave\n        }; // A strategy for computing higher frequency waveforms: apply\n        // multipliers to each harmonic according to d.mult.  These\n        // multipliers can be interpolated and applied at any number\n        // of transition frequencies.\n\n        if (d.mult) {\n          ff = wavedata[k].freq;\n          record.freq = {};\n\n          for (j = 0; j < ff.length; ++j) {\n            wave = makePeriodicWave(makeMultiple(d, d.mult, (j + 1) / ff.length));\n\n            if (wave) {\n              record.freq[ff[j]] = wave;\n            }\n          }\n        } // This wave has some default filter settings.\n\n\n        if (d.defs) {\n          record.defs = d.defs;\n        }\n\n        result[k] = record;\n      }\n\n      return result;\n    }({\n      // Currently the only nonstandard waveform is \"piano\".\n      // It is based on the first 32 harmonics from the example:\n      // https://github.com/GoogleChrome/web-audio-samples\n      // /blob/gh-pages/samples/audio/wave-tables/Piano\n      // That is a terrific sound for the lowest piano tones.\n      // For higher tones, interpolate to a customzed wave\n      // shape created by hand, and apply a lowpass filter.\n      piano: {\n        real: [0, 0, -0.203569, 0.5, -0.401676, 0.137128, -0.104117, 0.115965, -0.004413, 0.067884, -0.00888, 0.0793, -0.038756, 0.011882, -0.030883, 0.027608, -0.013429, 0.00393, -0.014029, 0.00972, -0.007653, 0.007866, -0.032029, 0.046127, -0.024155, 0.023095, -0.005522, 0.004511, -0.003593, 0.011248, -0.004919, 0.008505],\n        imag: [0, 0.147621, 0, 0.000007, -0.00001, 0.000005, -0.000006, 0.000009, 0, 0.000008, -0.000001, 0.000014, -0.000008, 0.000003, -0.000009, 0.000009, -0.000005, 0.000002, -0.000007, 0.000005, -0.000005, 0.000005, -0.000023, 0.000037, -0.000021, 0.000022, -0.000006, 0.000005, -0.000004, 0.000014, -0.000007, 0.000012],\n        // How to adjust the harmonics for the higest notes.\n        mult: [1, 1, 0.18, 0.016, 0.01, 0.01, 0.01, 0.004, 0.014, 0.02, 0.014, 0.004, 0.002, 0.00001],\n        // The frequencies at which to interpolate the harmonics.\n        freq: [65, 80, 100, 135, 180, 240, 620, 1360],\n        // The default filter settings to use for the piano wave.\n        // TODO: this approach attenuates low notes too much -\n        // this should be fixed.\n        defs: {\n          wave: \"piano\",\n          gain: 0.5,\n          attack: 0.002,\n          decay: 0.25,\n          sustain: 0.03,\n          release: 0.1,\n          decayfollow: 0.7,\n          cutoff: 800,\n          cutfollow: 0.1,\n          resonance: 1,\n          detune: 0.9994\n        }\n      }\n    });\n  }; // END WAVETABLE-BUILDER\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // UTILS\n\n\n  var Utils = /*#__PURE__*/function () {\n    function Utils() {\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Utils);\n    }\n\n    Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Utils, null, [{\n      key: \"isAudioPresent\",\n      // Tests for the presence of HTML5 Web Audio (or webkit's version).\n      value: function isAudioPresent() {\n        return !!(global.AudioContext || global.webkitAudioContext);\n      } // All our audio funnels through the same AudioContext with a\n      // DynamicsCompressorNode used as the main output, to compress the\n      // dynamic range of all audio.  getAudioTop sets this up.\n\n    }, {\n      key: \"getAudioTop\",\n      value: function getAudioTop() {\n        if (Utils._audioTop) {\n          return Utils._audioTop;\n        }\n\n        if (!Utils.isAudioPresent()) {\n          return null;\n        }\n\n        var ac = new (global.AudioContext || global.webkitAudioContext)();\n        Utils._audioTop = {\n          ac: ac,\n          wavetable: makeWavetable(ac),\n          out: null,\n          currentStart: null\n        };\n        Utils.resetAudio();\n        return Utils._audioTop;\n      } // When audio needs to be interrupted globally (e.g., when you press the\n      // stop button in the IDE), resetAudio does the job.\n\n    }, {\n      key: \"resetAudio\",\n      value: function resetAudio() {\n        if (Utils._audioTop) {\n          var atop = Utils._audioTop; // Disconnect the top-level node and make a new one.\n\n          if (atop.out) {\n            atop.out.disconnect();\n            atop.out = null;\n            atop.currentStart = null;\n          }\n\n          var dcn = atop.ac.createDynamicsCompressor();\n          dcn.ratio.setValueAtTime(16, 0);\n          dcn.attack.setValueAtTime(0.0005, 0); // dcn.ratio = 16; // RONYEH: .ratio is a READ ONLY property.\n          // dcn.attack = 0.0005; // RONYEH: .ratio is a READ ONLY property.\n\n          dcn.connect(atop.ac.destination);\n          atop.out = dcn;\n        }\n      } // For precise scheduling of future notes, the AudioContext currentTime is\n      // cached and is held constant until the script releases to the event loop.\n\n    }, {\n      key: \"audioCurrentStartTime\",\n      value: function audioCurrentStartTime() {\n        var atop = Utils.getAudioTop();\n\n        if (atop.currentStart != null) {\n          return atop.currentStart;\n        } // A delay could be added below to introduce a universal delay in\n        // all beginning sounds (without skewing durations for scheduled\n        // sequences).\n\n\n        atop.currentStart = Math.max(0.25, atop.ac.currentTime\n        /* + 0.0 delay */\n        );\n        setTimeout(function () {\n          atop.currentStart = null;\n        }, 0);\n        return atop.currentStart;\n      } // Converts a midi note number to a frequency in Hz.\n\n    }, {\n      key: \"midiToFrequency\",\n      value: function midiToFrequency(midi) {\n        return 440 * Math.pow(2, (midi - 69) / 12);\n      } // Some constants.\n\n    }, {\n      key: \"frequencyToMidi\",\n      // Converts a frequency in Hz to the closest midi number.\n      value: function frequencyToMidi(freq) {\n        return Math.round(69 + Math.log(freq / 440) * 12 / Math.LN2);\n      } // Converts an ABC pitch (such as \"^G,,\") to a midi note number.\n\n    }, {\n      key: \"pitchToMidi\",\n      value: function pitchToMidi(pitch) {\n        var m = /^(\\^+|_+|=|)([A-Ga-g])([,']*)$/.exec(pitch);\n\n        if (!m) {\n          return null;\n        }\n\n        var octave = m[3].replace(/,/g, \"\").length - m[3].replace(/'/g, \"\").length;\n        var semitone = Utils.noteNum[m[2]] + Utils.accSym[m[1].charAt(0)] * m[1].length + 12 * octave;\n        return semitone + 60; // 60 = midi code middle \"C\".\n      } // Converts a midi number to an ABC notation pitch.\n\n    }, {\n      key: \"midiToPitch\",\n      value: function midiToPitch(midi) {\n        var index = (midi - 72) % 12;\n\n        if (midi > 60 || index != 0) {\n          index += 12;\n        }\n\n        var octaves = Math.round((midi - index - 60) / 12),\n            result = Utils.noteName[index];\n\n        while (octaves != 0) {\n          result += octaves > 0 ? \"'\" : \",\";\n          octaves += octaves > 0 ? -1 : 1;\n        }\n\n        return result;\n      } // Converts an ABC pitch to a frequency in Hz.\n\n    }, {\n      key: \"pitchToFrequency\",\n      value: function pitchToFrequency(pitch) {\n        return Utils.midiToFrequency(Utils.pitchToMidi(pitch));\n      } // The default sound is a square wave with a pretty quick decay to zero.\n\n    }, {\n      key: \"makeTimbre\",\n      // Norrmalizes a timbre object by making a copy that has exactly\n      // the right set of timbre fields, defaulting when needed.\n      // A timbre can specify any of the fields of defaultTimbre; any\n      // unspecified fields are treated as they are set in defaultTimbre.\n      value: function makeTimbre(options, atop) {\n        if (!options) {\n          options = {};\n        }\n\n        if (typeof options == \"string\") {\n          // Abbreviation: name a wave to get a default timbre for that wave.\n          options = {\n            wave: options\n          };\n        }\n\n        var result = {},\n            key,\n            wt = atop && atop.wavetable && atop.wavetable[options.wave];\n\n        for (key in Utils.defaultTimbre) {\n          if (options.hasOwnProperty(key)) {\n            result[key] = options[key];\n          } else if (wt && wt.defs && wt.defs.hasOwnProperty(key)) {\n            result[key] = wt.defs[key];\n          } else {\n            result[key] = Utils.defaultTimbre[key];\n          }\n        }\n\n        return result;\n      }\n    }, {\n      key: \"getWhiteNoiseBuf\",\n      // cache\n      value: function getWhiteNoiseBuf() {\n        if (whiteNoiseBuf == null) {\n          var ac = Utils.getAudioTop().ac,\n              bufferSize = 2 * ac.sampleRate,\n              whiteNoiseBuf = ac.createBuffer(1, bufferSize, ac.sampleRate),\n              output = whiteNoiseBuf.getChannelData(0);\n\n          for (var i = 0; i < bufferSize; i++) {\n            output[i] = Math.random() * 2 - 1;\n          }\n        }\n\n        return whiteNoiseBuf;\n      } // This utility function creates an oscillator at the given frequency\n      // and the given wavename.  It supports lookups in a static wavetable,\n      // defined right below.\n\n    }, {\n      key: \"makeOscillator\",\n      value: function makeOscillator(atop, wavename, freq) {\n        if (wavename == \"noise\") {\n          var whiteNoise = atop.ac.createBufferSource();\n          whiteNoise.buffer = Utils.getWhiteNoiseBuf();\n          whiteNoise.loop = true;\n          return whiteNoise;\n        }\n\n        var wavetable = atop.wavetable,\n            o = atop.ac.createOscillator(),\n            k,\n            pwave,\n            bwf,\n            wf;\n\n        try {\n          if (wavetable.hasOwnProperty(wavename)) {\n            // Use a customized wavetable.\n            pwave = wavetable[wavename].wave;\n\n            if (wavetable[wavename].freq) {\n              bwf = 0; // Look for a higher-frequency variant.\n\n              for (k in wavetable[wavename].freq) {\n                wf = Number(k);\n\n                if (freq > wf && wf > bwf) {\n                  bwf = wf;\n                  pwave = wavetable[wavename].freq[bwf];\n                }\n              }\n            }\n\n            if (!o.setPeriodicWave && o.setWaveTable) {\n              // The old API name: Safari 7 still uses this.\n              o.setWaveTable(pwave);\n            } else {\n              // The new API name.\n              o.setPeriodicWave(pwave);\n            }\n          } else {\n            o.type = wavename;\n          }\n        } catch (e) {\n          if (window.console) {\n            window.console.log(e);\n          } // If unrecognized, just use square.\n          // TODO: support \"noise\" or other wave shapes.\n\n\n          o.type = \"square\";\n        } // o.frequency.value = freq; // RONYEH REMOVED DUE TO SOME BUG.\n\n\n        o.frequency.setTargetAtTime(freq, atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n        return o;\n      }\n    }]);\n\n    return Utils;\n  }(); // END UTILS\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////////////////////////////////////////////////\n  // Parses an ABC file to an object with the following structure:\n  // {\n  //   X: value from the X: lines in header (\\n separated for multiple values)\n  //   V: value from the V:myname lines that appear before K:\n  //   (etc): for all the one-letter header-names.\n  //   K: value from the K: lines in header.\n  //   tempo: Q: line parsed as beatsecs\n  //   timbre: ... I:timbre line as parsed by makeTimbre\n  //   voice: {\n  //     myname: { // voice with id \"myname\"\n  //       V: value from the V:myname lines (from the body)\n  //       stems: [...] as parsed by parseABCstems\n  //    }\n  //  }\n  // }\n  // ABC files are idiosyncratic to parse: the written specifications\n  // do not necessarily reflect the defacto standard implemented by\n  // ABC content on the web.  This implementation is designed to be\n  // practical, working on content as it appears on the web, and only\n  // using the written standard as a guideline.\n\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"_audioTop\", null);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"noteNum\", {\n    C: 0,\n    D: 2,\n    E: 4,\n    F: 5,\n    G: 7,\n    A: 9,\n    B: 11,\n    c: 12,\n    d: 14,\n    e: 16,\n    f: 17,\n    g: 19,\n    a: 21,\n    b: 23\n  });\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"accSym\", {\n    \"^\": 1,\n    \"\": 0,\n    \"=\": 0,\n    _: -1\n  });\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"noteName\", [\"C\", \"^C\", \"D\", \"_E\", \"E\", \"F\", \"^F\", \"G\", \"_A\", \"A\", \"_B\", \"B\", \"c\", \"^c\", \"d\", \"_e\", \"e\", \"f\", \"^f\", \"g\", \"_a\", \"a\", \"_b\", \"b\"]);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"defaultTimbre\", {\n    wave: \"square\",\n    // Oscillator type.\n    gain: 0.1,\n    // Overall gain at maximum attack.\n    attack: 0.002,\n    // Attack time at the beginning of a tone.\n    decay: 0.4,\n    // Rate of exponential decay after attack.\n    decayfollow: 0,\n    // Amount of decay shortening for higher notes.\n    sustain: 0,\n    // Portion of gain to sustain indefinitely.\n    release: 0.1,\n    // Release time after a tone is done.\n    cutoff: 0,\n    // Low-pass filter cutoff frequency.\n    cutfollow: 0,\n    // Cutoff adjustment, a multiple of oscillator freq.\n    resonance: 0,\n    // Low-pass filter resonance.\n    detune: 0 // Detune factor for a second oscillator.\n\n  });\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Utils, \"whiteNoiseBuf\", null);\n\n  var ABCheader = /^([A-Za-z]):\\s*(.*)$/;\n  var ABCtoken = /(?:\\[[A-Za-z]:[^\\]]*\\])|\\s+|%[^\\n]*|![^\\s!:|\\[\\]]*!|\\+[^+|!]*\\+|[_<>@^]?\"[^\"]*\"|\\[|\\]|>+|<+|(?:(?:\\^+|_+|=|)[A-Ga-g](?:,+|'+|))|\\(\\d+(?::\\d+){0,2}|\\d*\\/\\d+|\\d+\\/?|\\/+|[xzXZ]|\\[?\\|\\]?|:?\\|:?|::|./g;\n\n  function parseABCFile(str) {\n    var lines = str.split(\"\\n\"),\n        result = {},\n        context = result,\n        timbre,\n        j,\n        k,\n        header,\n        stems,\n        key = {},\n        accent = {\n      slurred: 0\n    },\n        voiceid,\n        out; // ABC files are parsed one line at a time.\n\n    for (j = 0; j < lines.length; ++j) {\n      // First, check to see if the line is a header line.\n      header = ABCheader.exec(lines[j]);\n\n      if (header) {\n        handleInformation(header[1], header[2].trim());\n      } else if (/^\\s*(?:%.*)?$/.test(lines[j])) {\n        // Skip blank and comment lines.\n        continue;\n      } else {\n        // Parse the notes.\n        parseABCNotes(lines[j]);\n      }\n    }\n\n    var infer = [\"unitnote\", \"unitbeat\", \"tempo\"];\n\n    if (result.hasOwnProperty(\"voice\") && result.voice !== null) {\n      out = [];\n\n      for (j in result.voice) {\n        if (result.voice[j].stems && result.voice[j].stems.length) {\n          // Calculate times for all the tied notes.  This happens at the end\n          // because in principle, the first note of a song could be tied all\n          // the way through to the last note.\n          processTies(result.voice[j].stems); // Bring up inferred tempo values from voices if not specified\n          // in the header.\n\n          for (k = 0; k < infer.length; ++k) {\n            if (!(infer[k] in result) && infer[k] in result.voice[j]) {\n              result[infer[k]] = result.voice[j][infer[k]];\n            }\n          } // Remove this internal state variable;\n\n\n          delete result.voice[j].accent;\n        } else {\n          out.push(j);\n        }\n      } // Delete any voices that had no stems.\n\n\n      for (j = 0; j < out.length; ++j) {\n        delete result.voice[out[j]];\n      }\n    }\n\n    return result; ////////////////////////////////////////////////////////////////////////\n    // Parsing helper functions below.\n    ////////////////////////////////////////////////////////////////////////\n    // Processes header fields such as V: voice, which may appear at the\n    // top of the ABC file, or in the ABC body in a [V:voice] directive.\n\n    function handleInformation(field, value) {\n      // The following headers are recognized and processed.\n      switch (field) {\n        case \"V\":\n          // A V: header switches voices if in the body.\n          // If in the header, then it is just advisory.\n          if (context !== result) {\n            startVoiceContext(value.split(\" \")[0]);\n          }\n\n          break;\n\n        case \"M\":\n          parseMeter(value, context);\n          break;\n\n        case \"L\":\n          parseUnitNote(value, context);\n          break;\n\n        case \"Q\":\n          parseTempo(value, context);\n          break;\n      } // All headers (including unrecognized ones) are\n      // just accumulated as properties. Repeated header\n      // lines are accumulated as multiline properties.\n\n\n      if (context.hasOwnProperty(field)) {\n        context[field] += \"\\n\" + value;\n      } else {\n        context[field] = value;\n      } // The K header is special: it should be the last one\n      // before the voices and notes begin.\n\n\n      if (field == \"K\") {\n        key = keysig(value);\n\n        if (context === result) {\n          startVoiceContext(firstVoiceName());\n        }\n      }\n    } // Shifts context to a voice with the given id given.  If no id\n    // given, then just sticks with the current voice.  If the current\n    // voice is unnamed and empty, renames the current voice.\n\n\n    function startVoiceContext(id) {\n      id = id || \"\";\n\n      if (!id && context !== result) {\n        return;\n      }\n\n      if (!result.voice) {\n        result.voice = {};\n      }\n\n      if (result.voice.hasOwnProperty(id)) {\n        // Resume a named voice.\n        context = result.voice[id];\n        accent = context.accent;\n      } else {\n        // Start a new voice.\n        context = {\n          id: id,\n          accent: {\n            slurred: 0\n          }\n        };\n        result.voice[id] = context;\n        accent = context.accent;\n      }\n    } // For picking a default voice, looks for the first voice name.\n\n\n    function firstVoiceName() {\n      if (result.V) {\n        return result.V.split(/\\s+/)[0];\n      } else {\n        return \"\";\n      }\n    } // Parses a single line of ABC notes (i.e., not a header line).\n    //\n    // We process an ABC song stream by dividing it into tokens, each of\n    // which is a pitch, duration, or special decoration symbol; then\n    // we process each decoration individually, and we process each\n    // stem as a group using parseStem.\n    // The structure of a single ABC note is something like this:\n    //\n    // NOTE -> STACCATO? PITCH DURATION? TIE?\n    //\n    // I.e., it always has a pitch, and it is prefixed by some optional\n    // decorations such as a (.) staccato marking, and it is suffixed by\n    // an optional duration and an optional tie (-) marking.\n    //\n    // A stem is either a note or a bracketed series of notes, followed\n    // by duration and tie.\n    //\n    // STEM -> NOTE   OR    '[' NOTE * ']' DURAITON? TIE?\n    //\n    // Then a song is just a sequence of stems interleaved with other\n    // decorations such as dynamics markings and measure delimiters.\n\n\n    function parseABCNotes(str) {\n      var tokens = str.match(ABCtoken),\n          parsed = null,\n          index = 0,\n          dotted = 0,\n          beatlet = null,\n          t;\n\n      if (!tokens) {\n        return null;\n      }\n\n      while (index < tokens.length) {\n        // Ignore %comments and !markings!\n        if (/^[\\s%]/.test(tokens[index])) {\n          index++;\n          continue;\n        } // Handle inline [X:...] information fields\n\n\n        if (/^\\[[A-Za-z]:[^\\]]*\\]$/.test(tokens[index])) {\n          handleInformation(tokens[index].substring(1, 2), tokens[index].substring(3, tokens[index].length - 1).trim());\n          index++;\n          continue;\n        } // Handled dotted notation abbreviations.\n\n\n        if (/</.test(tokens[index])) {\n          dotted = -tokens[index++].length;\n          continue;\n        }\n\n        if (/>/.test(tokens[index])) {\n          dotted = tokens[index++].length;\n          continue;\n        }\n\n        if (/^\\(\\d+(?::\\d+)*/.test(tokens[index])) {\n          beatlet = parseBeatlet(tokens[index++]);\n          continue;\n        }\n\n        if (/^[!+].*[!+]$/.test(tokens[index])) {\n          parseDecoration(tokens[index++], accent);\n          continue;\n        }\n\n        if (/^.?\".*\"$/.test(tokens[index])) {\n          // Ignore double-quoted tokens (chords and general text annotations).\n          index++;\n          continue;\n        }\n\n        if (/^[()]$/.test(tokens[index])) {\n          if (tokens[index++] == \"(\") {\n            accent.slurred += 1;\n          } else {\n            accent.slurred -= 1;\n\n            if (accent.slurred <= 0) {\n              accent.slurred = 0;\n\n              if (context.stems && context.stems.length >= 1) {\n                // The last notes in a slur are not slurred.\n                slurStem(context.stems[context.stems.length - 1], false);\n              }\n            }\n          }\n\n          continue;\n        } // Handle measure markings by clearing accidentals.\n\n\n        if (/\\|/.test(tokens[index])) {\n          for (t in accent) {\n            if (t.length == 1) {\n              // Single-letter accent properties are note accidentals.\n              delete accent[t];\n            }\n          }\n\n          index++;\n          continue;\n        }\n\n        parsed = parseStem(tokens, index, key, accent); // Skip unparsable bits\n\n        if (parsed === null) {\n          index++;\n          continue;\n        } // Process a parsed stem.\n\n\n        if (beatlet) {\n          scaleStem(parsed.stem, beatlet.time);\n          beatlet.count -= 1;\n\n          if (!beatlet.count) {\n            beatlet = null;\n          }\n        } // If syncopated with > or < notation, shift part of a beat\n        // between this stem and the previous one.\n\n\n        if (dotted && context.stems && context.stems.length) {\n          if (dotted > 0) {\n            t = (1 - Math.pow(0.5, dotted)) * parsed.stem.time;\n          } else {\n            t = (Math.pow(0.5, -dotted) - 1) * context.stems[context.stems.length - 1].time;\n          }\n\n          syncopateStem(context.stems[context.stems.length - 1], t);\n          syncopateStem(parsed.stem, -t);\n        }\n\n        dotted = 0; // Slur all the notes contained within a strem.\n\n        if (accent.slurred) {\n          slurStem(parsed.stem, true);\n        } // Start a default voice if we're not in a voice yet.\n\n\n        if (context === result) {\n          startVoiceContext(firstVoiceName());\n        }\n\n        if (!(\"stems\" in context)) {\n          context.stems = [];\n        } // Add the stem to the sequence of stems for this voice.\n\n\n        context.stems.push(parsed.stem); // Advance the parsing index since a stem is multiple tokens.\n\n        index = parsed.index;\n      }\n    } // Parse M: lines.  \"3/4\" is 3/4 time and \"C\" is 4/4 (common) time.\n\n\n    function parseMeter(mline, beatinfo) {\n      var d = /^C/.test(mline) ? 4 / 4 : durationToTime(mline);\n\n      if (!d) {\n        return;\n      }\n\n      if (!beatinfo.unitnote) {\n        if (d < 0.75) {\n          beatinfo.unitnote = 1 / 16;\n        } else {\n          beatinfo.unitnote = 1 / 8;\n        }\n      }\n    } // Parse L: lines, e.g., \"1/8\".\n\n\n    function parseUnitNote(lline, beatinfo) {\n      var d = durationToTime(lline);\n\n      if (!d) {\n        return;\n      }\n\n      beatinfo.unitnote = d;\n    } // Parse Q: line, e.g., \"1/4=66\".\n\n\n    function parseTempo(qline, beatinfo) {\n      var parts = qline.split(/\\s+|=/),\n          j,\n          unit = null,\n          tempo = null;\n\n      for (j = 0; j < parts.length; ++j) {\n        // It could be reversed, like \"66=1/4\", or just \"120\", so\n        // determine what is going on by looking for a slash etc.\n        if (parts[j].indexOf(\"/\") >= 0 || /^[1-4]$/.test(parts[j])) {\n          // The note-unit (e.g., 1/4).\n          unit = unit || durationToTime(parts[j]);\n        } else {\n          // The tempo-number (e.g., 120)\n          tempo = tempo || Number(parts[j]);\n        }\n      }\n\n      if (unit) {\n        beatinfo.unitbeat = unit;\n      }\n\n      if (tempo) {\n        beatinfo.tempo = tempo;\n      }\n    } // Run through all the notes, adding up time for tied notes,\n    // and marking notes that were held over with holdover = true.\n\n\n    function processTies(stems) {\n      var tied = {},\n          nextTied,\n          j,\n          k,\n          note,\n          firstNote;\n\n      for (j = 0; j < stems.length; ++j) {\n        nextTied = {};\n\n        for (k = 0; k < stems[j].notes.length; ++k) {\n          firstNote = note = stems[j].notes[k];\n\n          if (tied.hasOwnProperty(note.pitch)) {\n            // Pitch was tied from before.\n            firstNote = tied[note.pitch]; // Get the earliest note in the tie.\n\n            firstNote.time += note.time; // Extend its time.\n\n            note.holdover = true; // Silence this note as a holdover.\n          }\n\n          if (note.tie) {\n            // This note is tied with the next.\n            nextTied[note.pitch] = firstNote; // Save it away.\n          }\n        }\n\n        tied = nextTied;\n      }\n    } // Returns a map of A-G -> accidentals, according to the key signature.\n    // When n is zero, there are no accidentals (e.g., C major or A minor).\n    // When n is positive, there are n sharps (e.g., for G major, n = 1).\n    // When n is negative, there are -n flats (e.g., for F major, n = -1).\n\n\n    function accidentals(n) {\n      var sharps = \"FCGDAEB\",\n          result = {},\n          j;\n\n      if (!n) {\n        return result;\n      }\n\n      if (n > 0) {\n        // Handle sharps.\n        for (j = 0; j < n && j < 7; ++j) {\n          result[sharps.charAt(j)] = \"^\";\n        }\n      } else {\n        // Flats are in the opposite order.\n        for (j = 0; j > n && j > -7; --j) {\n          result[sharps.charAt(6 + j)] = \"_\";\n        }\n      }\n\n      return result;\n    } // Decodes the key signature line (e.g., K: C#m) at the front of an ABC tune.\n    // Supports the whole range of scale systems listed in the ABC spec.\n\n\n    function keysig(keyname) {\n      if (!keyname) {\n        return {};\n      }\n\n      var kkey,\n          sigcodes = {\n        // Major\n        \"c#\": 7,\n        \"f#\": 6,\n        b: 5,\n        e: 4,\n        a: 3,\n        d: 2,\n        g: 1,\n        c: 0,\n        f: -1,\n        bb: -2,\n        eb: -3,\n        ab: -4,\n        db: -5,\n        gb: -6,\n        cb: -7,\n        // Minor\n        \"a#m\": 7,\n        \"d#m\": 6,\n        \"g#m\": 5,\n        \"c#m\": 4,\n        \"f#m\": 3,\n        bm: 2,\n        em: 1,\n        am: 0,\n        dm: -1,\n        gm: -2,\n        cm: -3,\n        fm: -4,\n        bbm: -5,\n        ebm: -6,\n        abm: -7,\n        // Mixolydian\n        \"g#mix\": 7,\n        \"c#mix\": 6,\n        \"f#mix\": 5,\n        bmix: 4,\n        emix: 3,\n        amix: 2,\n        dmix: 1,\n        gmix: 0,\n        cmix: -1,\n        fmix: -2,\n        bbmix: -3,\n        ebmix: -4,\n        abmix: -5,\n        dbmix: -6,\n        gbmix: -7,\n        // Dorian\n        \"d#dor\": 7,\n        \"g#dor\": 6,\n        \"c#dor\": 5,\n        \"f#dor\": 4,\n        bdor: 3,\n        edor: 2,\n        ador: 1,\n        ddor: 0,\n        gdor: -1,\n        cdor: -2,\n        fdor: -3,\n        bbdor: -4,\n        ebdor: -5,\n        abdor: -6,\n        dbdor: -7,\n        // Phrygian\n        \"e#phr\": 7,\n        \"a#phr\": 6,\n        \"d#phr\": 5,\n        \"g#phr\": 4,\n        \"c#phr\": 3,\n        \"f#phr\": 2,\n        bphr: 1,\n        ephr: 0,\n        aphr: -1,\n        dphr: -2,\n        gphr: -3,\n        cphr: -4,\n        fphr: -5,\n        bbphr: -6,\n        ebphr: -7,\n        // Lydian\n        \"f#lyd\": 7,\n        blyd: 6,\n        elyd: 5,\n        alyd: 4,\n        dlyd: 3,\n        glyd: 2,\n        clyd: 1,\n        flyd: 0,\n        bblyd: -1,\n        eblyd: -2,\n        ablyd: -3,\n        dblyd: -4,\n        gblyd: -5,\n        cblyd: -6,\n        fblyd: -7,\n        // Locrian\n        \"b#loc\": 7,\n        \"e#loc\": 6,\n        \"a#loc\": 5,\n        \"d#loc\": 4,\n        \"g#loc\": 3,\n        \"c#loc\": 2,\n        \"f#loc\": 1,\n        bloc: 0,\n        eloc: -1,\n        aloc: -2,\n        dloc: -3,\n        gloc: -4,\n        cloc: -5,\n        floc: -6,\n        bbloc: -7\n      };\n      var k = keyname.replace(/\\s+/g, \"\").toLowerCase().substr(0, 5);\n      var scale = k.match(/maj|min|mix|dor|phr|lyd|loc|m/);\n\n      if (scale) {\n        if (scale == \"maj\") {\n          kkey = k.substr(0, scale.index);\n        } else if (scale == \"min\") {\n          kkey = k.substr(0, scale.index + 1);\n        } else {\n          kkey = k.substr(0, scale.index + scale[0].length);\n        }\n      } else {\n        kkey = /^[a-g][#b]?/.exec(k) || \"\";\n      }\n\n      var result = accidentals(sigcodes[kkey]);\n      var extras = keyname.substr(kkey.length).match(/(_+|=|\\^+)[a-g]/gi);\n\n      if (extras) {\n        for (var j = 0; j < extras.length; ++j) {\n          var note = extras[j].charAt(extras[j].length - 1).toUpperCase();\n\n          if (extras[j].charAt(0) == \"=\") {\n            delete result[note];\n          } else {\n            result[note] = extras[j].substr(0, extras[j].length - 1);\n          }\n        }\n      }\n\n      return result;\n    } // Additively adjusts the beats for a stem and the contained notes.\n\n\n    function syncopateStem(stem, t) {\n      var j,\n          note,\n          stemtime = stem.time,\n          newtime = stemtime + t;\n      stem.time = newtime;\n      syncopateStem;\n\n      for (j = 0; j < stem.notes.length; ++j) {\n        note = stem.notes[j]; // Only adjust a note's duration if it matched the stem's duration.\n\n        if (note.time == stemtime) {\n          note.time = newtime;\n        }\n      }\n    } // Marks everything in the stem with the slur attribute (or deletes it).\n\n\n    function slurStem(stem, addSlur) {\n      var j, note;\n\n      for (j = 0; j < stem.notes.length; ++j) {\n        note = stem.notes[j];\n\n        if (addSlur) {\n          note.slurred = true;\n        } else if (note.slurred) {\n          delete note.slurred;\n        }\n      }\n    } // Scales the beats for a stem and the contained notes.\n\n\n    function scaleStem(stem, s) {\n      var j;\n      stem.time *= s;\n\n      for (j = 0; j < stem.notes.length; ++j) {\n        stem.notes[j].time *= s;\n      }\n    } // Parses notation of the form (3 or (5:2:10, which means to do\n    // the following 3 notes in the space of 2 notes, or to do the following\n    // 10 notes at the rate of 5 notes per 2 beats.\n\n\n    function parseBeatlet(token) {\n      var m = /^\\((\\d+)(?::(\\d+)(?::(\\d+))?)?$/.exec(token);\n\n      if (!m) {\n        return null;\n      }\n\n      var count = Number(m[1]),\n          beats = Number(m[2]) || 2,\n          duration = Number(m[3]) || count;\n      return {\n        time: beats / count,\n        count: duration\n      };\n    } // Parse !ppp! markings.\n\n\n    function parseDecoration(token, accent) {\n      if (token.length < 2) {\n        return;\n      }\n\n      token = token.substring(1, token.length - 1);\n\n      switch (token) {\n        case \"pppp\":\n        case \"ppp\":\n          accent.dynamics = 0.2;\n          break;\n\n        case \"pp\":\n          accent.dynamics = 0.4;\n          break;\n\n        case \"p\":\n          accent.dynamics = 0.6;\n          break;\n\n        case \"mp\":\n          accent.dynamics = 0.8;\n          break;\n\n        case \"mf\":\n          accent.dynamics = 1.0;\n          break;\n\n        case \"f\":\n          accent.dynamics = 1.2;\n          break;\n\n        case \"ff\":\n          accent.dynamics = 1.4;\n          break;\n\n        case \"fff\":\n        case \"ffff\":\n          accent.dynamics = 1.5;\n          break;\n      }\n    } // Parses a stem, which may be a single note, or which may be\n    // a chorded note.\n\n\n    function parseStem(tokens, index, key, accent) {\n      var notes = [],\n          duration = \"\",\n          staccato = false,\n          noteDuration,\n          noteTime,\n          velocity,\n          lastNote = null,\n          minStemTime = Infinity,\n          j; // A single staccato marking applies to the entire stem.\n\n      if (index < tokens.length && \".\" == tokens[index]) {\n        staccato = true;\n        index++;\n      }\n\n      if (index < tokens.length && tokens[index] == \"[\") {\n        // Deal with [CEG] chorded notation.\n        index++; // Scan notes within the chord.\n\n        while (index < tokens.length) {\n          // Ignore and space and %comments.\n          if (/^[\\s%]/.test(tokens[index])) {\n            index++;\n            continue;\n          }\n\n          if (/[A-Ga-g]/.test(tokens[index])) {\n            // Grab a pitch.\n            lastNote = {\n              pitch: applyAccent(tokens[index++], key, accent),\n              tie: false\n            };\n            lastNote.frequency = Utils.pitchToFrequency(lastNote.pitch);\n            notes.push(lastNote);\n          } else if (/[xzXZ]/.test(tokens[index])) {\n            // Grab a rest.\n            lastNote = null;\n            index++;\n          } else if (\".\" == tokens[index]) {\n            // A staccato mark applies to the entire stem.\n            staccato = true;\n            index++;\n            continue;\n          } else {\n            // Stop parsing the stem if something is unrecognized.\n            break;\n          } // After a pitch or rest, look for a duration.\n\n\n          if (index < tokens.length && /^(?![\\s%!]).*[\\d\\/]/.test(tokens[index])) {\n            noteDuration = tokens[index++];\n            noteTime = durationToTime(noteDuration);\n          } else {\n            noteDuration = \"\";\n            noteTime = 1;\n          } // If it's a note (not a rest), store the duration\n\n\n          if (lastNote) {\n            lastNote.duration = noteDuration;\n            lastNote.time = noteTime;\n          } // When a stem has more than one duration, use the shortest\n          // one for timing. The standard says to pick the first one,\n          // but in practice, transcribed music online seems to\n          // follow the rule that the stem's duration is determined\n          // by the shortest contained duration.\n\n\n          if (noteTime && noteTime < minStemTime) {\n            duration = noteDuration;\n            minStemTime = noteTime;\n          } // After a duration, look for a tie mark.  Individual notes\n          // within a stem can be tied.\n\n\n          if (index < tokens.length && \"-\" == tokens[index]) {\n            if (lastNote) {\n              notes[notes.length - 1].tie = true;\n            }\n\n            index++;\n          }\n        } // The last thing in a chord should be a ].  If it isn't, then\n        // this doesn't look like a stem after all, and return null.\n\n\n        if (tokens[index] != \"]\") {\n          return null;\n        }\n\n        index++;\n      } else if (index < tokens.length && /[A-Ga-g]/.test(tokens[index])) {\n        // Grab a single note.\n        lastNote = {\n          pitch: applyAccent(tokens[index++], key, accent),\n          tie: false,\n          duration: \"\",\n          time: 1\n        };\n        lastNote.frequency = Utils.pitchToFrequency(lastNote.pitch);\n        notes.push(lastNote);\n      } else if (index < tokens.length && /^[xzXZ]$/.test(tokens[index])) {\n        // Grab a rest - no pitch.\n        index++;\n      } else {\n        // Something we don't recognize - not a stem.\n        return null;\n      } // Right after a [chord], note, or rest, look for a duration marking.\n\n\n      if (index < tokens.length && /^(?![\\s%!]).*[\\d\\/]/.test(tokens[index])) {\n        duration = tokens[index++];\n        noteTime = durationToTime(duration); // Apply the duration to all the ntoes in the stem.\n        // NOTE: spec suggests multiplying this duration, but that\n        // idiom is not seen (so far) in practice.\n\n        for (j = 0; j < notes.length; ++j) {\n          notes[j].duration = duration;\n          notes[j].time = noteTime;\n        }\n      } // Then look for a trailing tie marking.  Will tie every note in a chord.\n\n\n      if (index < tokens.length && \"-\" == tokens[index]) {\n        index++;\n\n        for (j = 0; j < notes.length; ++j) {\n          notes[j].tie = true;\n        }\n      }\n\n      if (accent.dynamics) {\n        velocity = accent.dynamics;\n\n        for (j = 0; j < notes.length; ++j) {\n          notes[j].velocity = velocity;\n        }\n      }\n\n      return {\n        index: index,\n        stem: {\n          notes: notes,\n          duration: duration,\n          staccato: staccato,\n          time: durationToTime(duration)\n        }\n      };\n    } // Normalizes pitch markings by stripping leading = if present.\n\n\n    function stripNatural(pitch) {\n      if (pitch.length > 0 && pitch.charAt(0) == \"=\") {\n        return pitch.substr(1);\n      }\n\n      return pitch;\n    } // Processes an accented pitch, automatically applying accidentals\n    // that have accumulated within the measure, and also saving\n    // explicit accidentals to continue to apply in the measure.\n\n\n    function applyAccent(pitch, key, accent) {\n      var m = /^(\\^+|_+|=|)([A-Ga-g])(.*)$/.exec(pitch),\n          letter;\n\n      if (!m) {\n        return pitch;\n      } // Note that an accidental in one octave applies in other octaves.\n\n\n      letter = m[2].toUpperCase();\n\n      if (m[1].length > 0) {\n        // When there is an explicit accidental, then remember it for\n        // the rest of the measure.\n        accent[letter] = m[1];\n        return stripNatural(pitch);\n      }\n\n      if (accent.hasOwnProperty(letter)) {\n        // Accidentals from this measure apply to unaccented notes.\n        return stripNatural(accent[letter] + m[2] + m[3]);\n      }\n\n      if (key.hasOwnProperty(letter)) {\n        // Key signatures apply by default.\n        return stripNatural(key[letter] + m[2] + m[3]);\n      }\n\n      return stripNatural(pitch);\n    } // Converts an ABC duration to a number (e.g., \"/3\"->0.333 or \"11/2\"->1.5).\n\n\n    function durationToTime(duration) {\n      var m = /^(\\d*)(?:\\/(\\d*))?$|^(\\/+)$/.exec(duration),\n          n,\n          d,\n          i = 0,\n          ilen;\n      if (!m) return;\n      if (m[3]) return Math.pow(0.5, m[3].length);\n      d = m[2] ? parseFloat(m[2]) : /\\//.test(duration) ? 2 : 1; // Handle mixed frations:\n\n      ilen = 0;\n      n = m[1] ? parseFloat(m[1]) : 1;\n\n      if (m[2]) {\n        while (ilen + 1 < m[1].length && n > d) {\n          ilen += 1;\n          i = parseFloat(m[1].substring(0, ilen));\n          n = parseFloat(m[1].substring(ilen));\n        }\n      }\n\n      return i + n / d;\n    }\n  }\n\n  _Musical.parseABCFile = parseABCFile;\n\n  var Instrument = /*#__PURE__*/function () {\n    Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Instrument, null, [{\n      key: \"pitchToMidi\",\n      // Seconds to delay all audiable timing.\n      // Seconds before an event to reexamine queue.\n      // Seconds ahead to put notes in WebAudio.\n      // Default duration of a tone.\n      // Silent time before disconnecting nodes.\n      // Accepts either an ABC pitch or a midi number and converts to midi.\n      value: function pitchToMidi(n) {\n        if (typeof n == \"string\") {\n          return Utils.pitchToMidi(n);\n        }\n\n        return n;\n      } // Accepts either an ABC pitch or a midi number and converts to ABC pitch.\n\n    }, {\n      key: \"midiToPitch\",\n      value: function midiToPitch(n) {\n        if (typeof n == \"number\") {\n          return Utils.midiToPitch(n);\n        }\n\n        return n;\n      }\n    }]);\n\n    function Instrument(options) {\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Instrument);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_out\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_atop\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_timbre\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_queue\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_minQueueTime\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_maxScheduledTime\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_unsortedQueue\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_startSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_finishSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_cleanupSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_callbackSet\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_handlers\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_now\", void 0);\n\n      Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, \"_pollTimer\", void 0);\n\n      this._atop = Utils.getAudioTop(); // Audio context.\n\n      this._timbre = Utils.makeTimbre(options, this._atop); // The instrument's timbre.\n\n      this._queue = []; // A queue of future tones to play.\n\n      this._minQueueTime = Infinity; // The earliest time in _queue.\n\n      this._maxScheduledTime = 0; // The latest time in _queue.\n\n      this._unsortedQueue = false; // True if _queue is unsorted.\n\n      this._startSet = []; // Unstarted tones already sent to WebAudio.\n\n      this._finishSet = {}; // Started tones playing in WebAudio.\n\n      this._cleanupSet = []; // Tones waiting for cleanup.\n\n      this._callbackSet = []; // A set of scheduled callbacks.\n\n      this._handlers = {}; // 'noteon' and 'noteoff' handlers.\n\n      this._now = null; // A cached current-time value.\n\n      if (Utils.isAudioPresent()) {\n        this.silence(); // Initializes top-level audio node.\n      }\n    } // Sets the default timbre for the instrument.  See defaultTimbre.\n\n\n    Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Instrument, [{\n      key: \"setTimbre\",\n      value: function setTimbre(t) {\n        this._timbre = Utils.makeTimbre(t, this._atop); // Saves a copy.\n      } // Returns the default timbre for the instrument as an object.\n\n    }, {\n      key: \"getTimbre\",\n      value: function getTimbre(t) {\n        return Utils.makeTimbre(this._timbre, this._atop); // Makes a copy.\n      } // Sets the overall volume for the instrument immediately.\n\n    }, {\n      key: \"setVolume\",\n      value: function setVolume(v) {\n        // Without an audio system, volume cannot be set.\n        if (!this._out) {\n          return;\n        }\n\n        if (!isNaN(v)) {\n          this._out.gain.value = v;\n        }\n      } // Sets the overall volume for the instrument.\n\n    }, {\n      key: \"getVolume\",\n      value: function getVolume(v) {\n        // Without an audio system, volume is stuck at zero.\n        if (!this._out) {\n          return 0.0;\n        }\n\n        return this._out.gain.value;\n      } // Silences the instrument immediately by reinitializing the audio\n      // graph for this instrument and emptying or flushing all queues in the\n      // scheduler.  Carefully notifies all notes that have started but not\n      // yet finished, and sequences that are awaiting scheduled callbacks.\n      // Does not notify notes that have not yet started.\n\n    }, {\n      key: \"silence\",\n      value: function silence() {\n        var j,\n            finished,\n            callbacks,\n            initvolume = 1; // Clear future notes.\n\n        this._queue.length = 0;\n        this._minQueueTime = Infinity;\n        this._maxScheduledTime = 0; // Don't notify notes that haven't started yet.\n\n        this._startSet.length = 0; // Flush finish callbacks that are promised.\n\n        finished = this._finishSet;\n        this._finishSet = {}; // Flush one-time callacks that are promised.\n\n        callbacks = this._callbackSet;\n        this._callbackSet = []; // Disconnect the audio graph for this instrument.\n\n        if (this._out) {\n          this._out.disconnect();\n\n          initvolume = this._out.gain.value;\n        } // Reinitialize the audio graph: all audio for the instrument\n        // multiplexes through a single gain node with a master volume.\n\n\n        this._atop = Utils.getAudioTop();\n        this._out = this._atop.ac.createGain(); // this._out.gain.value = initvolume; // RONYEH REMOVED DUE TO BUG.\n\n        this._out.gain.setTargetAtTime(initvolume, this._atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n\n        this._out.connect(this._atop.out); // As a last step, call all promised notifications.\n\n\n        for (j in finished) {\n          this._trigger(\"noteoff\", finished[j]);\n        }\n\n        for (j = 0; j < callbacks.length; ++j) {\n          callbacks[j].callback();\n        }\n      } // Future notes are scheduled relative to now(), which provides\n      // access to audioCurrentStartTime(), a time that holds steady\n      // until the script releases to the event loop.  When _now is\n      // non-null, it indicates that scheduling is already in progress.\n      // The timer-driven _doPoll function clears the cached _now.\n\n    }, {\n      key: \"now\",\n      value: function now() {\n        if (this._now != null) {\n          return this._now;\n        }\n\n        this._startPollTimer(true); // passing (true) sets this._now.\n\n\n        return this._now;\n      } // Register an event handler.  Done without jQuery to reduce dependencies.\n\n    }, {\n      key: \"on\",\n      value: function on(eventname, cb) {\n        if (!this._handlers.hasOwnProperty(eventname)) {\n          this._handlers[eventname] = [];\n        }\n\n        this._handlers[eventname].push(cb);\n      } // Unregister an event handler.  Done without jQuery to reduce dependencies.\n\n    }, {\n      key: \"off\",\n      value: function off(eventname, cb) {\n        if (this._handlers.hasOwnProperty(eventname)) {\n          if (!cb) {\n            this._handlers[eventname] = [];\n          } else {\n            var j,\n                hunt = this._handlers[eventname];\n\n            for (j = 0; j < hunt.length; ++j) {\n              if (hunt[j] === cb) {\n                hunt.splice(j, 1);\n                j -= 1;\n              }\n            }\n          }\n        }\n      } // Trigger an event, notifying any registered handlers.\n\n    }, {\n      key: \"_trigger\",\n      value: function _trigger(eventname, record) {\n        var cb = this._handlers[eventname],\n            j;\n\n        if (!cb) {\n          return;\n        }\n\n        if (cb.length == 1) {\n          // Special, common case of one handler: no copy needed.\n          cb[0](record);\n          return;\n        } // Copy the array of callbacks before iterating, because the\n        // main this._handlers copy could be changed by a handler.\n        // You get notified if-and-only-if you are registered\n        // at the starting moment of _trigger.\n\n\n        cb = cb.slice();\n\n        for (j = 0; j < cb.length; ++j) {\n          cb[j](record);\n        }\n      } // Tells the WebAudio API to play a tone (now or soon).  The passed\n      // record specifies a start time and release time, an ADSR envelope,\n      // and other timbre parameters.  This function sets up a WebAudio\n      // node graph for the tone generators and filters for the tone.\n\n    }, {\n      key: \"_makeSound\",\n      value: function _makeSound(record) {\n        var timbre = record.timbre || this._timbre,\n            starttime = record.time + Instrument.timeOffset,\n            releasetime = starttime + record.duration,\n            attacktime = Math.min(releasetime, starttime + timbre.attack),\n            decaytime = timbre.decay * Math.pow(440 / record.frequency, timbre.decayfollow),\n            decaystarttime = attacktime,\n            stoptime = releasetime + timbre.release,\n            doubled = timbre.detune && timbre.detune != 1.0,\n            amp = timbre.gain * record.velocity * (doubled ? 0.5 : 1.0),\n            ac = this._atop.ac,\n            g,\n            f,\n            o,\n            o2,\n            pwave,\n            k,\n            wf,\n            bwf; // Only hook up tone generators if it is an audible sound.\n\n        if (record.duration > 0 && record.velocity > 0) {\n          g = ac.createGain();\n          g.gain.setValueAtTime(0, starttime);\n          g.gain.linearRampToValueAtTime(amp, attacktime); // For the beginning of the decay, use linearRampToValue instead\n          // of setTargetAtTime, because it avoids http://crbug.com/254942.\n\n          while (decaystarttime < attacktime + 1 / 32 && decaystarttime + 1 / 256 < releasetime) {\n            // Just trace out the curve in increments of 1/256 sec\n            // for up to 1/32 seconds.\n            decaystarttime += 1 / 256;\n            g.gain.linearRampToValueAtTime(amp * (timbre.sustain + (1 - timbre.sustain) * Math.exp((attacktime - decaystarttime) / decaytime)), decaystarttime);\n          } // For the rest of the decay, use setTargetAtTime.\n\n\n          g.gain.setTargetAtTime(amp * timbre.sustain, decaystarttime, decaytime); // Then at release time, mark the value and ramp to zero.\n\n          g.gain.setValueAtTime(amp * (timbre.sustain + (1 - timbre.sustain) * Math.exp((attacktime - releasetime) / decaytime)), releasetime);\n          g.gain.linearRampToValueAtTime(0, stoptime);\n          g.connect(this._out); // Hook up a low-pass filter if cutoff is specified.\n\n          if (!timbre.cutoff && !timbre.cutfollow || timbre.cutoff == Infinity) {\n            f = g;\n          } else {\n            // Apply the cutoff frequency adjusted using cutfollow.\n            f = ac.createBiquadFilter(); // f.frequency.value = timbre.cutoff + record.frequency * timbre.cutfollow; // RONYEH REMOVED DUE TO BUG.\n            // f.Q.value = timbre.resonance; // RONYEH REMOVED DUE TO BUG.\n\n            f.frequency.setTargetAtTime(timbre.cutoff + record.frequency * timbre.cutfollow, this._atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n            f.Q.setTargetAtTime(timbre.resonance, this._atop.ac.currentTime, 0.001); // RONYEH ADDED\n\n            f.connect(g);\n          } // Hook up the main oscillator.\n\n\n          o = Utils.makeOscillator(this._atop, timbre.wave, record.frequency);\n          o.connect(f);\n          o.start(starttime);\n          o.stop(stoptime); // Hook up a detuned oscillator.\n\n          if (doubled) {\n            o2 = Utils.makeOscillator(this._atop, timbre.wave, record.frequency * timbre.detune);\n            o2.connect(f);\n            o2.start(starttime);\n            o2.stop(stoptime);\n          } // Store nodes in the record so that they can be modified\n          // in case the tone is truncated later.\n\n\n          record.gainNode = g;\n          record.oscillators = [o];\n\n          if (doubled) {\n            record.oscillators.push(o2);\n          }\n\n          record.cleanuptime = stoptime;\n        } else {\n          // Inaudible sounds are scheduled: their purpose is to truncate\n          // audible tones at the same pitch.  But duration is set to zero\n          // so that they are cleaned up quickly.\n          record.duration = 0;\n        }\n\n        this._startSet.push(record);\n      } // Truncates a sound previously scheduled by _makeSound by using\n      // cancelScheduledValues and directly ramping down to zero.\n      // Can only be used to shorten a sound.\n\n    }, {\n      key: \"_truncateSound\",\n      value: function _truncateSound(record, truncatetime) {\n        if (truncatetime < record.time + record.duration) {\n          record.duration = Math.max(0, truncatetime - record.time);\n\n          if (record.gainNode) {\n            var timbre = record.timbre || this._timbre,\n                starttime = record.time + Instrument.timeOffset,\n                releasetime = truncatetime + Instrument.timeOffset,\n                attacktime = Math.min(releasetime, starttime + timbre.attack),\n                decaytime = timbre.decay * Math.pow(440 / record.frequency, timbre.decayfollow),\n                stoptime = releasetime + timbre.release,\n                cleanuptime = stoptime + Instrument.cleanupDelay,\n                doubled = timbre.detune && timbre.detune != 1.0,\n                amp = timbre.gain * record.velocity * (doubled ? 0.5 : 1.0),\n                j,\n                g = record.gainNode; // Cancel any envelope points after the new releasetime.\n\n            g.gain.cancelScheduledValues(releasetime);\n\n            if (releasetime <= starttime) {\n              // Release before start?  Totally silence the note.\n              g.gain.setValueAtTime(0, releasetime);\n            } else if (releasetime <= attacktime) {\n              // Release before attack is done?  Interrupt ramp up.\n              // g.gain.linearRampToValueAtTime((amp * (releasetime - starttime)) / (attacktime - starttime));\n              g.gain.linearRampToValueAtTime(amp * (releasetime - starttime) / (attacktime - starttime), starttime); // RONYEH ADDED SECOND PARAM \"starttime\".\n            } else {\n              // Release during decay?  Interrupt decay down.\n              g.gain.setValueAtTime(amp * (timbre.sustain + (1 - timbre.sustain) * Math.exp((attacktime - releasetime) / decaytime)), releasetime);\n            } // Then ramp down to zero according to record.release.\n\n\n            g.gain.linearRampToValueAtTime(0, stoptime); // After stoptime, stop the oscillators.  This is necessary to\n            // eliminate extra work for WebAudio for no-longer-audible notes.\n\n            if (record.oscillators) {\n              for (j = 0; j < record.oscillators.length; ++j) {\n                record.oscillators[j].stop(stoptime);\n              }\n            } // Schedule disconnect.\n\n\n            record.cleanuptime = cleanuptime;\n          }\n        }\n      } // The core scheduling loop is managed by Instrument._doPoll.  It reads\n      // the audiocontext's current time and pushes tone records from one\n      // stage to the next.\n      //\n      // 1. The first stage is the _queue, which has tones that have not\n      //    yet been given to WebAudio. This loop scans _queue to find\n      //    notes that need to begin in the next few seconds; then it\n      //    sends those to WebAduio and moves them to _startSet. Because\n      //    scheduled songs can be long, _queue can be large.\n      //\n      // 2. Second is _startSet, which has tones that have been given to\n      //    WebAudio, but whose start times have not yet elapsed. When\n      //    the time advances past the start time of a record, a 'noteon'\n      //    notification is fired for the tone, and it is moved to\n      //    _finishSet.\n      //\n      // 3. _finishSet represents the notes that are currently sounding.\n      //    The programming model for Instrument is that only one tone of\n      //    a specific frequency may be played at once within a Instrument,\n      //    so only one tone of a given frequency may exist in _finishSet\n      //    at once.  When there is a conflict, the sooner-to-end-note\n      //    is truncated.\n      //\n      // 4. After a note is released, it may have a litle release time\n      //    (depending on timbre.release), after which the nodes can\n      //    be totally disconnected and cleaned up.  _cleanupSet holds\n      //    notes for which we are awaiting cleanup.\n\n    }, {\n      key: \"_doPoll\",\n      value: function _doPoll() {\n        this._pollTimer = null;\n        this._now = null;\n\n        if (window.hasOwnProperty(\"interrupted\") && window[\"interrupted\"] === true) {\n          this.silence();\n          return;\n        } // The shortest time we can delay is 1 / 1000 secs, so if an event\n        // is within the next 0.5 ms, now is the closest moment, and we go\n        // ahead and process it.\n\n\n        var instant = this._atop.ac.currentTime + 1 / 2000,\n            callbacks = [],\n            j,\n            work,\n            when,\n            freq,\n            record,\n            conflict,\n            save,\n            cb; // Schedule a batch of notes\n\n        if (this._minQueueTime - instant <= Instrument.bufferSecs) {\n          if (this._unsortedQueue) {\n            this._queue.sort(function (a, b) {\n              if (a.time != b.time) {\n                return a.time - b.time;\n              }\n\n              if (a.duration != b.duration) {\n                return a.duration - b.duration;\n              }\n\n              return a.frequency - b.frequency;\n            });\n\n            this._unsortedQueue = false;\n          }\n\n          for (j = 0; j < this._queue.length; ++j) {\n            if (this._queue[j].time - instant > Instrument.bufferSecs) {\n              break;\n            }\n          }\n\n          if (j > 0) {\n            work = this._queue.splice(0, j);\n\n            for (j = 0; j < work.length; ++j) {\n              this._makeSound(work[j]);\n            }\n\n            this._minQueueTime = this._queue.length > 0 ? this._queue[0].time : Infinity;\n          }\n        } // Disconnect notes from the cleanup set.\n\n\n        for (j = 0; j < this._cleanupSet.length; ++j) {\n          record = this._cleanupSet[j];\n\n          if (record.cleanuptime < instant) {\n            if (record.gainNode) {\n              // This explicit disconnect is needed or else Chrome's WebAudio\n              // starts getting overloaded after a couple thousand notes.\n              record.gainNode.disconnect();\n              record.gainNode = null;\n            }\n\n            this._cleanupSet.splice(j, 1);\n\n            j -= 1;\n          }\n        } // Notify about any notes finishing.\n\n\n        for (freq in this._finishSet) {\n          record = this._finishSet[freq];\n          when = record.time + record.duration;\n\n          if (when <= instant) {\n            callbacks.push({\n              order: [when, 0],\n              f: this._trigger,\n              t: this,\n              a: [\"noteoff\", record]\n            });\n\n            if (record.cleanuptime != Infinity) {\n              this._cleanupSet.push(record);\n            }\n\n            delete this._finishSet[freq];\n          }\n        } // Call any specific one-time callbacks that were registered.\n\n\n        for (j = 0; j < this._callbackSet.length; ++j) {\n          cb = this._callbackSet[j];\n          when = cb.time;\n\n          if (when <= instant) {\n            callbacks.push({\n              order: [when, 1],\n              f: cb.callback,\n              t: null,\n              a: []\n            });\n\n            this._callbackSet.splice(j, 1);\n\n            j -= 1;\n          }\n        } // Notify about any notes starting.\n\n\n        for (j = 0; j < this._startSet.length; ++j) {\n          if (this._startSet[j].time <= instant) {\n            save = record = this._startSet[j];\n            freq = record.frequency;\n            conflict = null;\n\n            if (this._finishSet.hasOwnProperty(freq)) {\n              // If there is already a note at the same frequency playing,\n              // then release the one that starts first, immediately.\n              conflict = this._finishSet[freq];\n\n              if (conflict.time < record.time || conflict.time == record.time && conflict.duration < record.duration) {\n                // Our new sound conflicts with an old one: end the old one\n                // and notify immediately of its noteoff event.\n                this._truncateSound(conflict, record.time);\n\n                callbacks.push({\n                  order: [record.time, 0],\n                  f: this._trigger,\n                  t: this,\n                  a: [\"noteoff\", conflict]\n                });\n                delete this._finishSet[freq];\n              } else {\n                // A conflict from the future has already scheduled,\n                // so our own note shouldn't sound.  Truncate ourselves\n                // immediately, and suppress our own noteon and noteoff.\n                this._truncateSound(record, conflict.time);\n\n                conflict = record;\n              }\n            }\n\n            this._startSet.splice(j, 1);\n\n            j -= 1;\n\n            if (record.duration > 0 && record.velocity > 0 && conflict !== record) {\n              this._finishSet[freq] = record;\n              callbacks.push({\n                order: [record.time, 2],\n                f: this._trigger,\n                t: this,\n                a: [\"noteon\", record]\n              });\n            }\n          }\n        } // Schedule the next _doPoll.\n\n\n        this._startPollTimer(); // Sort callbacks according to the \"order\" tuple, so earlier events\n        // are notified first.\n\n\n        callbacks.sort(function (a, b) {\n          if (a.order[0] != b.order[0]) {\n            return a.order[0] - b.order[0];\n          } // tiebreak by notifying 'noteoff' first and 'noteon' last.\n\n\n          return a.order[1] - b.order[1];\n        }); // At the end, call all the callbacks without depending on \"this\" state.\n\n        for (j = 0; j < callbacks.length; ++j) {\n          cb = callbacks[j];\n          cb.f.apply(cb.t, cb.a);\n        }\n      } // Schedules the next _doPoll call by examining times in the various\n      // sets and determining the soonest event that needs _doPoll processing.\n\n    }, {\n      key: \"_startPollTimer\",\n      value: function _startPollTimer() {\n        var setnow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n        // If we have already done a \"setnow\", then pollTimer is zero-timeout\n        // and cannot be faster.\n        if (this._pollTimer && this._now != null) {\n          return;\n        }\n\n        var self = this,\n            poll = function poll() {\n          self._doPoll();\n        },\n            earliest = Infinity,\n            j,\n            delay;\n\n        if (this._pollTimer) {\n          // Clear any old timer\n          clearTimeout(this._pollTimer);\n          this._pollTimer = null;\n        }\n\n        if (setnow) {\n          // When scheduling tones, cache _now and keep a zero-timeout poll.\n          // _now will be cleared the next time we execute _doPoll.\n          this._now = Utils.audioCurrentStartTime();\n          this._pollTimer = setTimeout(poll, 0);\n          return;\n        } // Timer due to notes starting: wake up for 'noteon' notification.\n\n\n        for (j = 0; j < this._startSet.length; ++j) {\n          earliest = Math.min(earliest, this._startSet[j].time);\n        } // Timer due to notes finishing: wake up for 'noteoff' notification.\n\n\n        for (j in this._finishSet) {\n          earliest = Math.min(earliest, this._finishSet[j].time + this._finishSet[j].duration);\n        } // Timer due to scheduled callback.\n\n\n        for (j = 0; j < this._callbackSet.length; ++j) {\n          earliest = Math.min(earliest, this._callbackSet[j].time);\n        } // Timer due to cleanup: add a second to give some time to batch up.\n\n\n        if (this._cleanupSet.length > 0) {\n          earliest = Math.min(earliest, this._cleanupSet[0].cleanuptime + 1);\n        } // Timer due to sequencer events: subtract a little time to stay ahead.\n\n\n        earliest = Math.min(earliest, this._minQueueTime - Instrument.dequeueTime);\n        delay = Math.max(0.001, earliest - this._atop.ac.currentTime); // If there are no future events, then we do not need a timer.\n\n        if (isNaN(delay) || delay == Infinity) {\n          return;\n        } // Use the Javascript timer to wake up at the right moment.\n\n\n        this._pollTimer = setTimeout(poll, Math.round(delay * 1000));\n      } // The low-level tone function.\n\n    }, {\n      key: \"tone\",\n      value: function tone(pitch, duration, velocity, delay, timbre, origin) {\n        // If audio is not present, this is a no-op.\n        if (!this._atop) {\n          return;\n        } // Called with an object instead of listed args.\n\n\n        if (typeof pitch == \"object\") {\n          if (velocity == null) velocity = pitch.velocity;\n          if (duration == null) duration = pitch.duration;\n          if (delay == null) delay = pitch.delay;\n          if (timbre == null) timbre = pitch.timbre;\n          if (origin == null) origin = pitch.origin;\n          pitch = pitch.pitch;\n        } // Convert pitch from various formats to Hz frequency and a midi num.\n\n\n        var midi, frequency;\n\n        if (!pitch) {\n          pitch = \"C\";\n        }\n\n        if (isNaN(pitch)) {\n          midi = Utils.pitchToMidi(pitch);\n          frequency = Utils.midiToFrequency(midi);\n        } else {\n          frequency = Number(pitch);\n\n          if (frequency < 0) {\n            midi = -frequency;\n            frequency = Utils.midiToFrequency(midi);\n          } else {\n            midi = Utils.frequencyToMidi(frequency);\n          }\n        }\n\n        if (!timbre) {\n          timbre = this._timbre;\n        } // If there is a custom timbre, validate and copy it.\n\n\n        if (timbre !== this._timbre) {\n          var given = timbre,\n              key;\n          timbre = {};\n\n          for (key in Utils.defaultTimbre) {\n            if (key in given) {\n              timbre[key] = given[key];\n            } else {\n              timbre[key] = Utils.defaultTimbre[key]; // RONYEH: There was a typo bug in the original Musical.js. It was caught by our TypeScript compiler.\n            }\n          }\n        } // Create the record for a tone.\n\n\n        var ac = this._atop.ac,\n            now = this.now(),\n            time = now + (delay || 0),\n            record = {\n          time: time,\n          on: false,\n          frequency: frequency,\n          midi: midi,\n          velocity: velocity == null ? 1 : velocity,\n          duration: duration == null ? Instrument.toneLength : duration,\n          timbre: timbre,\n          instrument: this,\n          gainNode: null,\n          oscillators: null,\n          cleanuptime: Infinity,\n          origin: origin // save the origin of the tone for visible feedback\n\n        };\n\n        if (time < now + Instrument.bufferSecs) {\n          // The tone starts soon!  Give it directly to WebAudio.\n          this._makeSound(record);\n        } else {\n          // The tone is later: queue it.\n          if (!this._unsortedQueue && this._queue.length && time < this._queue[this._queue.length - 1].time) {\n            this._unsortedQueue = true;\n          }\n\n          this._queue.push(record);\n\n          this._minQueueTime = Math.min(this._minQueueTime, record.time);\n        }\n      } // The low-level callback scheduling method.\n\n    }, {\n      key: \"schedule\",\n      value: function schedule(delay, callback) {\n        this._callbackSet.push({\n          time: this.now() + delay,\n          callback: callback\n        });\n      } // The high-level sequencing method.\n\n    }, {\n      key: \"play\",\n      value: function play(abcstring) {\n        var args = Array.prototype.slice.call(arguments),\n            done = null,\n            opts = {},\n            subfile,\n            abcfile,\n            argindex,\n            tempo,\n            timbre,\n            k,\n            delay,\n            maxdelay = 0,\n            attenuate,\n            voicename,\n            stems,\n            ni,\n            vn,\n            j,\n            stem,\n            note,\n            beatsecs,\n            secs,\n            v,\n            files = []; // Look for continuation as last argument.\n\n        if (args.length && \"function\" == typeof args[args.length - 1]) {\n          done = args.pop();\n        }\n\n        if (!this._atop) {\n          if (done) {\n            done();\n          }\n\n          return;\n        } // Look for options as first object.\n\n\n        argindex = 0;\n\n        if (\"object\" == typeof args[0]) {\n          // Copy own properties into an options object.\n          for (k in args[0]) {\n            if (args[0].hasOwnProperty(k)) {\n              opts[k] = args[0][k];\n            }\n          }\n\n          argindex = 1; // If a song is supplied by options object, process it.\n\n          if (opts.hasOwnProperty(\"song\")) {\n            args.push(opts[\"song\"]);\n          }\n        } // Parse any number of ABC files as input.\n\n\n        for (; argindex < args.length; ++argindex) {\n          // Handle splitting of ABC subfiles at X: lines.\n          subfile = args[argindex].split(/\\n(?=X:)/);\n\n          for (k = 0; k < subfile.length; ++k) {\n            abcfile = parseABCFile(subfile[k]);\n            if (!abcfile) continue; // Take tempo markings from the first file, and share them.\n\n            if (!opts.hasOwnProperty(\"tempo\") && abcfile.tempo) {\n              opts[\"tempo\"] = abcfile.tempo;\n\n              if (abcfile.unitbeat) {\n                opts[\"tempo\"] = opts[\"tempo\"] * abcfile.unitbeat / (abcfile.unitnote || 1);\n              }\n            } // Ignore files without songs.\n\n\n            if (!abcfile.voice) continue;\n            files.push(abcfile);\n          }\n        } // Default tempo to 120 if nothing else is specified.\n\n\n        if (!opts.hasOwnProperty(\"tempo\")) {\n          opts[\"tempo\"] = 120;\n        } // Default volume to 1 if nothing is specified.\n\n\n        if (!opts.hasOwnProperty(\"volume\")) {\n          opts[\"volume\"] = 1;\n        }\n\n        beatsecs = 60.0 / opts[\"tempo\"]; // Schedule all notes from all the files.\n\n        for (k = 0; k < files.length; ++k) {\n          abcfile = files[k]; // Each file can have multiple voices (e.g., left and right hands)\n\n          for (vn in abcfile.voice) {\n            // Each voice could have a separate timbre.\n            timbre = Utils.makeTimbre(opts[\"timbre\"] || abcfile.voice[vn].timbre || abcfile.timbre || this._timbre, this._atop); // Each voice has a series of stems (notes or chords).\n\n            stems = abcfile.voice[vn].stems;\n            if (!stems) continue; // Starting at delay zero (now), schedule all tones.\n\n            delay = 0;\n\n            for (ni = 0; ni < stems.length; ++ni) {\n              stem = stems[ni]; // Attenuate chords to reduce clipping.\n\n              attenuate = 1 / Math.sqrt(stem.notes.length); // Schedule every note inside a stem.\n\n              for (j = 0; j < stem.notes.length; ++j) {\n                note = stem.notes[j];\n\n                if (note.holdover) {\n                  // Skip holdover notes from ties.\n                  continue;\n                }\n\n                secs = (note.time || stem.time) * beatsecs;\n\n                if (stem.staccato) {\n                  // Shorten staccato notes.\n                  secs = Math.min(Math.min(secs, beatsecs / 16), timbre.attack + timbre.decay);\n                } else if (!note.slurred && secs >= 1 / 8) {\n                  // Separate unslurred notes by about a 30th of a second.\n                  secs -= 1 / 32;\n                }\n\n                v = (note.velocity || 1) * attenuate * opts[\"volume\"]; // This is innsermost part of the inner loop!\n\n                this.tone( // Play the tone:\n                note.pitch, // at the given pitch\n                secs, // for the given duration\n                v, // with the given volume\n                delay, // starting at the proper time\n                timbre, // with the selected timbre\n                note // the origin object for visual feedback\n                );\n              }\n\n              delay += stem.time * beatsecs; // Advance the sequenced time.\n            }\n\n            maxdelay = Math.max(delay, maxdelay);\n          }\n        }\n\n        this._maxScheduledTime = Math.max(this._maxScheduledTime, this.now() + maxdelay);\n\n        if (done) {\n          // Schedule a \"done\" callback after all sequencing is complete.\n          this.schedule(maxdelay, done);\n        }\n      }\n    }]);\n\n    return Instrument;\n  }();\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"timeOffset\", 0.0625);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"dequeueTime\", 0.5);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"bufferSecs\", 2);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"toneLength\", 1);\n\n  Object(_Users_ronyeh_Code_S_Web_squarepoet_github_io_src_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Instrument, \"cleanupDelay\", 0.1);\n\n  _Musical.Instrument = Instrument;\n})(Musical || (Musical = {}));\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Musical);\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwcy9zaGFyZWQvc291bmQvTXVzaWNhbC50cz8wN2IxIl0sIm5hbWVzIjpbIm1ha2VXYXZldGFibGUiLCJhYyIsIndhdmVkYXRhIiwibWFrZVBlcmlvZGljV2F2ZSIsImRhdGEiLCJuIiwicmVhbCIsImxlbmd0aCIsIkZsb2F0MzJBcnJheSIsImltYWciLCJqIiwiY3JlYXRlUGVyaW9kaWNXYXZlIiwiZSIsImNyZWF0ZVdhdmVUYWJsZSIsIm1ha2VNdWx0aXBsZSIsIm11bHQiLCJhbXQiLCJyZXN1bHQiLCJtIiwiTWF0aCIsImxvZyIsIm1pbiIsInB1c2giLCJleHAiLCJrIiwiZCIsImZmIiwicmVjb3JkIiwid2F2ZSIsInB3IiwiZnJlcSIsImRlZnMiLCJwaWFubyIsImdhaW4iLCJhdHRhY2siLCJkZWNheSIsInN1c3RhaW4iLCJyZWxlYXNlIiwiZGVjYXlmb2xsb3ciLCJjdXRvZmYiLCJjdXRmb2xsb3ciLCJyZXNvbmFuY2UiLCJkZXR1bmUiLCJVdGlscyIsImdsb2JhbCIsIkF1ZGlvQ29udGV4dCIsIndlYmtpdEF1ZGlvQ29udGV4dCIsIl9hdWRpb1RvcCIsImlzQXVkaW9QcmVzZW50Iiwid2F2ZXRhYmxlIiwib3V0IiwiY3VycmVudFN0YXJ0IiwicmVzZXRBdWRpbyIsImF0b3AiLCJkaXNjb25uZWN0IiwiZGNuIiwiY3JlYXRlRHluYW1pY3NDb21wcmVzc29yIiwicmF0aW8iLCJzZXRWYWx1ZUF0VGltZSIsImNvbm5lY3QiLCJkZXN0aW5hdGlvbiIsImdldEF1ZGlvVG9wIiwibWF4IiwiY3VycmVudFRpbWUiLCJzZXRUaW1lb3V0IiwibWlkaSIsInBvdyIsInJvdW5kIiwiTE4yIiwicGl0Y2giLCJleGVjIiwib2N0YXZlIiwicmVwbGFjZSIsInNlbWl0b25lIiwibm90ZU51bSIsImFjY1N5bSIsImNoYXJBdCIsImluZGV4Iiwib2N0YXZlcyIsIm5vdGVOYW1lIiwibWlkaVRvRnJlcXVlbmN5IiwicGl0Y2hUb01pZGkiLCJvcHRpb25zIiwia2V5Iiwid3QiLCJkZWZhdWx0VGltYnJlIiwiaGFzT3duUHJvcGVydHkiLCJ3aGl0ZU5vaXNlQnVmIiwiYnVmZmVyU2l6ZSIsInNhbXBsZVJhdGUiLCJjcmVhdGVCdWZmZXIiLCJvdXRwdXQiLCJnZXRDaGFubmVsRGF0YSIsImkiLCJyYW5kb20iLCJ3YXZlbmFtZSIsIndoaXRlTm9pc2UiLCJjcmVhdGVCdWZmZXJTb3VyY2UiLCJidWZmZXIiLCJnZXRXaGl0ZU5vaXNlQnVmIiwibG9vcCIsIm8iLCJjcmVhdGVPc2NpbGxhdG9yIiwicHdhdmUiLCJid2YiLCJ3ZiIsIk51bWJlciIsInNldFBlcmlvZGljV2F2ZSIsInNldFdhdmVUYWJsZSIsInR5cGUiLCJ3aW5kb3ciLCJjb25zb2xlIiwiZnJlcXVlbmN5Iiwic2V0VGFyZ2V0QXRUaW1lIiwiQyIsIkQiLCJFIiwiRiIsIkciLCJBIiwiQiIsImMiLCJmIiwiZyIsImEiLCJiIiwiXyIsIkFCQ2hlYWRlciIsIkFCQ3Rva2VuIiwicGFyc2VBQkNGaWxlIiwic3RyIiwibGluZXMiLCJzcGxpdCIsImNvbnRleHQiLCJ0aW1icmUiLCJoZWFkZXIiLCJzdGVtcyIsImFjY2VudCIsInNsdXJyZWQiLCJ2b2ljZWlkIiwiaGFuZGxlSW5mb3JtYXRpb24iLCJ0cmltIiwidGVzdCIsInBhcnNlQUJDTm90ZXMiLCJpbmZlciIsInZvaWNlIiwicHJvY2Vzc1RpZXMiLCJmaWVsZCIsInZhbHVlIiwic3RhcnRWb2ljZUNvbnRleHQiLCJwYXJzZU1ldGVyIiwicGFyc2VVbml0Tm90ZSIsInBhcnNlVGVtcG8iLCJrZXlzaWciLCJmaXJzdFZvaWNlTmFtZSIsImlkIiwiViIsInRva2VucyIsIm1hdGNoIiwicGFyc2VkIiwiZG90dGVkIiwiYmVhdGxldCIsInQiLCJzdWJzdHJpbmciLCJwYXJzZUJlYXRsZXQiLCJwYXJzZURlY29yYXRpb24iLCJzbHVyU3RlbSIsInBhcnNlU3RlbSIsInNjYWxlU3RlbSIsInN0ZW0iLCJ0aW1lIiwiY291bnQiLCJzeW5jb3BhdGVTdGVtIiwibWxpbmUiLCJiZWF0aW5mbyIsImR1cmF0aW9uVG9UaW1lIiwidW5pdG5vdGUiLCJsbGluZSIsInFsaW5lIiwicGFydHMiLCJ1bml0IiwidGVtcG8iLCJpbmRleE9mIiwidW5pdGJlYXQiLCJ0aWVkIiwibmV4dFRpZWQiLCJub3RlIiwiZmlyc3ROb3RlIiwibm90ZXMiLCJob2xkb3ZlciIsInRpZSIsImFjY2lkZW50YWxzIiwic2hhcnBzIiwia2V5bmFtZSIsImtrZXkiLCJzaWdjb2RlcyIsImJiIiwiZWIiLCJhYiIsImRiIiwiZ2IiLCJjYiIsImJtIiwiZW0iLCJhbSIsImRtIiwiZ20iLCJjbSIsImZtIiwiYmJtIiwiZWJtIiwiYWJtIiwiYm1peCIsImVtaXgiLCJhbWl4IiwiZG1peCIsImdtaXgiLCJjbWl4IiwiZm1peCIsImJibWl4IiwiZWJtaXgiLCJhYm1peCIsImRibWl4IiwiZ2JtaXgiLCJiZG9yIiwiZWRvciIsImFkb3IiLCJkZG9yIiwiZ2RvciIsImNkb3IiLCJmZG9yIiwiYmJkb3IiLCJlYmRvciIsImFiZG9yIiwiZGJkb3IiLCJicGhyIiwiZXBociIsImFwaHIiLCJkcGhyIiwiZ3BociIsImNwaHIiLCJmcGhyIiwiYmJwaHIiLCJlYnBociIsImJseWQiLCJlbHlkIiwiYWx5ZCIsImRseWQiLCJnbHlkIiwiY2x5ZCIsImZseWQiLCJiYmx5ZCIsImVibHlkIiwiYWJseWQiLCJkYmx5ZCIsImdibHlkIiwiY2JseWQiLCJmYmx5ZCIsImJsb2MiLCJlbG9jIiwiYWxvYyIsImRsb2MiLCJnbG9jIiwiY2xvYyIsImZsb2MiLCJiYmxvYyIsInRvTG93ZXJDYXNlIiwic3Vic3RyIiwic2NhbGUiLCJleHRyYXMiLCJ0b1VwcGVyQ2FzZSIsInN0ZW10aW1lIiwibmV3dGltZSIsImFkZFNsdXIiLCJzIiwidG9rZW4iLCJiZWF0cyIsImR1cmF0aW9uIiwiZHluYW1pY3MiLCJzdGFjY2F0byIsIm5vdGVEdXJhdGlvbiIsIm5vdGVUaW1lIiwidmVsb2NpdHkiLCJsYXN0Tm90ZSIsIm1pblN0ZW1UaW1lIiwiSW5maW5pdHkiLCJhcHBseUFjY2VudCIsInBpdGNoVG9GcmVxdWVuY3kiLCJzdHJpcE5hdHVyYWwiLCJsZXR0ZXIiLCJpbGVuIiwicGFyc2VGbG9hdCIsIkluc3RydW1lbnQiLCJtaWRpVG9QaXRjaCIsIl9hdG9wIiwiX3RpbWJyZSIsIm1ha2VUaW1icmUiLCJfcXVldWUiLCJfbWluUXVldWVUaW1lIiwiX21heFNjaGVkdWxlZFRpbWUiLCJfdW5zb3J0ZWRRdWV1ZSIsIl9zdGFydFNldCIsIl9maW5pc2hTZXQiLCJfY2xlYW51cFNldCIsIl9jYWxsYmFja1NldCIsIl9oYW5kbGVycyIsIl9ub3ciLCJzaWxlbmNlIiwidiIsIl9vdXQiLCJpc05hTiIsImZpbmlzaGVkIiwiY2FsbGJhY2tzIiwiaW5pdHZvbHVtZSIsImNyZWF0ZUdhaW4iLCJfdHJpZ2dlciIsImNhbGxiYWNrIiwiX3N0YXJ0UG9sbFRpbWVyIiwiZXZlbnRuYW1lIiwiaHVudCIsInNwbGljZSIsInNsaWNlIiwic3RhcnR0aW1lIiwidGltZU9mZnNldCIsInJlbGVhc2V0aW1lIiwiYXR0YWNrdGltZSIsImRlY2F5dGltZSIsImRlY2F5c3RhcnR0aW1lIiwic3RvcHRpbWUiLCJkb3VibGVkIiwiYW1wIiwibzIiLCJsaW5lYXJSYW1wVG9WYWx1ZUF0VGltZSIsImNyZWF0ZUJpcXVhZEZpbHRlciIsIlEiLCJtYWtlT3NjaWxsYXRvciIsInN0YXJ0Iiwic3RvcCIsImdhaW5Ob2RlIiwib3NjaWxsYXRvcnMiLCJjbGVhbnVwdGltZSIsInRydW5jYXRldGltZSIsImNsZWFudXBEZWxheSIsImNhbmNlbFNjaGVkdWxlZFZhbHVlcyIsIl9wb2xsVGltZXIiLCJpbnN0YW50Iiwid29yayIsIndoZW4iLCJjb25mbGljdCIsInNhdmUiLCJidWZmZXJTZWNzIiwic29ydCIsIl9tYWtlU291bmQiLCJvcmRlciIsIl90cnVuY2F0ZVNvdW5kIiwiYXBwbHkiLCJzZXRub3ciLCJzZWxmIiwicG9sbCIsIl9kb1BvbGwiLCJlYXJsaWVzdCIsImRlbGF5IiwiY2xlYXJUaW1lb3V0IiwiYXVkaW9DdXJyZW50U3RhcnRUaW1lIiwiZGVxdWV1ZVRpbWUiLCJvcmlnaW4iLCJmcmVxdWVuY3lUb01pZGkiLCJnaXZlbiIsIm5vdyIsIm9uIiwidG9uZUxlbmd0aCIsImluc3RydW1lbnQiLCJhYmNzdHJpbmciLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYXJndW1lbnRzIiwiZG9uZSIsIm9wdHMiLCJzdWJmaWxlIiwiYWJjZmlsZSIsImFyZ2luZGV4IiwibWF4ZGVsYXkiLCJhdHRlbnVhdGUiLCJ2b2ljZW5hbWUiLCJuaSIsInZuIiwiYmVhdHNlY3MiLCJzZWNzIiwiZmlsZXMiLCJwb3AiLCJzcXJ0IiwidG9uZSIsInNjaGVkdWxlIiwiTXVzaWNhbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7OztBQUdJO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBLE1BQU1BLGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsQ0FBVUMsRUFBVixFQUFjO0FBQ2hDLFdBQVEsVUFBVUMsUUFBVixFQUFvQjtBQUN4QixlQUFTQyxnQkFBVCxDQUEwQkMsSUFBMUIsRUFBZ0M7QUFDNUIsWUFBSUMsQ0FBQyxHQUFHRCxJQUFJLENBQUNFLElBQUwsQ0FBVUMsTUFBbEI7QUFBQSxZQUNJRCxJQUFJLEdBQUcsSUFBSUUsWUFBSixDQUFpQkgsQ0FBakIsQ0FEWDtBQUFBLFlBRUlJLElBQUksR0FBRyxJQUFJRCxZQUFKLENBQWlCSCxDQUFqQixDQUZYO0FBQUEsWUFHSUssQ0FISjs7QUFJQSxhQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdMLENBQWhCLEVBQW1CLEVBQUVLLENBQXJCLEVBQXdCO0FBQ3BCSixjQUFJLENBQUNJLENBQUQsQ0FBSixHQUFVTixJQUFJLENBQUNFLElBQUwsQ0FBVUksQ0FBVixDQUFWO0FBQ0FELGNBQUksQ0FBQ0MsQ0FBRCxDQUFKLEdBQVVOLElBQUksQ0FBQ0ssSUFBTCxD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Qjs7QUFDQSxZQUFJTCxJQUFKLEVBQVU7QUFDTjtBQUNBLGVBQUtnQixRQUFMLENBQWNYLFFBQWQsRUFBd0JMLElBQXhCO0FBQ0g7QUFDSjs7Ozs7OzBKQTF3QlF0RixVLGdCQUNXLE07OzBKQURYQSxVLGlCQUVZLEc7OzBKQUZaQSxVLGdCQUdXLEM7OzBKQUhYQSxVLGdCQUlXLEM7OzBKQUpYQSxVLGtCQUthLEc7OztHQXJ1Q3BCdUcsTyxLQUFBQSxPOztBQWsvREtBLHNFQUFmIiwiZmlsZSI6Ii4vYXBwcy9zaGFyZWQvc291bmQvTXVzaWNhbC50cy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBtdXNpY2FsLmpzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vUGVuY2lsQ29kZS9tdXNpY2FsLmpzXG5cbm5hbWVzcGFjZSBNdXNpY2FsIHtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFdBVkVUQUJMRS1CVUlMREVSXG5cbiAgICAvLyB3YXZldGFibGUgaXMgYSB0YWJsZSBvZiBuYW1lcyBmb3Igbm9uc3RhbmRhcmQgd2F2ZWZvcm1zLlxuICAgIC8vIFRoZSB0YWJsZSBtYXBzIG5hbWVzIHRvIG9iamVjdHMgdGhhdCBoYXZlIHdhdmU6IGFuZCBmcmVxOlxuICAgIC8vIHByb3BlcnRpZXMuIFRoZSB3YXZlOiBwcm9wZXJ0eSBpcyBhIFBlcmlvZGljV2F2ZSB0byB1c2VcbiAgICAvLyBmb3IgdGhlIG9zY2lsbGF0b3IuICBUaGUgZnJlcTogcHJvcGVydHksIGlmIHByZXNlbnQsXG4gICAgLy8gaXMgYSBtYXAgZnJvbSBoaWdoZXIgZnJlcXVlbmNpZXMgdG8gbW9yZSBQZXJpb2RpY1dhdmVcbiAgICAvLyBvYmplY3RzOyB3aGVuIGEgZnJlcXVlbmN5IGhpZ2hlciB0aGFuIHRoZSBnaXZlbiB0aHJlc2hvbGRcbiAgICAvLyBpcyByZXF1ZXN0ZWQsIHRoZSBhbHRlcm5hdGUgUGVyaW9kaWNXYXZlIGlzIHVzZWQuXG5cbiAgICBjb25zdCBtYWtlV2F2ZXRhYmxlID0gZnVuY3Rpb24gKGFjKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHdhdmVkYXRhKSB7XG4gICAgICAgICAgICBmdW5jdGlvbiBtYWtlUGVyaW9kaWNXYXZlKGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbiA9IGRhdGEucmVhbC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIHJlYWwgPSBuZXcgRmxvYXQzMkFycmF5KG4pLFxuICAgICAgICAgICAgICAgICAgICBpbWFnID0gbmV3IEZsb2F0MzJBcnJheShuKSxcbiAgICAgICAgICAgICAgICAgICAgajtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWxbal0gPSBkYXRhLnJlYWxbal07XG4gICAgICAgICAgICAgICAgICAgIGltYWdbal0gPSBkYXRhLmltYWdbal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIExhdGVzdCBBUEkgbmFtaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWMuY3JlYXRlUGVyaW9kaWNXYXZlKHJlYWwsIGltYWcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRWFybGllciBBUEkgbmFtaW5nLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWMuY3JlYXRlV2F2ZVRhYmxlKHJlYWwsIGltYWcpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBtYWtlTXVsdGlwbGUoZGF0YSwgbXVsdCwgYW10KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHsgcmVhbDogW10sIGltYWc6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgICAgIG4gPSBkYXRhLnJlYWwubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBtO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbSA9IE1hdGgubG9nKG11bHRbTWF0aC5taW4oaiwgbXVsdC5sZW5ndGggLSAxKV0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVhbC5wdXNoKGRhdGEucmVhbFtqXSAqIE1hdGguZXhwKGFtdCAqIG0pKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmltYWcucHVzaChkYXRhLmltYWdbal0gKiBNYXRoLmV4cChhbXQgKiBtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBmZixcbiAgICAgICAgICAgICAgICByZWNvcmQsXG4gICAgICAgICAgICAgICAgd2F2ZSxcbiAgICAgICAgICAgICAgICBwdztcbiAgICAgICAgICAgIGZvciAoayBpbiB3YXZlZGF0YSkge1xuICAgICAgICAgICAgICAgIGQgPSB3YXZlZGF0YVtrXTtcbiAgICAgICAgICAgICAgICB3YXZlID0gbWFrZVBlcmlvZGljV2F2ZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXdhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHsgd2F2ZTogd2F2ZSB9O1xuICAgICAgICAgICAgICAgIC8vIEEgc3RyYXRlZ3kgZm9yIGNvbXB1dGluZyBoaWdoZXIgZnJlcXVlbmN5IHdhdmVmb3JtczogYXBwbHlcbiAgICAgICAgICAgICAgICAvLyBtdWx0aXBsaWVycyB0byBlYWNoIGhhcm1vbmljIGFjY29yZGluZyB0byBkLm11bHQuICBUaGVzZVxuICAgICAgICAgICAgICAgIC8vIG11bHRpcGxpZXJzIGNhbiBiZSBpbnRlcnBvbGF0ZWQgYW5kIGFwcGxpZWQgYXQgYW55IG51bWJlclxuICAgICAgICAgICAgICAgIC8vIG9mIHRyYW5zaXRpb24gZnJlcXVlbmNpZXMuXG4gICAgICAgICAgICAgICAgaWYgKGQubXVsdCkge1xuICAgICAgICAgICAgICAgICAgICBmZiA9IHdhdmVkYXRhW2tdLmZyZXE7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5mcmVxID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBmZi5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2F2ZSA9IG1ha2VQZXJpb2RpY1dhdmUobWFrZU11bHRpcGxlKGQsIGQubXVsdCwgKGogKyAxKSAvIGZmLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdhdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuZnJlcVtmZltqXV0gPSB3YXZlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2F2ZSBoYXMgc29tZSBkZWZhdWx0IGZpbHRlciBzZXR0aW5ncy5cbiAgICAgICAgICAgICAgICBpZiAoZC5kZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5kZWZzID0gZC5kZWZzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba10gPSByZWNvcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KSh7XG4gICAgICAgICAgICAvLyBDdXJyZW50bHkgdGhlIG9ubHkgbm9uc3RhbmRhcmQgd2F2ZWZvcm0gaXMgXCJwaWFub1wiLlxuICAgICAgICAgICAgLy8gSXQgaXMgYmFzZWQgb24gdGhlIGZpcnN0IDMyIGhhcm1vbmljcyBmcm9tIHRoZSBleGFtcGxlOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZS93ZWItYXVkaW8tc2FtcGxlc1xuICAgICAgICAgICAgLy8gL2Jsb2IvZ2gtcGFnZXMvc2FtcGxlcy9hdWRpby93YXZlLXRhYmxlcy9QaWFub1xuICAgICAgICAgICAgLy8gVGhhdCBpcyBhIHRlcnJpZmljIHNvdW5kIGZvciB0aGUgbG93ZXN0IHBpYW5vIHRvbmVzLlxuICAgICAgICAgICAgLy8gRm9yIGhpZ2hlciB0b25lcywgaW50ZXJwb2xhdGUgdG8gYSBjdXN0b216ZWQgd2F2ZVxuICAgICAgICAgICAgLy8gc2hhcGUgY3JlYXRlZCBieSBoYW5kLCBhbmQgYXBwbHkgYSBsb3dwYXNzIGZpbHRlci5cbiAgICAgICAgICAgIHBpYW5vOiB7XG4gICAgICAgICAgICAgICAgcmVhbDogW1xuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAtMC4yMDM1NjksXG4gICAgICAgICAgICAgICAgICAgIDAuNSxcbiAgICAgICAgICAgICAgICAgICAgLTAuNDAxNjc2LFxuICAgICAgICAgICAgICAgICAgICAwLjEzNzEyOCxcbiAgICAgICAgICAgICAgICAgICAgLTAuMTA0MTE3LFxuICAgICAgICAgICAgICAgICAgICAwLjExNTk2NSxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDA0NDEzLFxuICAgICAgICAgICAgICAgICAgICAwLjA2Nzg4NCxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDA4ODgsXG4gICAgICAgICAgICAgICAgICAgIDAuMDc5MyxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDM4NzU2LFxuICAgICAgICAgICAgICAgICAgICAwLjAxMTg4MixcbiAgICAgICAgICAgICAgICAgICAgLTAuMDMwODgzLFxuICAgICAgICAgICAgICAgICAgICAwLjAyNzYwOCxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDEzNDI5LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMzkzLFxuICAgICAgICAgICAgICAgICAgICAtMC4wMTQwMjksXG4gICAgICAgICAgICAgICAgICAgIDAuMDA5NzIsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAwNzY1MyxcbiAgICAgICAgICAgICAgICAgICAgMC4wMDc4NjYsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAzMjAyOSxcbiAgICAgICAgICAgICAgICAgICAgMC4wNDYxMjcsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAyNDE1NSxcbiAgICAgICAgICAgICAgICAgICAgMC4wMjMwOTUsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAwNTUyMixcbiAgICAgICAgICAgICAgICAgICAgMC4wMDQ1MTEsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAwMzU5MyxcbiAgICAgICAgICAgICAgICAgICAgMC4wMTEyNDgsXG4gICAgICAgICAgICAgICAgICAgIC0wLjAwNDkxOSxcbiAgICAgICAgICAgICAgICAgICAgMC4wMDg1MDUsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBpbWFnOiBbXG4gICAgICAgICAgICAgICAgICAgIDAsXG4gICAgICAgICAgICAgICAgICAgIDAuMTQ3NjIxLFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwNyxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDEsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA1LFxuICAgICAgICAgICAgICAgICAgICAtMC4wMDAwMDYsXG4gICAgICAgICAgICAgICAgICAgIDAuMDAwMDA5LFxuICAgICAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwOCxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDAxLFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAxNCxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA4LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwMyxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA5LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwOSxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA1LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwMixcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA3LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA1LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDIzLFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAzNyxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDIxLFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAyMixcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA2LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAwNSxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA0LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAxNCxcbiAgICAgICAgICAgICAgICAgICAgLTAuMDAwMDA3LFxuICAgICAgICAgICAgICAgICAgICAwLjAwMDAxMixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIC8vIEhvdyB0byBhZGp1c3QgdGhlIGhhcm1vbmljcyBmb3IgdGhlIGhpZ2VzdCBub3Rlcy5cbiAgICAgICAgICAgICAgICBtdWx0OiBbMSwgMSwgMC4xOCwgMC4wMTYsIDAuMDEsIDAuMDEsIDAuMDEsIDAuMDA0LCAwLjAxNCwgMC4wMiwgMC4wMTQsIDAuMDA0LCAwLjAwMiwgMC4wMDAwMV0sXG4gICAgICAgICAgICAgICAgLy8gVGhlIGZyZXF1ZW5jaWVzIGF0IHdoaWNoIHRvIGludGVycG9sYXRlIHRoZSBoYXJtb25pY3MuXG4gICAgICAgICAgICAgICAgZnJlcTogWzY1LCA4MCwgMTAwLCAxMzUsIDE4MCwgMjQwLCA2MjAsIDEzNjBdLFxuICAgICAgICAgICAgICAgIC8vIFRoZSBkZWZhdWx0IGZpbHRlciBzZXR0aW5ncyB0byB1c2UgZm9yIHRoZSBwaWFubyB3YXZlLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IHRoaXMgYXBwcm9hY2ggYXR0ZW51YXRlcyBsb3cgbm90ZXMgdG9vIG11Y2ggLVxuICAgICAgICAgICAgICAgIC8vIHRoaXMgc2hvdWxkIGJlIGZpeGVkLlxuICAgICAgICAgICAgICAgIGRlZnM6IHsgd2F2ZTogXCJwaWFub1wiLCBnYWluOiAwLjUsIGF0dGFjazogMC4wMDIsIGRlY2F5OiAwLjI1LCBzdXN0YWluOiAwLjAzLCByZWxlYXNlOiAwLjEsIGRlY2F5Zm9sbG93OiAwLjcsIGN1dG9mZjogODAwLCBjdXRmb2xsb3c6IDAuMSwgcmVzb25hbmNlOiAxLCBkZXR1bmU6IDAuOTk5NCB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8vIEVORCBXQVZFVEFCTEUtQlVJTERFUlxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFVUSUxTXG5cbiAgICBjbGFzcyBVdGlscyB7XG4gICAgICAgIC8vIFRlc3RzIGZvciB0aGUgcHJlc2VuY2Ugb2YgSFRNTDUgV2ViIEF1ZGlvIChvciB3ZWJraXQncyB2ZXJzaW9uKS5cbiAgICAgICAgc3RhdGljIGlzQXVkaW9QcmVzZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuICEhKGdsb2JhbC5BdWRpb0NvbnRleHQgfHwgZ2xvYmFsLndlYmtpdEF1ZGlvQ29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbGwgb3VyIGF1ZGlvIGZ1bm5lbHMgdGhyb3VnaCB0aGUgc2FtZSBBdWRpb0NvbnRleHQgd2l0aCBhXG4gICAgICAgIC8vIER5bmFtaWNzQ29tcHJlc3Nvck5vZGUgdXNlZCBhcyB0aGUgbWFpbiBvdXRwdXQsIHRvIGNvbXByZXNzIHRoZVxuICAgICAgICAvLyBkeW5hbWljIHJhbmdlIG9mIGFsbCBhdWRpby4gIGdldEF1ZGlvVG9wIHNldHMgdGhpcyB1cC5cbiAgICAgICAgcHJpdmF0ZSBzdGF0aWMgX2F1ZGlvVG9wID0gbnVsbDtcbiAgICAgICAgc3RhdGljIGdldEF1ZGlvVG9wKCkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLl9hdWRpb1RvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5fYXVkaW9Ub3A7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIVV0aWxzLmlzQXVkaW9QcmVzZW50KCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhYyA9IG5ldyAoZ2xvYmFsLkF1ZGlvQ29udGV4dCB8fCBnbG9iYWwud2Via2l0QXVkaW9Db250ZXh0KSgpO1xuICAgICAgICAgICAgVXRpbHMuX2F1ZGlvVG9wID0ge1xuICAgICAgICAgICAgICAgIGFjOiBhYyxcbiAgICAgICAgICAgICAgICB3YXZldGFibGU6IG1ha2VXYXZldGFibGUoYWMpLFxuICAgICAgICAgICAgICAgIG91dDogbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RhcnQ6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVXRpbHMucmVzZXRBdWRpbygpO1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLl9hdWRpb1RvcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdoZW4gYXVkaW8gbmVlZHMgdG8gYmUgaW50ZXJydXB0ZWQgZ2xvYmFsbHkgKGUuZy4sIHdoZW4geW91IHByZXNzIHRoZVxuICAgICAgICAvLyBzdG9wIGJ1dHRvbiBpbiB0aGUgSURFKSwgcmVzZXRBdWRpbyBkb2VzIHRoZSBqb2IuXG4gICAgICAgIHN0YXRpYyByZXNldEF1ZGlvKCkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLl9hdWRpb1RvcCkge1xuICAgICAgICAgICAgICAgIHZhciBhdG9wID0gVXRpbHMuX2F1ZGlvVG9wO1xuICAgICAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRvcC1sZXZlbCBub2RlIGFuZCBtYWtlIGEgbmV3IG9uZS5cbiAgICAgICAgICAgICAgICBpZiAoYXRvcC5vdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXRvcC5vdXQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBhdG9wLm91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGF0b3AuY3VycmVudFN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGRjbiA9IGF0b3AuYWMuY3JlYXRlRHluYW1pY3NDb21wcmVzc29yKCk7XG4gICAgICAgICAgICAgICAgZGNuLnJhdGlvLnNldFZhbHVlQXRUaW1lKDE2LCAwKTtcbiAgICAgICAgICAgICAgICBkY24uYXR0YWNrLnNldFZhbHVlQXRUaW1lKDAuMDAwNSwgMCk7XG4gICAgICAgICAgICAgICAgLy8gZGNuLnJhdGlvID0gMTY7IC8vIFJPTllFSDogLnJhdGlvIGlzIGEgUkVBRCBPTkxZIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIGRjbi5hdHRhY2sgPSAwLjAwMDU7IC8vIFJPTllFSDogLnJhdGlvIGlzIGEgUkVBRCBPTkxZIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIGRjbi5jb25uZWN0KGF0b3AuYWMuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgIGF0b3Aub3V0ID0gZGNuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIHByZWNpc2Ugc2NoZWR1bGluZyBvZiBmdXR1cmUgbm90ZXMsIHRoZSBBdWRpb0NvbnRleHQgY3VycmVudFRpbWUgaXNcbiAgICAgICAgLy8gY2FjaGVkIGFuZCBpcyBoZWxkIGNvbnN0YW50IHVudGlsIHRoZSBzY3JpcHQgcmVsZWFzZXMgdG8gdGhlIGV2ZW50IGxvb3AuXG4gICAgICAgIHN0YXRpYyBhdWRpb0N1cnJlbnRTdGFydFRpbWUoKSB7XG4gICAgICAgICAgICB2YXIgYXRvcCA9IFV0aWxzLmdldEF1ZGlvVG9wKCk7XG4gICAgICAgICAgICBpZiAoYXRvcC5jdXJyZW50U3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhdG9wLmN1cnJlbnRTdGFydDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEEgZGVsYXkgY291bGQgYmUgYWRkZWQgYmVsb3cgdG8gaW50cm9kdWNlIGEgdW5pdmVyc2FsIGRlbGF5IGluXG4gICAgICAgICAgICAvLyBhbGwgYmVnaW5uaW5nIHNvdW5kcyAod2l0aG91dCBza2V3aW5nIGR1cmF0aW9ucyBmb3Igc2NoZWR1bGVkXG4gICAgICAgICAgICAvLyBzZXF1ZW5jZXMpLlxuICAgICAgICAgICAgYXRvcC5jdXJyZW50U3RhcnQgPSBNYXRoLm1heCgwLjI1LCBhdG9wLmFjLmN1cnJlbnRUaW1lIC8qICsgMC4wIGRlbGF5ICovKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGF0b3AuY3VycmVudFN0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmV0dXJuIGF0b3AuY3VycmVudFN0YXJ0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydHMgYSBtaWRpIG5vdGUgbnVtYmVyIHRvIGEgZnJlcXVlbmN5IGluIEh6LlxuICAgICAgICBzdGF0aWMgbWlkaVRvRnJlcXVlbmN5KG1pZGkpIHtcbiAgICAgICAgICAgIHJldHVybiA0NDAgKiBNYXRoLnBvdygyLCAobWlkaSAtIDY5KSAvIDEyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWUgY29uc3RhbnRzLlxuICAgICAgICBzdGF0aWMgbm90ZU51bSA9IHsgQzogMCwgRDogMiwgRTogNCwgRjogNSwgRzogNywgQTogOSwgQjogMTEsIGM6IDEyLCBkOiAxNCwgZTogMTYsIGY6IDE3LCBnOiAxOSwgYTogMjEsIGI6IDIzIH07XG4gICAgICAgIHN0YXRpYyBhY2NTeW0gPSB7IFwiXlwiOiAxLCBcIlwiOiAwLCBcIj1cIjogMCwgXzogLTEgfTtcbiAgICAgICAgc3RhdGljIG5vdGVOYW1lID0gW1wiQ1wiLCBcIl5DXCIsIFwiRFwiLCBcIl9FXCIsIFwiRVwiLCBcIkZcIiwgXCJeRlwiLCBcIkdcIiwgXCJfQVwiLCBcIkFcIiwgXCJfQlwiLCBcIkJcIiwgXCJjXCIsIFwiXmNcIiwgXCJkXCIsIFwiX2VcIiwgXCJlXCIsIFwiZlwiLCBcIl5mXCIsIFwiZ1wiLCBcIl9hXCIsIFwiYVwiLCBcIl9iXCIsIFwiYlwiXTtcblxuICAgICAgICAvLyBDb252ZXJ0cyBhIGZyZXF1ZW5jeSBpbiBIeiB0byB0aGUgY2xvc2VzdCBtaWRpIG51bWJlci5cbiAgICAgICAgc3RhdGljIGZyZXF1ZW5jeVRvTWlkaShmcmVxKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCg2OSArIChNYXRoLmxvZyhmcmVxIC8gNDQwKSAqIDEyKSAvIE1hdGguTE4yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnRzIGFuIEFCQyBwaXRjaCAoc3VjaCBhcyBcIl5HLCxcIikgdG8gYSBtaWRpIG5vdGUgbnVtYmVyLlxuICAgICAgICBzdGF0aWMgcGl0Y2hUb01pZGkocGl0Y2gpIHtcbiAgICAgICAgICAgIHZhciBtID0gL14oXFxeK3xfK3w9fCkoW0EtR2EtZ10pKFssJ10qKSQvLmV4ZWMocGl0Y2gpO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2N0YXZlID0gbVszXS5yZXBsYWNlKC8sL2csIFwiXCIpLmxlbmd0aCAtIG1bM10ucmVwbGFjZSgvJy9nLCBcIlwiKS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgc2VtaXRvbmUgPSBVdGlscy5ub3RlTnVtW21bMl1dICsgVXRpbHMuYWNjU3ltW21bMV0uY2hhckF0KDApXSAqIG1bMV0ubGVuZ3RoICsgMTIgKiBvY3RhdmU7XG4gICAgICAgICAgICByZXR1cm4gc2VtaXRvbmUgKyA2MDsgLy8gNjAgPSBtaWRpIGNvZGUgbWlkZGxlIFwiQ1wiLlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydHMgYSBtaWRpIG51bWJlciB0byBhbiBBQkMgbm90YXRpb24gcGl0Y2guXG4gICAgICAgIHN0YXRpYyBtaWRpVG9QaXRjaChtaWRpKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAobWlkaSAtIDcyKSAlIDEyO1xuICAgICAgICAgICAgaWYgKG1pZGkgPiA2MCB8fCBpbmRleCAhPSAwKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2N0YXZlcyA9IE1hdGgucm91bmQoKG1pZGkgLSBpbmRleCAtIDYwKSAvIDEyKSxcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBVdGlscy5ub3RlTmFtZVtpbmRleF07XG4gICAgICAgICAgICB3aGlsZSAob2N0YXZlcyAhPSAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IG9jdGF2ZXMgPiAwID8gXCInXCIgOiBcIixcIjtcbiAgICAgICAgICAgICAgICBvY3RhdmVzICs9IG9jdGF2ZXMgPiAwID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnRzIGFuIEFCQyBwaXRjaCB0byBhIGZyZXF1ZW5jeSBpbiBIei5cbiAgICAgICAgc3RhdGljIHBpdGNoVG9GcmVxdWVuY3kocGl0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBVdGlscy5taWRpVG9GcmVxdWVuY3koVXRpbHMucGl0Y2hUb01pZGkocGl0Y2gpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBkZWZhdWx0IHNvdW5kIGlzIGEgc3F1YXJlIHdhdmUgd2l0aCBhIHByZXR0eSBxdWljayBkZWNheSB0byB6ZXJvLlxuICAgICAgICBzdGF0aWMgZGVmYXVsdFRpbWJyZSA9IHtcbiAgICAgICAgICAgIHdhdmU6IFwic3F1YXJlXCIsIC8vIE9zY2lsbGF0b3IgdHlwZS5cbiAgICAgICAgICAgIGdhaW46IDAuMSwgLy8gT3ZlcmFsbCBnYWluIGF0IG1heGltdW0gYXR0YWNrLlxuICAgICAgICAgICAgYXR0YWNrOiAwLjAwMiwgLy8gQXR0YWNrIHRpbWUgYXQgdGhlIGJlZ2lubmluZyBvZiBhIHRvbmUuXG4gICAgICAgICAgICBkZWNheTogMC40LCAvLyBSYXRlIG9mIGV4cG9uZW50aWFsIGRlY2F5IGFmdGVyIGF0dGFjay5cbiAgICAgICAgICAgIGRlY2F5Zm9sbG93OiAwLCAvLyBBbW91bnQgb2YgZGVjYXkgc2hvcnRlbmluZyBmb3IgaGlnaGVyIG5vdGVzLlxuICAgICAgICAgICAgc3VzdGFpbjogMCwgLy8gUG9ydGlvbiBvZiBnYWluIHRvIHN1c3RhaW4gaW5kZWZpbml0ZWx5LlxuICAgICAgICAgICAgcmVsZWFzZTogMC4xLCAvLyBSZWxlYXNlIHRpbWUgYWZ0ZXIgYSB0b25lIGlzIGRvbmUuXG4gICAgICAgICAgICBjdXRvZmY6IDAsIC8vIExvdy1wYXNzIGZpbHRlciBjdXRvZmYgZnJlcXVlbmN5LlxuICAgICAgICAgICAgY3V0Zm9sbG93OiAwLCAvLyBDdXRvZmYgYWRqdXN0bWVudCwgYSBtdWx0aXBsZSBvZiBvc2NpbGxhdG9yIGZyZXEuXG4gICAgICAgICAgICByZXNvbmFuY2U6IDAsIC8vIExvdy1wYXNzIGZpbHRlciByZXNvbmFuY2UuXG4gICAgICAgICAgICBkZXR1bmU6IDAsIC8vIERldHVuZSBmYWN0b3IgZm9yIGEgc2Vjb25kIG9zY2lsbGF0b3IuXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gTm9ycm1hbGl6ZXMgYSB0aW1icmUgb2JqZWN0IGJ5IG1ha2luZyBhIGNvcHkgdGhhdCBoYXMgZXhhY3RseVxuICAgICAgICAvLyB0aGUgcmlnaHQgc2V0IG9mIHRpbWJyZSBmaWVsZHMsIGRlZmF1bHRpbmcgd2hlbiBuZWVkZWQuXG4gICAgICAgIC8vIEEgdGltYnJlIGNhbiBzcGVjaWZ5IGFueSBvZiB0aGUgZmllbGRzIG9mIGRlZmF1bHRUaW1icmU7IGFueVxuICAgICAgICAvLyB1bnNwZWNpZmllZCBmaWVsZHMgYXJlIHRyZWF0ZWQgYXMgdGhleSBhcmUgc2V0IGluIGRlZmF1bHRUaW1icmUuXG4gICAgICAgIHN0YXRpYyBtYWtlVGltYnJlKG9wdGlvbnMsIGF0b3ApIHtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQWJicmV2aWF0aW9uOiBuYW1lIGEgd2F2ZSB0byBnZXQgYSBkZWZhdWx0IHRpbWJyZSBmb3IgdGhhdCB3YXZlLlxuICAgICAgICAgICAgICAgIG9wdGlvbnMgPSB7IHdhdmU6IG9wdGlvbnMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fSxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgd3QgPSBhdG9wICYmIGF0b3Aud2F2ZXRhYmxlICYmIGF0b3Aud2F2ZXRhYmxlW29wdGlvbnMud2F2ZV07XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBVdGlscy5kZWZhdWx0VGltYnJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHd0ICYmIHd0LmRlZnMgJiYgd3QuZGVmcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gd3QuZGVmc1trZXldO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gVXRpbHMuZGVmYXVsdFRpbWJyZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0aWMgd2hpdGVOb2lzZUJ1ZiA9IG51bGw7IC8vIGNhY2hlXG4gICAgICAgIHN0YXRpYyBnZXRXaGl0ZU5vaXNlQnVmKCkge1xuICAgICAgICAgICAgaWYgKHdoaXRlTm9pc2VCdWYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciBhYyA9IFV0aWxzLmdldEF1ZGlvVG9wKCkuYWMsXG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlclNpemUgPSAyICogYWMuc2FtcGxlUmF0ZSxcbiAgICAgICAgICAgICAgICAgICAgd2hpdGVOb2lzZUJ1ZiA9IGFjLmNyZWF0ZUJ1ZmZlcigxLCBidWZmZXJTaXplLCBhYy5zYW1wbGVSYXRlKSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gd2hpdGVOb2lzZUJ1Zi5nZXRDaGFubmVsRGF0YSgwKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlclNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSBNYXRoLnJhbmRvbSgpICogMiAtIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHdoaXRlTm9pc2VCdWY7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGlzIHV0aWxpdHkgZnVuY3Rpb24gY3JlYXRlcyBhbiBvc2NpbGxhdG9yIGF0IHRoZSBnaXZlbiBmcmVxdWVuY3lcbiAgICAgICAgLy8gYW5kIHRoZSBnaXZlbiB3YXZlbmFtZS4gIEl0IHN1cHBvcnRzIGxvb2t1cHMgaW4gYSBzdGF0aWMgd2F2ZXRhYmxlLFxuICAgICAgICAvLyBkZWZpbmVkIHJpZ2h0IGJlbG93LlxuICAgICAgICBzdGF0aWMgbWFrZU9zY2lsbGF0b3IoYXRvcCwgd2F2ZW5hbWUsIGZyZXEpIHtcbiAgICAgICAgICAgIGlmICh3YXZlbmFtZSA9PSBcIm5vaXNlXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgd2hpdGVOb2lzZSA9IGF0b3AuYWMuY3JlYXRlQnVmZmVyU291cmNlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGVOb2lzZS5idWZmZXIgPSBVdGlscy5nZXRXaGl0ZU5vaXNlQnVmKCk7XG4gICAgICAgICAgICAgICAgd2hpdGVOb2lzZS5sb29wID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2hpdGVOb2lzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB3YXZldGFibGUgPSBhdG9wLndhdmV0YWJsZSxcbiAgICAgICAgICAgICAgICBvID0gYXRvcC5hYy5jcmVhdGVPc2NpbGxhdG9yKCksXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICBwd2F2ZSxcbiAgICAgICAgICAgICAgICBid2YsXG4gICAgICAgICAgICAgICAgd2Y7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh3YXZldGFibGUuaGFzT3duUHJvcGVydHkod2F2ZW5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBhIGN1c3RvbWl6ZWQgd2F2ZXRhYmxlLlxuICAgICAgICAgICAgICAgICAgICBwd2F2ZSA9IHdhdmV0YWJsZVt3YXZlbmFtZV0ud2F2ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdhdmV0YWJsZVt3YXZlbmFtZV0uZnJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYndmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvb2sgZm9yIGEgaGlnaGVyLWZyZXF1ZW5jeSB2YXJpYW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrIGluIHdhdmV0YWJsZVt3YXZlbmFtZV0uZnJlcSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdmID0gTnVtYmVyKGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmVxID4gd2YgJiYgd2YgPiBid2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYndmID0gd2Y7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB3YXZlID0gd2F2ZXRhYmxlW3dhdmVuYW1lXS5mcmVxW2J3Zl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghby5zZXRQZXJpb2RpY1dhdmUgJiYgby5zZXRXYXZlVGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBvbGQgQVBJIG5hbWU6IFNhZmFyaSA3IHN0aWxsIHVzZXMgdGhpcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIG8uc2V0V2F2ZVRhYmxlKHB3YXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBuZXcgQVBJIG5hbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBvLnNldFBlcmlvZGljV2F2ZShwd2F2ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvLnR5cGUgPSB3YXZlbmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdW5yZWNvZ25pemVkLCBqdXN0IHVzZSBzcXVhcmUuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogc3VwcG9ydCBcIm5vaXNlXCIgb3Igb3RoZXIgd2F2ZSBzaGFwZXMuXG4gICAgICAgICAgICAgICAgby50eXBlID0gXCJzcXVhcmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG8uZnJlcXVlbmN5LnZhbHVlID0gZnJlcTsgLy8gUk9OWUVIIFJFTU9WRUQgRFVFIFRPIFNPTUUgQlVHLlxuICAgICAgICAgICAgby5mcmVxdWVuY3kuc2V0VGFyZ2V0QXRUaW1lKGZyZXEsIGF0b3AuYWMuY3VycmVudFRpbWUsIDAuMDAxKTsgLy8gUk9OWUVIIEFEREVEXG4gICAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEVORCBVVElMU1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLy8gUGFyc2VzIGFuIEFCQyBmaWxlIHRvIGFuIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuICAgIC8vIHtcbiAgICAvLyAgIFg6IHZhbHVlIGZyb20gdGhlIFg6IGxpbmVzIGluIGhlYWRlciAoXFxuIHNlcGFyYXRlZCBmb3IgbXVsdGlwbGUgdmFsdWVzKVxuICAgIC8vICAgVjogdmFsdWUgZnJvbSB0aGUgVjpteW5hbWUgbGluZXMgdGhhdCBhcHBlYXIgYmVmb3JlIEs6XG4gICAgLy8gICAoZXRjKTogZm9yIGFsbCB0aGUgb25lLWxldHRlciBoZWFkZXItbmFtZXMuXG4gICAgLy8gICBLOiB2YWx1ZSBmcm9tIHRoZSBLOiBsaW5lcyBpbiBoZWFkZXIuXG4gICAgLy8gICB0ZW1wbzogUTogbGluZSBwYXJzZWQgYXMgYmVhdHNlY3NcbiAgICAvLyAgIHRpbWJyZTogLi4uIEk6dGltYnJlIGxpbmUgYXMgcGFyc2VkIGJ5IG1ha2VUaW1icmVcbiAgICAvLyAgIHZvaWNlOiB7XG4gICAgLy8gICAgIG15bmFtZTogeyAvLyB2b2ljZSB3aXRoIGlkIFwibXluYW1lXCJcbiAgICAvLyAgICAgICBWOiB2YWx1ZSBmcm9tIHRoZSBWOm15bmFtZSBsaW5lcyAoZnJvbSB0aGUgYm9keSlcbiAgICAvLyAgICAgICBzdGVtczogWy4uLl0gYXMgcGFyc2VkIGJ5IHBhcnNlQUJDc3RlbXNcbiAgICAvLyAgICB9XG4gICAgLy8gIH1cbiAgICAvLyB9XG4gICAgLy8gQUJDIGZpbGVzIGFyZSBpZGlvc3luY3JhdGljIHRvIHBhcnNlOiB0aGUgd3JpdHRlbiBzcGVjaWZpY2F0aW9uc1xuICAgIC8vIGRvIG5vdCBuZWNlc3NhcmlseSByZWZsZWN0IHRoZSBkZWZhY3RvIHN0YW5kYXJkIGltcGxlbWVudGVkIGJ5XG4gICAgLy8gQUJDIGNvbnRlbnQgb24gdGhlIHdlYi4gIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZGVzaWduZWQgdG8gYmVcbiAgICAvLyBwcmFjdGljYWwsIHdvcmtpbmcgb24gY29udGVudCBhcyBpdCBhcHBlYXJzIG9uIHRoZSB3ZWIsIGFuZCBvbmx5XG4gICAgLy8gdXNpbmcgdGhlIHdyaXR0ZW4gc3RhbmRhcmQgYXMgYSBndWlkZWxpbmUuXG5cbiAgICB2YXIgQUJDaGVhZGVyID0gL14oW0EtWmEtel0pOlxccyooLiopJC87XG4gICAgdmFyIEFCQ3Rva2VuID0gLyg/OlxcW1tBLVphLXpdOlteXFxdXSpcXF0pfFxccyt8JVteXFxuXSp8IVteXFxzITp8XFxbXFxdXSohfFxcK1teK3whXSpcXCt8W188PkBeXT9cIlteXCJdKlwifFxcW3xcXF18Pit8PCt8KD86KD86XFxeK3xfK3w9fClbQS1HYS1nXSg/OiwrfCcrfCkpfFxcKFxcZCsoPzo6XFxkKyl7MCwyfXxcXGQqXFwvXFxkK3xcXGQrXFwvP3xcXC8rfFt4elhaXXxcXFs/XFx8XFxdP3w6P1xcfDo/fDo6fC4vZztcblxuICAgIGV4cG9ydCBmdW5jdGlvbiBwYXJzZUFCQ0ZpbGUoc3RyKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IHN0ci5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIHJlc3VsdDogYW55ID0ge30sXG4gICAgICAgICAgICBjb250ZXh0ID0gcmVzdWx0LFxuICAgICAgICAgICAgdGltYnJlLFxuICAgICAgICAgICAgaixcbiAgICAgICAgICAgIGssXG4gICAgICAgICAgICBoZWFkZXIsXG4gICAgICAgICAgICBzdGVtcyxcbiAgICAgICAgICAgIGtleSA9IHt9LFxuICAgICAgICAgICAgYWNjZW50ID0geyBzbHVycmVkOiAwIH0sXG4gICAgICAgICAgICB2b2ljZWlkLFxuICAgICAgICAgICAgb3V0O1xuICAgICAgICAvLyBBQkMgZmlsZXMgYXJlIHBhcnNlZCBvbmUgbGluZSBhdCBhIHRpbWUuXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgLy8gRmlyc3QsIGNoZWNrIHRvIHNlZSBpZiB0aGUgbGluZSBpcyBhIGhlYWRlciBsaW5lLlxuICAgICAgICAgICAgaGVhZGVyID0gQUJDaGVhZGVyLmV4ZWMobGluZXNbal0pO1xuICAgICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgICAgIGhhbmRsZUluZm9ybWF0aW9uKGhlYWRlclsxXSwgaGVhZGVyWzJdLnRyaW0oKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKC9eXFxzKig/OiUuKik/JC8udGVzdChsaW5lc1tqXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTa2lwIGJsYW5rIGFuZCBjb21tZW50IGxpbmVzLlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgbm90ZXMuXG4gICAgICAgICAgICAgICAgcGFyc2VBQkNOb3RlcyhsaW5lc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZmVyID0gW1widW5pdG5vdGVcIiwgXCJ1bml0YmVhdFwiLCBcInRlbXBvXCJdO1xuICAgICAgICBpZiAocmVzdWx0Lmhhc093blByb3BlcnR5KFwidm9pY2VcIikgJiYgcmVzdWx0LnZvaWNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvdXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaiBpbiByZXN1bHQudm9pY2UpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnZvaWNlW2pdLnN0ZW1zICYmIHJlc3VsdC52b2ljZVtqXS5zdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRpbWVzIGZvciBhbGwgdGhlIHRpZWQgbm90ZXMuICBUaGlzIGhhcHBlbnMgYXQgdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIGluIHByaW5jaXBsZSwgdGhlIGZpcnN0IG5vdGUgb2YgYSBzb25nIGNvdWxkIGJlIHRpZWQgYWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSB3YXkgdGhyb3VnaCB0byB0aGUgbGFzdCBub3RlLlxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzVGllcyhyZXN1bHQudm9pY2Vbal0uc3RlbXMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBCcmluZyB1cCBpbmZlcnJlZCB0ZW1wbyB2YWx1ZXMgZnJvbSB2b2ljZXMgaWYgbm90IHNwZWNpZmllZFxuICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgaGVhZGVyLlxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgaW5mZXIubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGluZmVyW2tdIGluIHJlc3VsdCkgJiYgaW5mZXJba10gaW4gcmVzdWx0LnZvaWNlW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2luZmVyW2tdXSA9IHJlc3VsdC52b2ljZVtqXVtpbmZlcltrXV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaXMgaW50ZXJuYWwgc3RhdGUgdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQudm9pY2Vbal0uYWNjZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG91dC5wdXNoKGopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlbGV0ZSBhbnkgdm9pY2VzIHRoYXQgaGFkIG5vIHN0ZW1zLlxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG91dC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQudm9pY2Vbb3V0W2pdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgICAgICAvLyBQYXJzaW5nIGhlbHBlciBmdW5jdGlvbnMgYmVsb3cuXG4gICAgICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgICAgIC8vIFByb2Nlc3NlcyBoZWFkZXIgZmllbGRzIHN1Y2ggYXMgVjogdm9pY2UsIHdoaWNoIG1heSBhcHBlYXIgYXQgdGhlXG4gICAgICAgIC8vIHRvcCBvZiB0aGUgQUJDIGZpbGUsIG9yIGluIHRoZSBBQkMgYm9keSBpbiBhIFtWOnZvaWNlXSBkaXJlY3RpdmUuXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUluZm9ybWF0aW9uKGZpZWxkLCB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBoZWFkZXJzIGFyZSByZWNvZ25pemVkIGFuZCBwcm9jZXNzZWQuXG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlZcIjpcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBWOiBoZWFkZXIgc3dpdGNoZXMgdm9pY2VzIGlmIGluIHRoZSBib2R5LlxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpbiB0aGUgaGVhZGVyLCB0aGVuIGl0IGlzIGp1c3QgYWR2aXNvcnkuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0ICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0Vm9pY2VDb250ZXh0KHZhbHVlLnNwbGl0KFwiIFwiKVswXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk1cIjpcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VNZXRlcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJMXCI6XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlVW5pdE5vdGUodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUVwiOlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVRlbXBvKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBbGwgaGVhZGVycyAoaW5jbHVkaW5nIHVucmVjb2duaXplZCBvbmVzKSBhcmVcbiAgICAgICAgICAgIC8vIGp1c3QgYWNjdW11bGF0ZWQgYXMgcHJvcGVydGllcy4gUmVwZWF0ZWQgaGVhZGVyXG4gICAgICAgICAgICAvLyBsaW5lcyBhcmUgYWNjdW11bGF0ZWQgYXMgbXVsdGlsaW5lIHByb3BlcnRpZXMuXG4gICAgICAgICAgICBpZiAoY29udGV4dC5oYXNPd25Qcm9wZXJ0eShmaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0W2ZpZWxkXSArPSBcIlxcblwiICsgdmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRleHRbZmllbGRdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgSyBoZWFkZXIgaXMgc3BlY2lhbDogaXQgc2hvdWxkIGJlIHRoZSBsYXN0IG9uZVxuICAgICAgICAgICAgLy8gYmVmb3JlIHRoZSB2b2ljZXMgYW5kIG5vdGVzIGJlZ2luLlxuICAgICAgICAgICAgaWYgKGZpZWxkID09IFwiS1wiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5c2lnKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCA9PT0gcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Vm9pY2VDb250ZXh0KGZpcnN0Vm9pY2VOYW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNoaWZ0cyBjb250ZXh0IHRvIGEgdm9pY2Ugd2l0aCB0aGUgZ2l2ZW4gaWQgZ2l2ZW4uICBJZiBubyBpZFxuICAgICAgICAvLyBnaXZlbiwgdGhlbiBqdXN0IHN0aWNrcyB3aXRoIHRoZSBjdXJyZW50IHZvaWNlLiAgSWYgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gdm9pY2UgaXMgdW5uYW1lZCBhbmQgZW1wdHksIHJlbmFtZXMgdGhlIGN1cnJlbnQgdm9pY2UuXG4gICAgICAgIGZ1bmN0aW9uIHN0YXJ0Vm9pY2VDb250ZXh0KGlkKSB7XG4gICAgICAgICAgICBpZCA9IGlkIHx8IFwiXCI7XG4gICAgICAgICAgICBpZiAoIWlkICYmIGNvbnRleHQgIT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0LnZvaWNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnZvaWNlID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LnZvaWNlLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgIC8vIFJlc3VtZSBhIG5hbWVkIHZvaWNlLlxuICAgICAgICAgICAgICAgIGNvbnRleHQgPSByZXN1bHQudm9pY2VbaWRdO1xuICAgICAgICAgICAgICAgIGFjY2VudCA9IGNvbnRleHQuYWNjZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTdGFydCBhIG5ldyB2b2ljZS5cbiAgICAgICAgICAgICAgICBjb250ZXh0ID0geyBpZDogaWQsIGFjY2VudDogeyBzbHVycmVkOiAwIH0gfTtcbiAgICAgICAgICAgICAgICByZXN1bHQudm9pY2VbaWRdID0gY29udGV4dDtcbiAgICAgICAgICAgICAgICBhY2NlbnQgPSBjb250ZXh0LmFjY2VudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEZvciBwaWNraW5nIGEgZGVmYXVsdCB2b2ljZSwgbG9va3MgZm9yIHRoZSBmaXJzdCB2b2ljZSBuYW1lLlxuICAgICAgICBmdW5jdGlvbiBmaXJzdFZvaWNlTmFtZSgpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuVikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQuVi5zcGxpdCgvXFxzKy8pWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlcyBhIHNpbmdsZSBsaW5lIG9mIEFCQyBub3RlcyAoaS5lLiwgbm90IGEgaGVhZGVyIGxpbmUpLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBwcm9jZXNzIGFuIEFCQyBzb25nIHN0cmVhbSBieSBkaXZpZGluZyBpdCBpbnRvIHRva2VucywgZWFjaCBvZlxuICAgICAgICAvLyB3aGljaCBpcyBhIHBpdGNoLCBkdXJhdGlvbiwgb3Igc3BlY2lhbCBkZWNvcmF0aW9uIHN5bWJvbDsgdGhlblxuICAgICAgICAvLyB3ZSBwcm9jZXNzIGVhY2ggZGVjb3JhdGlvbiBpbmRpdmlkdWFsbHksIGFuZCB3ZSBwcm9jZXNzIGVhY2hcbiAgICAgICAgLy8gc3RlbSBhcyBhIGdyb3VwIHVzaW5nIHBhcnNlU3RlbS5cbiAgICAgICAgLy8gVGhlIHN0cnVjdHVyZSBvZiBhIHNpbmdsZSBBQkMgbm90ZSBpcyBzb21ldGhpbmcgbGlrZSB0aGlzOlxuICAgICAgICAvL1xuICAgICAgICAvLyBOT1RFIC0+IFNUQUNDQVRPPyBQSVRDSCBEVVJBVElPTj8gVElFP1xuICAgICAgICAvL1xuICAgICAgICAvLyBJLmUuLCBpdCBhbHdheXMgaGFzIGEgcGl0Y2gsIGFuZCBpdCBpcyBwcmVmaXhlZCBieSBzb21lIG9wdGlvbmFsXG4gICAgICAgIC8vIGRlY29yYXRpb25zIHN1Y2ggYXMgYSAoLikgc3RhY2NhdG8gbWFya2luZywgYW5kIGl0IGlzIHN1ZmZpeGVkIGJ5XG4gICAgICAgIC8vIGFuIG9wdGlvbmFsIGR1cmF0aW9uIGFuZCBhbiBvcHRpb25hbCB0aWUgKC0pIG1hcmtpbmcuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEEgc3RlbSBpcyBlaXRoZXIgYSBub3RlIG9yIGEgYnJhY2tldGVkIHNlcmllcyBvZiBub3RlcywgZm9sbG93ZWRcbiAgICAgICAgLy8gYnkgZHVyYXRpb24gYW5kIHRpZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU1RFTSAtPiBOT1RFICAgT1IgICAgJ1snIE5PVEUgKiAnXScgRFVSQUlUT04/IFRJRT9cbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlbiBhIHNvbmcgaXMganVzdCBhIHNlcXVlbmNlIG9mIHN0ZW1zIGludGVybGVhdmVkIHdpdGggb3RoZXJcbiAgICAgICAgLy8gZGVjb3JhdGlvbnMgc3VjaCBhcyBkeW5hbWljcyBtYXJraW5ncyBhbmQgbWVhc3VyZSBkZWxpbWl0ZXJzLlxuICAgICAgICBmdW5jdGlvbiBwYXJzZUFCQ05vdGVzKHN0cikge1xuICAgICAgICAgICAgdmFyIHRva2VucyA9IHN0ci5tYXRjaChBQkN0b2tlbiksXG4gICAgICAgICAgICAgICAgcGFyc2VkID0gbnVsbCxcbiAgICAgICAgICAgICAgICBpbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgZG90dGVkID0gMCxcbiAgICAgICAgICAgICAgICBiZWF0bGV0ID0gbnVsbCxcbiAgICAgICAgICAgICAgICB0O1xuICAgICAgICAgICAgaWYgKCF0b2tlbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgJWNvbW1lbnRzIGFuZCAhbWFya2luZ3MhXG4gICAgICAgICAgICAgICAgaWYgKC9eW1xccyVdLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgaW5saW5lIFtYOi4uLl0gaW5mb3JtYXRpb24gZmllbGRzXG4gICAgICAgICAgICAgICAgaWYgKC9eXFxbW0EtWmEtel06W15cXF1dKlxcXSQvLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSW5mb3JtYXRpb24odG9rZW5zW2luZGV4XS5zdWJzdHJpbmcoMSwgMiksIHRva2Vuc1tpbmRleF0uc3Vic3RyaW5nKDMsIHRva2Vuc1tpbmRleF0ubGVuZ3RoIC0gMSkudHJpbSgpKTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZWQgZG90dGVkIG5vdGF0aW9uIGFiYnJldmlhdGlvbnMuXG4gICAgICAgICAgICAgICAgaWYgKC88Ly50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvdHRlZCA9IC10b2tlbnNbaW5kZXgrK10ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC8+Ly50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvdHRlZCA9IHRva2Vuc1tpbmRleCsrXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL15cXChcXGQrKD86OlxcZCspKi8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICBiZWF0bGV0ID0gcGFyc2VCZWF0bGV0KHRva2Vuc1tpbmRleCsrXSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL15bIStdLipbIStdJC8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZURlY29yYXRpb24odG9rZW5zW2luZGV4KytdLCBhY2NlbnQpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9eLj9cIi4qXCIkLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBkb3VibGUtcXVvdGVkIHRva2VucyAoY2hvcmRzIGFuZCBnZW5lcmFsIHRleHQgYW5ub3RhdGlvbnMpLlxuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKC9eWygpXSQvLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2Vuc1tpbmRleCsrXSA9PSBcIihcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjZW50LnNsdXJyZWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VudC5zbHVycmVkIC09IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWNjZW50LnNsdXJyZWQgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY2VudC5zbHVycmVkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5zdGVtcyAmJiBjb250ZXh0LnN0ZW1zLmxlbmd0aCA+PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBsYXN0IG5vdGVzIGluIGEgc2x1ciBhcmUgbm90IHNsdXJyZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsdXJTdGVtKGNvbnRleHQuc3RlbXNbY29udGV4dC5zdGVtcy5sZW5ndGggLSAxXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIG1lYXN1cmUgbWFya2luZ3MgYnkgY2xlYXJpbmcgYWNjaWRlbnRhbHMuXG4gICAgICAgICAgICAgICAgaWYgKC9cXHwvLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0IGluIGFjY2VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5nbGUtbGV0dGVyIGFjY2VudCBwcm9wZXJ0aWVzIGFyZSBub3RlIGFjY2lkZW50YWxzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhY2NlbnRbdF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZCA9IHBhcnNlU3RlbSh0b2tlbnMsIGluZGV4LCBrZXksIGFjY2VudCk7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bnBhcnNhYmxlIGJpdHNcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGEgcGFyc2VkIHN0ZW0uXG4gICAgICAgICAgICAgICAgaWYgKGJlYXRsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2NhbGVTdGVtKHBhcnNlZC5zdGVtLCBiZWF0bGV0LnRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBiZWF0bGV0LmNvdW50IC09IDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYmVhdGxldC5jb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVhdGxldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgc3luY29wYXRlZCB3aXRoID4gb3IgPCBub3RhdGlvbiwgc2hpZnQgcGFydCBvZiBhIGJlYXRcbiAgICAgICAgICAgICAgICAvLyBiZXR3ZWVuIHRoaXMgc3RlbSBhbmQgdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgICAgICAgICBpZiAoZG90dGVkICYmIGNvbnRleHQuc3RlbXMgJiYgY29udGV4dC5zdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvdHRlZCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoMSAtIE1hdGgucG93KDAuNSwgZG90dGVkKSkgKiBwYXJzZWQuc3RlbS50aW1lO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChNYXRoLnBvdygwLjUsIC1kb3R0ZWQpIC0gMSkgKiBjb250ZXh0LnN0ZW1zW2NvbnRleHQuc3RlbXMubGVuZ3RoIC0gMV0udGltZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzeW5jb3BhdGVTdGVtKGNvbnRleHQuc3RlbXNbY29udGV4dC5zdGVtcy5sZW5ndGggLSAxXSwgdCk7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNvcGF0ZVN0ZW0ocGFyc2VkLnN0ZW0sIC10KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZG90dGVkID0gMDtcbiAgICAgICAgICAgICAgICAvLyBTbHVyIGFsbCB0aGUgbm90ZXMgY29udGFpbmVkIHdpdGhpbiBhIHN0cmVtLlxuICAgICAgICAgICAgICAgIGlmIChhY2NlbnQuc2x1cnJlZCkge1xuICAgICAgICAgICAgICAgICAgICBzbHVyU3RlbShwYXJzZWQuc3RlbSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IGEgZGVmYXVsdCB2b2ljZSBpZiB3ZSdyZSBub3QgaW4gYSB2b2ljZSB5ZXQuXG4gICAgICAgICAgICAgICAgaWYgKGNvbnRleHQgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydFZvaWNlQ29udGV4dChmaXJzdFZvaWNlTmFtZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoXCJzdGVtc1wiIGluIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuc3RlbXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBzdGVtIHRvIHRoZSBzZXF1ZW5jZSBvZiBzdGVtcyBmb3IgdGhpcyB2b2ljZS5cbiAgICAgICAgICAgICAgICBjb250ZXh0LnN0ZW1zLnB1c2gocGFyc2VkLnN0ZW0pO1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgdGhlIHBhcnNpbmcgaW5kZXggc2luY2UgYSBzdGVtIGlzIG11bHRpcGxlIHRva2Vucy5cbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlZC5pbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFBhcnNlIE06IGxpbmVzLiAgXCIzLzRcIiBpcyAzLzQgdGltZSBhbmQgXCJDXCIgaXMgNC80IChjb21tb24pIHRpbWUuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlTWV0ZXIobWxpbmUsIGJlYXRpbmZvKSB7XG4gICAgICAgICAgICB2YXIgZCA9IC9eQy8udGVzdChtbGluZSkgPyA0IC8gNCA6IGR1cmF0aW9uVG9UaW1lKG1saW5lKTtcbiAgICAgICAgICAgIGlmICghZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYmVhdGluZm8udW5pdG5vdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZCA8IDAuNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVhdGluZm8udW5pdG5vdGUgPSAxIC8gMTY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYmVhdGluZm8udW5pdG5vdGUgPSAxIC8gODtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2UgTDogbGluZXMsIGUuZy4sIFwiMS84XCIuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlVW5pdE5vdGUobGxpbmUsIGJlYXRpbmZvKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGR1cmF0aW9uVG9UaW1lKGxsaW5lKTtcbiAgICAgICAgICAgIGlmICghZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlYXRpbmZvLnVuaXRub3RlID0gZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZSBROiBsaW5lLCBlLmcuLCBcIjEvND02NlwiLlxuICAgICAgICBmdW5jdGlvbiBwYXJzZVRlbXBvKHFsaW5lLCBiZWF0aW5mbykge1xuICAgICAgICAgICAgdmFyIHBhcnRzID0gcWxpbmUuc3BsaXQoL1xccyt8PS8pLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgdW5pdCA9IG51bGwsXG4gICAgICAgICAgICAgICAgdGVtcG8gPSBudWxsO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgLy8gSXQgY291bGQgYmUgcmV2ZXJzZWQsIGxpa2UgXCI2Nj0xLzRcIiwgb3IganVzdCBcIjEyMFwiLCBzb1xuICAgICAgICAgICAgICAgIC8vIGRldGVybWluZSB3aGF0IGlzIGdvaW5nIG9uIGJ5IGxvb2tpbmcgZm9yIGEgc2xhc2ggZXRjLlxuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1tqXS5pbmRleE9mKFwiL1wiKSA+PSAwIHx8IC9eWzEtNF0kLy50ZXN0KHBhcnRzW2pdKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgbm90ZS11bml0IChlLmcuLCAxLzQpLlxuICAgICAgICAgICAgICAgICAgICB1bml0ID0gdW5pdCB8fCBkdXJhdGlvblRvVGltZShwYXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHRlbXBvLW51bWJlciAoZS5nLiwgMTIwKVxuICAgICAgICAgICAgICAgICAgICB0ZW1wbyA9IHRlbXBvIHx8IE51bWJlcihwYXJ0c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVuaXQpIHtcbiAgICAgICAgICAgICAgICBiZWF0aW5mby51bml0YmVhdCA9IHVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGVtcG8pIHtcbiAgICAgICAgICAgICAgICBiZWF0aW5mby50ZW1wbyA9IHRlbXBvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJ1biB0aHJvdWdoIGFsbCB0aGUgbm90ZXMsIGFkZGluZyB1cCB0aW1lIGZvciB0aWVkIG5vdGVzLFxuICAgICAgICAvLyBhbmQgbWFya2luZyBub3RlcyB0aGF0IHdlcmUgaGVsZCBvdmVyIHdpdGggaG9sZG92ZXIgPSB0cnVlLlxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzVGllcyhzdGVtcykge1xuICAgICAgICAgICAgdmFyIHRpZWQgPSB7fSxcbiAgICAgICAgICAgICAgICBuZXh0VGllZCxcbiAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgbm90ZSxcbiAgICAgICAgICAgICAgICBmaXJzdE5vdGU7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RlbXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBuZXh0VGllZCA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBzdGVtc1tqXS5ub3Rlcy5sZW5ndGg7ICsraykge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdE5vdGUgPSBub3RlID0gc3RlbXNbal0ubm90ZXNba107XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aWVkLmhhc093blByb3BlcnR5KG5vdGUucGl0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQaXRjaCB3YXMgdGllZCBmcm9tIGJlZm9yZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Tm90ZSA9IHRpZWRbbm90ZS5waXRjaF07IC8vIEdldCB0aGUgZWFybGllc3Qgbm90ZSBpbiB0aGUgdGllLlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3ROb3RlLnRpbWUgKz0gbm90ZS50aW1lOyAvLyBFeHRlbmQgaXRzIHRpbWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlLmhvbGRvdmVyID0gdHJ1ZTsgLy8gU2lsZW5jZSB0aGlzIG5vdGUgYXMgYSBob2xkb3Zlci5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobm90ZS50aWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgbm90ZSBpcyB0aWVkIHdpdGggdGhlIG5leHQuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0VGllZFtub3RlLnBpdGNoXSA9IGZpcnN0Tm90ZTsgLy8gU2F2ZSBpdCBhd2F5LlxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRpZWQgPSBuZXh0VGllZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXR1cm5zIGEgbWFwIG9mIEEtRyAtPiBhY2NpZGVudGFscywgYWNjb3JkaW5nIHRvIHRoZSBrZXkgc2lnbmF0dXJlLlxuICAgICAgICAvLyBXaGVuIG4gaXMgemVybywgdGhlcmUgYXJlIG5vIGFjY2lkZW50YWxzIChlLmcuLCBDIG1ham9yIG9yIEEgbWlub3IpLlxuICAgICAgICAvLyBXaGVuIG4gaXMgcG9zaXRpdmUsIHRoZXJlIGFyZSBuIHNoYXJwcyAoZS5nLiwgZm9yIEcgbWFqb3IsIG4gPSAxKS5cbiAgICAgICAgLy8gV2hlbiBuIGlzIG5lZ2F0aXZlLCB0aGVyZSBhcmUgLW4gZmxhdHMgKGUuZy4sIGZvciBGIG1ham9yLCBuID0gLTEpLlxuICAgICAgICBmdW5jdGlvbiBhY2NpZGVudGFscyhuKSB7XG4gICAgICAgICAgICB2YXIgc2hhcnBzID0gXCJGQ0dEQUVCXCIsXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge30sXG4gICAgICAgICAgICAgICAgajtcbiAgICAgICAgICAgIGlmICghbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc2hhcnBzLlxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBuICYmIGogPCA3OyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W3NoYXJwcy5jaGFyQXQoaildID0gXCJeXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGbGF0cyBhcmUgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPiBuICYmIGogPiAtNzsgLS1qKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtzaGFycHMuY2hhckF0KDYgKyBqKV0gPSBcIl9cIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIC8vIERlY29kZXMgdGhlIGtleSBzaWduYXR1cmUgbGluZSAoZS5nLiwgSzogQyNtKSBhdCB0aGUgZnJvbnQgb2YgYW4gQUJDIHR1bmUuXG4gICAgICAgIC8vIFN1cHBvcnRzIHRoZSB3aG9sZSByYW5nZSBvZiBzY2FsZSBzeXN0ZW1zIGxpc3RlZCBpbiB0aGUgQUJDIHNwZWMuXG4gICAgICAgIGZ1bmN0aW9uIGtleXNpZyhrZXluYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWtleW5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2tleSxcbiAgICAgICAgICAgICAgICBzaWdjb2RlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFqb3JcbiAgICAgICAgICAgICAgICAgICAgXCJjI1wiOiA3LFxuICAgICAgICAgICAgICAgICAgICBcImYjXCI6IDYsXG4gICAgICAgICAgICAgICAgICAgIGI6IDUsXG4gICAgICAgICAgICAgICAgICAgIGU6IDQsXG4gICAgICAgICAgICAgICAgICAgIGE6IDMsXG4gICAgICAgICAgICAgICAgICAgIGQ6IDIsXG4gICAgICAgICAgICAgICAgICAgIGc6IDEsXG4gICAgICAgICAgICAgICAgICAgIGM6IDAsXG4gICAgICAgICAgICAgICAgICAgIGY6IC0xLFxuICAgICAgICAgICAgICAgICAgICBiYjogLTIsXG4gICAgICAgICAgICAgICAgICAgIGViOiAtMyxcbiAgICAgICAgICAgICAgICAgICAgYWI6IC00LFxuICAgICAgICAgICAgICAgICAgICBkYjogLTUsXG4gICAgICAgICAgICAgICAgICAgIGdiOiAtNixcbiAgICAgICAgICAgICAgICAgICAgY2I6IC03LFxuICAgICAgICAgICAgICAgICAgICAvLyBNaW5vclxuICAgICAgICAgICAgICAgICAgICBcImEjbVwiOiA3LFxuICAgICAgICAgICAgICAgICAgICBcImQjbVwiOiA2LFxuICAgICAgICAgICAgICAgICAgICBcImcjbVwiOiA1LFxuICAgICAgICAgICAgICAgICAgICBcImMjbVwiOiA0LFxuICAgICAgICAgICAgICAgICAgICBcImYjbVwiOiAzLFxuICAgICAgICAgICAgICAgICAgICBibTogMixcbiAgICAgICAgICAgICAgICAgICAgZW06IDEsXG4gICAgICAgICAgICAgICAgICAgIGFtOiAwLFxuICAgICAgICAgICAgICAgICAgICBkbTogLTEsXG4gICAgICAgICAgICAgICAgICAgIGdtOiAtMixcbiAgICAgICAgICAgICAgICAgICAgY206IC0zLFxuICAgICAgICAgICAgICAgICAgICBmbTogLTQsXG4gICAgICAgICAgICAgICAgICAgIGJibTogLTUsXG4gICAgICAgICAgICAgICAgICAgIGVibTogLTYsXG4gICAgICAgICAgICAgICAgICAgIGFibTogLTcsXG4gICAgICAgICAgICAgICAgICAgIC8vIE1peG9seWRpYW5cbiAgICAgICAgICAgICAgICAgICAgXCJnI21peFwiOiA3LFxuICAgICAgICAgICAgICAgICAgICBcImMjbWl4XCI6IDYsXG4gICAgICAgICAgICAgICAgICAgIFwiZiNtaXhcIjogNSxcbiAgICAgICAgICAgICAgICAgICAgYm1peDogNCxcbiAgICAgICAgICAgICAgICAgICAgZW1peDogMyxcbiAgICAgICAgICAgICAgICAgICAgYW1peDogMixcbiAgICAgICAgICAgICAgICAgICAgZG1peDogMSxcbiAgICAgICAgICAgICAgICAgICAgZ21peDogMCxcbiAgICAgICAgICAgICAgICAgICAgY21peDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGZtaXg6IC0yLFxuICAgICAgICAgICAgICAgICAgICBiYm1peDogLTMsXG4gICAgICAgICAgICAgICAgICAgIGVibWl4OiAtNCxcbiAgICAgICAgICAgICAgICAgICAgYWJtaXg6IC01LFxuICAgICAgICAgICAgICAgICAgICBkYm1peDogLTYsXG4gICAgICAgICAgICAgICAgICAgIGdibWl4OiAtNyxcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9yaWFuXG4gICAgICAgICAgICAgICAgICAgIFwiZCNkb3JcIjogNyxcbiAgICAgICAgICAgICAgICAgICAgXCJnI2RvclwiOiA2LFxuICAgICAgICAgICAgICAgICAgICBcImMjZG9yXCI6IDUsXG4gICAgICAgICAgICAgICAgICAgIFwiZiNkb3JcIjogNCxcbiAgICAgICAgICAgICAgICAgICAgYmRvcjogMyxcbiAgICAgICAgICAgICAgICAgICAgZWRvcjogMixcbiAgICAgICAgICAgICAgICAgICAgYWRvcjogMSxcbiAgICAgICAgICAgICAgICAgICAgZGRvcjogMCxcbiAgICAgICAgICAgICAgICAgICAgZ2RvcjogLTEsXG4gICAgICAgICAgICAgICAgICAgIGNkb3I6IC0yLFxuICAgICAgICAgICAgICAgICAgICBmZG9yOiAtMyxcbiAgICAgICAgICAgICAgICAgICAgYmJkb3I6IC00LFxuICAgICAgICAgICAgICAgICAgICBlYmRvcjogLTUsXG4gICAgICAgICAgICAgICAgICAgIGFiZG9yOiAtNixcbiAgICAgICAgICAgICAgICAgICAgZGJkb3I6IC03LFxuICAgICAgICAgICAgICAgICAgICAvLyBQaHJ5Z2lhblxuICAgICAgICAgICAgICAgICAgICBcImUjcGhyXCI6IDcsXG4gICAgICAgICAgICAgICAgICAgIFwiYSNwaHJcIjogNixcbiAgICAgICAgICAgICAgICAgICAgXCJkI3BoclwiOiA1LFxuICAgICAgICAgICAgICAgICAgICBcImcjcGhyXCI6IDQsXG4gICAgICAgICAgICAgICAgICAgIFwiYyNwaHJcIjogMyxcbiAgICAgICAgICAgICAgICAgICAgXCJmI3BoclwiOiAyLFxuICAgICAgICAgICAgICAgICAgICBicGhyOiAxLFxuICAgICAgICAgICAgICAgICAgICBlcGhyOiAwLFxuICAgICAgICAgICAgICAgICAgICBhcGhyOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgZHBocjogLTIsXG4gICAgICAgICAgICAgICAgICAgIGdwaHI6IC0zLFxuICAgICAgICAgICAgICAgICAgICBjcGhyOiAtNCxcbiAgICAgICAgICAgICAgICAgICAgZnBocjogLTUsXG4gICAgICAgICAgICAgICAgICAgIGJicGhyOiAtNixcbiAgICAgICAgICAgICAgICAgICAgZWJwaHI6IC03LFxuICAgICAgICAgICAgICAgICAgICAvLyBMeWRpYW5cbiAgICAgICAgICAgICAgICAgICAgXCJmI2x5ZFwiOiA3LFxuICAgICAgICAgICAgICAgICAgICBibHlkOiA2LFxuICAgICAgICAgICAgICAgICAgICBlbHlkOiA1LFxuICAgICAgICAgICAgICAgICAgICBhbHlkOiA0LFxuICAgICAgICAgICAgICAgICAgICBkbHlkOiAzLFxuICAgICAgICAgICAgICAgICAgICBnbHlkOiAyLFxuICAgICAgICAgICAgICAgICAgICBjbHlkOiAxLFxuICAgICAgICAgICAgICAgICAgICBmbHlkOiAwLFxuICAgICAgICAgICAgICAgICAgICBiYmx5ZDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGVibHlkOiAtMixcbiAgICAgICAgICAgICAgICAgICAgYWJseWQ6IC0zLFxuICAgICAgICAgICAgICAgICAgICBkYmx5ZDogLTQsXG4gICAgICAgICAgICAgICAgICAgIGdibHlkOiAtNSxcbiAgICAgICAgICAgICAgICAgICAgY2JseWQ6IC02LFxuICAgICAgICAgICAgICAgICAgICBmYmx5ZDogLTcsXG4gICAgICAgICAgICAgICAgICAgIC8vIExvY3JpYW5cbiAgICAgICAgICAgICAgICAgICAgXCJiI2xvY1wiOiA3LFxuICAgICAgICAgICAgICAgICAgICBcImUjbG9jXCI6IDYsXG4gICAgICAgICAgICAgICAgICAgIFwiYSNsb2NcIjogNSxcbiAgICAgICAgICAgICAgICAgICAgXCJkI2xvY1wiOiA0LFxuICAgICAgICAgICAgICAgICAgICBcImcjbG9jXCI6IDMsXG4gICAgICAgICAgICAgICAgICAgIFwiYyNsb2NcIjogMixcbiAgICAgICAgICAgICAgICAgICAgXCJmI2xvY1wiOiAxLFxuICAgICAgICAgICAgICAgICAgICBibG9jOiAwLFxuICAgICAgICAgICAgICAgICAgICBlbG9jOiAtMSxcbiAgICAgICAgICAgICAgICAgICAgYWxvYzogLTIsXG4gICAgICAgICAgICAgICAgICAgIGRsb2M6IC0zLFxuICAgICAgICAgICAgICAgICAgICBnbG9jOiAtNCxcbiAgICAgICAgICAgICAgICAgICAgY2xvYzogLTUsXG4gICAgICAgICAgICAgICAgICAgIGZsb2M6IC02LFxuICAgICAgICAgICAgICAgICAgICBiYmxvYzogLTcsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBrID0ga2V5bmFtZS5yZXBsYWNlKC9cXHMrL2csIFwiXCIpLnRvTG93ZXJDYXNlKCkuc3Vic3RyKDAsIDUpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gay5tYXRjaCgvbWFqfG1pbnxtaXh8ZG9yfHBocnxseWR8bG9jfG0vKTtcbiAgICAgICAgICAgIGlmIChzY2FsZSkge1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSA9PSBcIm1halwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGtrZXkgPSBrLnN1YnN0cigwLCBzY2FsZS5pbmRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY2FsZSA9PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGtrZXkgPSBrLnN1YnN0cigwLCBzY2FsZS5pbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGtrZXkgPSBrLnN1YnN0cigwLCBzY2FsZS5pbmRleCArIHNjYWxlWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBra2V5ID0gL15bYS1nXVsjYl0/Ly5leGVjKGspIHx8IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gYWNjaWRlbnRhbHMoc2lnY29kZXNba2tleV0pO1xuICAgICAgICAgICAgdmFyIGV4dHJhcyA9IGtleW5hbWUuc3Vic3RyKGtrZXkubGVuZ3RoKS5tYXRjaCgvKF8rfD18XFxeKylbYS1nXS9naSk7XG4gICAgICAgICAgICBpZiAoZXh0cmFzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBleHRyYXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5vdGUgPSBleHRyYXNbal0uY2hhckF0KGV4dHJhc1tqXS5sZW5ndGggLSAxKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXh0cmFzW2pdLmNoYXJBdCgwKSA9PSBcIj1cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHJlc3VsdFtub3RlXTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtub3RlXSA9IGV4dHJhc1tqXS5zdWJzdHIoMCwgZXh0cmFzW2pdLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGRpdGl2ZWx5IGFkanVzdHMgdGhlIGJlYXRzIGZvciBhIHN0ZW0gYW5kIHRoZSBjb250YWluZWQgbm90ZXMuXG4gICAgICAgIGZ1bmN0aW9uIHN5bmNvcGF0ZVN0ZW0oc3RlbSwgdCkge1xuICAgICAgICAgICAgdmFyIGosXG4gICAgICAgICAgICAgICAgbm90ZSxcbiAgICAgICAgICAgICAgICBzdGVtdGltZSA9IHN0ZW0udGltZSxcbiAgICAgICAgICAgICAgICBuZXd0aW1lID0gc3RlbXRpbWUgKyB0O1xuICAgICAgICAgICAgc3RlbS50aW1lID0gbmV3dGltZTtcbiAgICAgICAgICAgIHN5bmNvcGF0ZVN0ZW07XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgc3RlbS5ub3Rlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIG5vdGUgPSBzdGVtLm5vdGVzW2pdO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWRqdXN0IGEgbm90ZSdzIGR1cmF0aW9uIGlmIGl0IG1hdGNoZWQgdGhlIHN0ZW0ncyBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgICBpZiAobm90ZS50aW1lID09IHN0ZW10aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGUudGltZSA9IG5ld3RpbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmtzIGV2ZXJ5dGhpbmcgaW4gdGhlIHN0ZW0gd2l0aCB0aGUgc2x1ciBhdHRyaWJ1dGUgKG9yIGRlbGV0ZXMgaXQpLlxuICAgICAgICBmdW5jdGlvbiBzbHVyU3RlbShzdGVtLCBhZGRTbHVyKSB7XG4gICAgICAgICAgICB2YXIgaiwgbm90ZTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBzdGVtLm5vdGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgbm90ZSA9IHN0ZW0ubm90ZXNbal07XG4gICAgICAgICAgICAgICAgaWYgKGFkZFNsdXIpIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZS5zbHVycmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG5vdGUuc2x1cnJlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbm90ZS5zbHVycmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTY2FsZXMgdGhlIGJlYXRzIGZvciBhIHN0ZW0gYW5kIHRoZSBjb250YWluZWQgbm90ZXMuXG4gICAgICAgIGZ1bmN0aW9uIHNjYWxlU3RlbShzdGVtLCBzKSB7XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIHN0ZW0udGltZSAqPSBzO1xuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0ZW0ubm90ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBzdGVtLm5vdGVzW2pdLnRpbWUgKj0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQYXJzZXMgbm90YXRpb24gb2YgdGhlIGZvcm0gKDMgb3IgKDU6MjoxMCwgd2hpY2ggbWVhbnMgdG8gZG9cbiAgICAgICAgLy8gdGhlIGZvbGxvd2luZyAzIG5vdGVzIGluIHRoZSBzcGFjZSBvZiAyIG5vdGVzLCBvciB0byBkbyB0aGUgZm9sbG93aW5nXG4gICAgICAgIC8vIDEwIG5vdGVzIGF0IHRoZSByYXRlIG9mIDUgbm90ZXMgcGVyIDIgYmVhdHMuXG4gICAgICAgIGZ1bmN0aW9uIHBhcnNlQmVhdGxldCh0b2tlbikge1xuICAgICAgICAgICAgdmFyIG0gPSAvXlxcKChcXGQrKSg/OjooXFxkKykoPzo6KFxcZCspKT8pPyQvLmV4ZWModG9rZW4pO1xuICAgICAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY291bnQgPSBOdW1iZXIobVsxXSksXG4gICAgICAgICAgICAgICAgYmVhdHMgPSBOdW1iZXIobVsyXSkgfHwgMixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IE51bWJlcihtWzNdKSB8fCBjb3VudDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGltZTogYmVhdHMgLyBjb3VudCxcbiAgICAgICAgICAgICAgICBjb3VudDogZHVyYXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhcnNlICFwcHAhIG1hcmtpbmdzLlxuICAgICAgICBmdW5jdGlvbiBwYXJzZURlY29yYXRpb24odG9rZW4sIGFjY2VudCkge1xuICAgICAgICAgICAgaWYgKHRva2VuLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2tlbiA9IHRva2VuLnN1YnN0cmluZygxLCB0b2tlbi5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgIHN3aXRjaCAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwicHBwcFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJwcHBcIjpcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50LmR5bmFtaWNzID0gMC4yO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicHBcIjpcbiAgICAgICAgICAgICAgICAgICAgYWNjZW50LmR5bmFtaWNzID0gMC40O1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicFwiOlxuICAgICAgICAgICAgICAgICAgICBhY2NlbnQuZHluYW1pY3MgPSAwLjY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtcFwiOlxuICAgICAgICAgICAgICAgICAgICBhY2NlbnQuZHluYW1pY3MgPSAwLjg7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtZlwiOlxuICAgICAgICAgICAgICAgICAgICBhY2NlbnQuZHluYW1pY3MgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VudC5keW5hbWljcyA9IDEuMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZmXCI6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VudC5keW5hbWljcyA9IDEuNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImZmZlwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJmZmZmXCI6XG4gICAgICAgICAgICAgICAgICAgIGFjY2VudC5keW5hbWljcyA9IDEuNTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFyc2VzIGEgc3RlbSwgd2hpY2ggbWF5IGJlIGEgc2luZ2xlIG5vdGUsIG9yIHdoaWNoIG1heSBiZVxuICAgICAgICAvLyBhIGNob3JkZWQgbm90ZS5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VTdGVtKHRva2VucywgaW5kZXgsIGtleSwgYWNjZW50KSB7XG4gICAgICAgICAgICB2YXIgbm90ZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IFwiXCIsXG4gICAgICAgICAgICAgICAgc3RhY2NhdG8gPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBub3RlRHVyYXRpb24sXG4gICAgICAgICAgICAgICAgbm90ZVRpbWUsXG4gICAgICAgICAgICAgICAgdmVsb2NpdHksXG4gICAgICAgICAgICAgICAgbGFzdE5vdGUgPSBudWxsLFxuICAgICAgICAgICAgICAgIG1pblN0ZW1UaW1lID0gSW5maW5pdHksXG4gICAgICAgICAgICAgICAgajtcbiAgICAgICAgICAgIC8vIEEgc2luZ2xlIHN0YWNjYXRvIG1hcmtpbmcgYXBwbGllcyB0byB0aGUgZW50aXJlIHN0ZW0uXG4gICAgICAgICAgICBpZiAoaW5kZXggPCB0b2tlbnMubGVuZ3RoICYmIFwiLlwiID09IHRva2Vuc1tpbmRleF0pIHtcbiAgICAgICAgICAgICAgICBzdGFjY2F0byA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRva2Vucy5sZW5ndGggJiYgdG9rZW5zW2luZGV4XSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAgIC8vIERlYWwgd2l0aCBbQ0VHXSBjaG9yZGVkIG5vdGF0aW9uLlxuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgLy8gU2NhbiBub3RlcyB3aXRoaW4gdGhlIGNob3JkLlxuICAgICAgICAgICAgICAgIHdoaWxlIChpbmRleCA8IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWdub3JlIGFuZCBzcGFjZSBhbmQgJWNvbW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoL15bXFxzJV0vLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoL1tBLUdhLWddLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHcmFiIGEgcGl0Y2guXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Tm90ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwaXRjaDogYXBwbHlBY2NlbnQodG9rZW5zW2luZGV4KytdLCBrZXksIGFjY2VudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGllOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0Tm90ZS5mcmVxdWVuY3kgPSBVdGlscy5waXRjaFRvRnJlcXVlbmN5KGxhc3ROb3RlLnBpdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVzLnB1c2gobGFzdE5vdGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKC9beHpYWl0vLnRlc3QodG9rZW5zW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdyYWIgYSByZXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vdGUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcIi5cIiA9PSB0b2tlbnNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHN0YWNjYXRvIG1hcmsgYXBwbGllcyB0byB0aGUgZW50aXJlIHN0ZW0uXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGFjY2F0byA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdG9wIHBhcnNpbmcgdGhlIHN0ZW0gaWYgc29tZXRoaW5nIGlzIHVucmVjb2duaXplZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIGEgcGl0Y2ggb3IgcmVzdCwgbG9vayBmb3IgYSBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgdG9rZW5zLmxlbmd0aCAmJiAvXig/IVtcXHMlIV0pLipbXFxkXFwvXS8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZUR1cmF0aW9uID0gdG9rZW5zW2luZGV4KytdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZVRpbWUgPSBkdXJhdGlvblRvVGltZShub3RlRHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZUR1cmF0aW9uID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVUaW1lID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGEgbm90ZSAobm90IGEgcmVzdCksIHN0b3JlIHRoZSBkdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBpZiAobGFzdE5vdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb3RlLmR1cmF0aW9uID0gbm90ZUR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vdGUudGltZSA9IG5vdGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gYSBzdGVtIGhhcyBtb3JlIHRoYW4gb25lIGR1cmF0aW9uLCB1c2UgdGhlIHNob3J0ZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIG9uZSBmb3IgdGltaW5nLiBUaGUgc3RhbmRhcmQgc2F5cyB0byBwaWNrIHRoZSBmaXJzdCBvbmUsXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBpbiBwcmFjdGljZSwgdHJhbnNjcmliZWQgbXVzaWMgb25saW5lIHNlZW1zIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvbGxvdyB0aGUgcnVsZSB0aGF0IHRoZSBzdGVtJ3MgZHVyYXRpb24gaXMgZGV0ZXJtaW5lZFxuICAgICAgICAgICAgICAgICAgICAvLyBieSB0aGUgc2hvcnRlc3QgY29udGFpbmVkIGR1cmF0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAobm90ZVRpbWUgJiYgbm90ZVRpbWUgPCBtaW5TdGVtVGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb24gPSBub3RlRHVyYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5TdGVtVGltZSA9IG5vdGVUaW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFmdGVyIGEgZHVyYXRpb24sIGxvb2sgZm9yIGEgdGllIG1hcmsuICBJbmRpdmlkdWFsIG5vdGVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhIHN0ZW0gY2FuIGJlIHRpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHRva2Vucy5sZW5ndGggJiYgXCItXCIgPT0gdG9rZW5zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3ROb3RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZXNbbm90ZXMubGVuZ3RoIC0gMV0udGllID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVGhlIGxhc3QgdGhpbmcgaW4gYSBjaG9yZCBzaG91bGQgYmUgYSBdLiAgSWYgaXQgaXNuJ3QsIHRoZW5cbiAgICAgICAgICAgICAgICAvLyB0aGlzIGRvZXNuJ3QgbG9vayBsaWtlIGEgc3RlbSBhZnRlciBhbGwsIGFuZCByZXR1cm4gbnVsbC5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW5zW2luZGV4XSAhPSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPCB0b2tlbnMubGVuZ3RoICYmIC9bQS1HYS1nXS8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIC8vIEdyYWIgYSBzaW5nbGUgbm90ZS5cbiAgICAgICAgICAgICAgICBsYXN0Tm90ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcGl0Y2g6IGFwcGx5QWNjZW50KHRva2Vuc1tpbmRleCsrXSwga2V5LCBhY2NlbnQpLFxuICAgICAgICAgICAgICAgICAgICB0aWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgdGltZTogMSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxhc3ROb3RlLmZyZXF1ZW5jeSA9IFV0aWxzLnBpdGNoVG9GcmVxdWVuY3kobGFzdE5vdGUucGl0Y2gpO1xuICAgICAgICAgICAgICAgIG5vdGVzLnB1c2gobGFzdE5vdGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA8IHRva2Vucy5sZW5ndGggJiYgL15beHpYWl0kLy50ZXN0KHRva2Vuc1tpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgLy8gR3JhYiBhIHJlc3QgLSBubyBwaXRjaC5cbiAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2UgZG9uJ3QgcmVjb2duaXplIC0gbm90IGEgc3RlbS5cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJpZ2h0IGFmdGVyIGEgW2Nob3JkXSwgbm90ZSwgb3IgcmVzdCwgbG9vayBmb3IgYSBkdXJhdGlvbiBtYXJraW5nLlxuICAgICAgICAgICAgaWYgKGluZGV4IDwgdG9rZW5zLmxlbmd0aCAmJiAvXig/IVtcXHMlIV0pLipbXFxkXFwvXS8udGVzdCh0b2tlbnNbaW5kZXhdKSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gdG9rZW5zW2luZGV4KytdO1xuICAgICAgICAgICAgICAgIG5vdGVUaW1lID0gZHVyYXRpb25Ub1RpbWUoZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IHRoZSBkdXJhdGlvbiB0byBhbGwgdGhlIG50b2VzIGluIHRoZSBzdGVtLlxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHNwZWMgc3VnZ2VzdHMgbXVsdGlwbHlpbmcgdGhpcyBkdXJhdGlvbiwgYnV0IHRoYXRcbiAgICAgICAgICAgICAgICAvLyBpZGlvbSBpcyBub3Qgc2VlbiAoc28gZmFyKSBpbiBwcmFjdGljZS5cbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbm90ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXNbal0uZHVyYXRpb24gPSBkdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXNbal0udGltZSA9IG5vdGVUaW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZW4gbG9vayBmb3IgYSB0cmFpbGluZyB0aWUgbWFya2luZy4gIFdpbGwgdGllIGV2ZXJ5IG5vdGUgaW4gYSBjaG9yZC5cbiAgICAgICAgICAgIGlmIChpbmRleCA8IHRva2Vucy5sZW5ndGggJiYgXCItXCIgPT0gdG9rZW5zW2luZGV4XSkge1xuICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IG5vdGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGVzW2pdLnRpZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY2VudC5keW5hbWljcykge1xuICAgICAgICAgICAgICAgIHZlbG9jaXR5ID0gYWNjZW50LmR5bmFtaWNzO1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBub3Rlcy5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBub3Rlc1tqXS52ZWxvY2l0eSA9IHZlbG9jaXR5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICAgICAgICAgIHN0ZW06IHtcbiAgICAgICAgICAgICAgICAgICAgbm90ZXM6IG5vdGVzLFxuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHN0YWNjYXRvOiBzdGFjY2F0byxcbiAgICAgICAgICAgICAgICAgICAgdGltZTogZHVyYXRpb25Ub1RpbWUoZHVyYXRpb24pLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZXMgcGl0Y2ggbWFya2luZ3MgYnkgc3RyaXBwaW5nIGxlYWRpbmcgPSBpZiBwcmVzZW50LlxuICAgICAgICBmdW5jdGlvbiBzdHJpcE5hdHVyYWwocGl0Y2gpIHtcbiAgICAgICAgICAgIGlmIChwaXRjaC5sZW5ndGggPiAwICYmIHBpdGNoLmNoYXJBdCgwKSA9PSBcIj1cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwaXRjaC5zdWJzdHIoMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGl0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJvY2Vzc2VzIGFuIGFjY2VudGVkIHBpdGNoLCBhdXRvbWF0aWNhbGx5IGFwcGx5aW5nIGFjY2lkZW50YWxzXG4gICAgICAgIC8vIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB3aXRoaW4gdGhlIG1lYXN1cmUsIGFuZCBhbHNvIHNhdmluZ1xuICAgICAgICAvLyBleHBsaWNpdCBhY2NpZGVudGFscyB0byBjb250aW51ZSB0byBhcHBseSBpbiB0aGUgbWVhc3VyZS5cbiAgICAgICAgZnVuY3Rpb24gYXBwbHlBY2NlbnQocGl0Y2gsIGtleSwgYWNjZW50KSB7XG4gICAgICAgICAgICB2YXIgbSA9IC9eKFxcXit8Xyt8PXwpKFtBLUdhLWddKSguKikkLy5leGVjKHBpdGNoKSxcbiAgICAgICAgICAgICAgICBsZXR0ZXI7XG4gICAgICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGl0Y2g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYW4gYWNjaWRlbnRhbCBpbiBvbmUgb2N0YXZlIGFwcGxpZXMgaW4gb3RoZXIgb2N0YXZlcy5cbiAgICAgICAgICAgIGxldHRlciA9IG1bMl0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIGlmIChtWzFdLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZXJlIGlzIGFuIGV4cGxpY2l0IGFjY2lkZW50YWwsIHRoZW4gcmVtZW1iZXIgaXQgZm9yXG4gICAgICAgICAgICAgICAgLy8gdGhlIHJlc3Qgb2YgdGhlIG1lYXN1cmUuXG4gICAgICAgICAgICAgICAgYWNjZW50W2xldHRlcl0gPSBtWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpcE5hdHVyYWwocGl0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFjY2VudC5oYXNPd25Qcm9wZXJ0eShsZXR0ZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gQWNjaWRlbnRhbHMgZnJvbSB0aGlzIG1lYXN1cmUgYXBwbHkgdG8gdW5hY2NlbnRlZCBub3Rlcy5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXBOYXR1cmFsKGFjY2VudFtsZXR0ZXJdICsgbVsyXSArIG1bM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleS5oYXNPd25Qcm9wZXJ0eShsZXR0ZXIpKSB7XG4gICAgICAgICAgICAgICAgLy8gS2V5IHNpZ25hdHVyZXMgYXBwbHkgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaXBOYXR1cmFsKGtleVtsZXR0ZXJdICsgbVsyXSArIG1bM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN0cmlwTmF0dXJhbChwaXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgYW4gQUJDIGR1cmF0aW9uIHRvIGEgbnVtYmVyIChlLmcuLCBcIi8zXCItPjAuMzMzIG9yIFwiMTEvMlwiLT4xLjUpLlxuICAgICAgICBmdW5jdGlvbiBkdXJhdGlvblRvVGltZShkdXJhdGlvbikge1xuICAgICAgICAgICAgdmFyIG0gPSAvXihcXGQqKSg/OlxcLyhcXGQqKSk/JHxeKFxcLyspJC8uZXhlYyhkdXJhdGlvbiksXG4gICAgICAgICAgICAgICAgbixcbiAgICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgICAgIGkgPSAwLFxuICAgICAgICAgICAgICAgIGlsZW47XG4gICAgICAgICAgICBpZiAoIW0pIHJldHVybjtcbiAgICAgICAgICAgIGlmIChtWzNdKSByZXR1cm4gTWF0aC5wb3coMC41LCBtWzNdLmxlbmd0aCk7XG4gICAgICAgICAgICBkID0gbVsyXSA/IHBhcnNlRmxvYXQobVsyXSkgOiAvXFwvLy50ZXN0KGR1cmF0aW9uKSA/IDIgOiAxO1xuICAgICAgICAgICAgLy8gSGFuZGxlIG1peGVkIGZyYXRpb25zOlxuICAgICAgICAgICAgaWxlbiA9IDA7XG4gICAgICAgICAgICBuID0gbVsxXSA/IHBhcnNlRmxvYXQobVsxXSkgOiAxO1xuICAgICAgICAgICAgaWYgKG1bMl0pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaWxlbiArIDEgPCBtWzFdLmxlbmd0aCAmJiBuID4gZCkge1xuICAgICAgICAgICAgICAgICAgICBpbGVuICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYXJzZUZsb2F0KG1bMV0uc3Vic3RyaW5nKDAsIGlsZW4pKTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHBhcnNlRmxvYXQobVsxXS5zdWJzdHJpbmcoaWxlbikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpICsgbiAvIGQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIElOU1RSVU1FTlRTXG4gICAgLy9cbiAgICAvLyBBbGwgZnVydGhlciBkZXRhaWxzIG9mIGF1ZGlvIGhhbmRsaW5nIGFyZSBlbmNhcHN1bGF0ZWQgaW4gdGhlIEluc3RydW1lbnRcbiAgICAvLyBjbGFzcywgd2hpY2gga25vd3MgaG93IHRvIHN5bnRoZXNpemUgYSBiYXNpYyB0aW1icmU7IGhvdyB0byBwbGF5IGFuZFxuICAgIC8vIHNjaGVkdWxlIGEgdG9uZTsgYW5kIGhvdyB0byBwYXJzZSBhbmQgc2VxdWVuY2UgYSBzb25nIHdyaXR0ZW4gaW4gQUJDXG4gICAgLy8gbm90YXRpb24uXG5cbiAgICAvLyBUaGUgY29uc3RydWN0b3IgYWNjZXB0cyBhIHRpbWJyZSBzdHJpbmcgb3Igb2JqZWN0LCBzcGVjaWZ5aW5nXG4gICAgLy8gaXRzIGRlZmF1bHQgc291bmQuICBUaGUgbWFpbiBtZWNoYW5pc21zIGluIEluc3RydW1lbnQgYXJlIGZvciBoYW5kbGluZ1xuICAgIC8vIHNlcXVlbmNpbmcgb2YgYSAocG90ZW50aWFsbHkgbGFyZ2UpIHNldCBvZiBub3RlcyBvdmVyIGEgKHBvdGVudGlhbGx5XG4gICAgLy8gbG9uZykgcGVyaW9kIG9mIHRpbWUuICBUaGUgb3ZlcmFsbCBzdHJhdGVneTpcbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICBFdmVudHM6ICAgICAgJ25vdGVvbicgICAgICAgICdub3Rlb2ZmJ1xuICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgfFxuICAgIC8vIHRvbmUoKS0ocXVpY2sgdG9uZXMpLT58IF9zdGFydFNldCAtLT58IF9maW5pc2hTZXQgLS0+fCBfY2xlYW51cFNldCAtLT58XG4gICAgLy8gICBcXCAgICAgICAgICAgICAgICAgICB8ICAvICAgICAgICAgICB8IFBsYXlpbmcgdG9uZXMgfCBEb25lIHRvbmVzICAgICB8XG4gICAgLy8gICAgXFwtLS0tIF9xdWV1ZSAtLS0tLS18LS8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gICAgLy8gICAgICBvZiBmdXR1cmUgdG9uZXMgIHwzIHNlY3MgYWhlYWQgc2VudCB0byBXZWJBdWRpbywgcmVtb3ZlZCB3aGVuIGRvbmVcbiAgICAvL1xuICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgcXVldWluZyBpcyB0byByZWR1Y2UgdGhlIGNvbXBsZXhpdHkgb2YgdGhlXG4gICAgLy8gbm9kZSBncmFwaCBzZW50IHRvIFdlYkF1ZGlvOiBhdCBhbnkgdGltZSwgV2ViQXVkaW8gaXMgb25seVxuICAgIC8vIHJlc3BvbnNpYmxlIGZvciBhYm91dCAyIHNlY29uZHMgb2YgbXVzaWMuICBJZiBhIGdyYXBoIHdpdGggdG9vXG4gICAgLy8gdG9vIG1hbnkgbm9kZXMgaXMgc2VudCB0byBXZWJBdWRpbyBhdCBvbmNlLCBvdXRwdXQgZGlzdG9ydHMgYmFkbHkuXG5cbiAgICBleHBvcnQgY2xhc3MgSW5zdHJ1bWVudCB7XG4gICAgICAgIHN0YXRpYyB0aW1lT2Zmc2V0ID0gMC4wNjI1OyAvLyBTZWNvbmRzIHRvIGRlbGF5IGFsbCBhdWRpYWJsZSB0aW1pbmcuXG4gICAgICAgIHN0YXRpYyBkZXF1ZXVlVGltZSA9IDAuNTsgLy8gU2Vjb25kcyBiZWZvcmUgYW4gZXZlbnQgdG8gcmVleGFtaW5lIHF1ZXVlLlxuICAgICAgICBzdGF0aWMgYnVmZmVyU2VjcyA9IDI7IC8vIFNlY29uZHMgYWhlYWQgdG8gcHV0IG5vdGVzIGluIFdlYkF1ZGlvLlxuICAgICAgICBzdGF0aWMgdG9uZUxlbmd0aCA9IDE7IC8vIERlZmF1bHQgZHVyYXRpb24gb2YgYSB0b25lLlxuICAgICAgICBzdGF0aWMgY2xlYW51cERlbGF5ID0gMC4xOyAvLyBTaWxlbnQgdGltZSBiZWZvcmUgZGlzY29ubmVjdGluZyBub2Rlcy5cblxuICAgICAgICAvLyBBY2NlcHRzIGVpdGhlciBhbiBBQkMgcGl0Y2ggb3IgYSBtaWRpIG51bWJlciBhbmQgY29udmVydHMgdG8gbWlkaS5cbiAgICAgICAgc3RhdGljIHBpdGNoVG9NaWRpKG4pIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnBpdGNoVG9NaWRpKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY2NlcHRzIGVpdGhlciBhbiBBQkMgcGl0Y2ggb3IgYSBtaWRpIG51bWJlciBhbmQgY29udmVydHMgdG8gQUJDIHBpdGNoLlxuICAgICAgICBzdGF0aWMgbWlkaVRvUGl0Y2gobikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMubWlkaVRvUGl0Y2gobik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIF9vdXQ7XG4gICAgICAgIF9hdG9wO1xuICAgICAgICBfdGltYnJlO1xuICAgICAgICBfcXVldWU7XG4gICAgICAgIF9taW5RdWV1ZVRpbWU7XG4gICAgICAgIF9tYXhTY2hlZHVsZWRUaW1lO1xuICAgICAgICBfdW5zb3J0ZWRRdWV1ZTtcbiAgICAgICAgX3N0YXJ0U2V0O1xuICAgICAgICBfZmluaXNoU2V0O1xuICAgICAgICBfY2xlYW51cFNldDtcbiAgICAgICAgX2NhbGxiYWNrU2V0O1xuICAgICAgICBfaGFuZGxlcnM7XG4gICAgICAgIF9ub3c7XG4gICAgICAgIF9wb2xsVGltZXI7XG5cbiAgICAgICAgY29uc3RydWN0b3Iob3B0aW9ucz86IGFueSkge1xuICAgICAgICAgICAgdGhpcy5fYXRvcCA9IFV0aWxzLmdldEF1ZGlvVG9wKCk7IC8vIEF1ZGlvIGNvbnRleHQuXG4gICAgICAgICAgICB0aGlzLl90aW1icmUgPSBVdGlscy5tYWtlVGltYnJlKG9wdGlvbnMsIHRoaXMuX2F0b3ApOyAvLyBUaGUgaW5zdHJ1bWVudCdzIHRpbWJyZS5cbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlID0gW107IC8vIEEgcXVldWUgb2YgZnV0dXJlIHRvbmVzIHRvIHBsYXkuXG4gICAgICAgICAgICB0aGlzLl9taW5RdWV1ZVRpbWUgPSBJbmZpbml0eTsgLy8gVGhlIGVhcmxpZXN0IHRpbWUgaW4gX3F1ZXVlLlxuICAgICAgICAgICAgdGhpcy5fbWF4U2NoZWR1bGVkVGltZSA9IDA7IC8vIFRoZSBsYXRlc3QgdGltZSBpbiBfcXVldWUuXG4gICAgICAgICAgICB0aGlzLl91bnNvcnRlZFF1ZXVlID0gZmFsc2U7IC8vIFRydWUgaWYgX3F1ZXVlIGlzIHVuc29ydGVkLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRTZXQgPSBbXTsgLy8gVW5zdGFydGVkIHRvbmVzIGFscmVhZHkgc2VudCB0byBXZWJBdWRpby5cbiAgICAgICAgICAgIHRoaXMuX2ZpbmlzaFNldCA9IHt9OyAvLyBTdGFydGVkIHRvbmVzIHBsYXlpbmcgaW4gV2ViQXVkaW8uXG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwU2V0ID0gW107IC8vIFRvbmVzIHdhaXRpbmcgZm9yIGNsZWFudXAuXG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja1NldCA9IFtdOyAvLyBBIHNldCBvZiBzY2hlZHVsZWQgY2FsbGJhY2tzLlxuICAgICAgICAgICAgdGhpcy5faGFuZGxlcnMgPSB7fTsgLy8gJ25vdGVvbicgYW5kICdub3Rlb2ZmJyBoYW5kbGVycy5cbiAgICAgICAgICAgIHRoaXMuX25vdyA9IG51bGw7IC8vIEEgY2FjaGVkIGN1cnJlbnQtdGltZSB2YWx1ZS5cbiAgICAgICAgICAgIGlmIChVdGlscy5pc0F1ZGlvUHJlc2VudCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWxlbmNlKCk7IC8vIEluaXRpYWxpemVzIHRvcC1sZXZlbCBhdWRpbyBub2RlLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgZGVmYXVsdCB0aW1icmUgZm9yIHRoZSBpbnN0cnVtZW50LiAgU2VlIGRlZmF1bHRUaW1icmUuXG4gICAgICAgIHNldFRpbWJyZSh0KSB7XG4gICAgICAgICAgICB0aGlzLl90aW1icmUgPSBVdGlscy5tYWtlVGltYnJlKHQsIHRoaXMuX2F0b3ApOyAvLyBTYXZlcyBhIGNvcHkuXG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm5zIHRoZSBkZWZhdWx0IHRpbWJyZSBmb3IgdGhlIGluc3RydW1lbnQgYXMgYW4gb2JqZWN0LlxuICAgICAgICBnZXRUaW1icmUodCkge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLm1ha2VUaW1icmUodGhpcy5fdGltYnJlLCB0aGlzLl9hdG9wKTsgLy8gTWFrZXMgYSBjb3B5LlxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgb3ZlcmFsbCB2b2x1bWUgZm9yIHRoZSBpbnN0cnVtZW50IGltbWVkaWF0ZWx5LlxuICAgICAgICBzZXRWb2x1bWUodikge1xuICAgICAgICAgICAgLy8gV2l0aG91dCBhbiBhdWRpbyBzeXN0ZW0sIHZvbHVtZSBjYW5ub3QgYmUgc2V0LlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTmFOKHYpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3V0LmdhaW4udmFsdWUgPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2V0cyB0aGUgb3ZlcmFsbCB2b2x1bWUgZm9yIHRoZSBpbnN0cnVtZW50LlxuICAgICAgICBnZXRWb2x1bWUodikge1xuICAgICAgICAgICAgLy8gV2l0aG91dCBhbiBhdWRpbyBzeXN0ZW0sIHZvbHVtZSBpcyBzdHVjayBhdCB6ZXJvLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9vdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMC4wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX291dC5nYWluLnZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2lsZW5jZXMgdGhlIGluc3RydW1lbnQgaW1tZWRpYXRlbHkgYnkgcmVpbml0aWFsaXppbmcgdGhlIGF1ZGlvXG4gICAgICAgIC8vIGdyYXBoIGZvciB0aGlzIGluc3RydW1lbnQgYW5kIGVtcHR5aW5nIG9yIGZsdXNoaW5nIGFsbCBxdWV1ZXMgaW4gdGhlXG4gICAgICAgIC8vIHNjaGVkdWxlci4gIENhcmVmdWxseSBub3RpZmllcyBhbGwgbm90ZXMgdGhhdCBoYXZlIHN0YXJ0ZWQgYnV0IG5vdFxuICAgICAgICAvLyB5ZXQgZmluaXNoZWQsIGFuZCBzZXF1ZW5jZXMgdGhhdCBhcmUgYXdhaXRpbmcgc2NoZWR1bGVkIGNhbGxiYWNrcy5cbiAgICAgICAgLy8gRG9lcyBub3Qgbm90aWZ5IG5vdGVzIHRoYXQgaGF2ZSBub3QgeWV0IHN0YXJ0ZWQuXG4gICAgICAgIHNpbGVuY2UoKSB7XG4gICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgICBmaW5pc2hlZCxcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MsXG4gICAgICAgICAgICAgICAgaW5pdHZvbHVtZSA9IDE7XG5cbiAgICAgICAgICAgIC8vIENsZWFyIGZ1dHVyZSBub3Rlcy5cbiAgICAgICAgICAgIHRoaXMuX3F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLl9taW5RdWV1ZVRpbWUgPSBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMuX21heFNjaGVkdWxlZFRpbWUgPSAwO1xuXG4gICAgICAgICAgICAvLyBEb24ndCBub3RpZnkgbm90ZXMgdGhhdCBoYXZlbid0IHN0YXJ0ZWQgeWV0LlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRTZXQubGVuZ3RoID0gMDtcblxuICAgICAgICAgICAgLy8gRmx1c2ggZmluaXNoIGNhbGxiYWNrcyB0aGF0IGFyZSBwcm9taXNlZC5cbiAgICAgICAgICAgIGZpbmlzaGVkID0gdGhpcy5fZmluaXNoU2V0O1xuICAgICAgICAgICAgdGhpcy5fZmluaXNoU2V0ID0ge307XG5cbiAgICAgICAgICAgIC8vIEZsdXNoIG9uZS10aW1lIGNhbGxhY2tzIHRoYXQgYXJlIHByb21pc2VkLlxuICAgICAgICAgICAgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tTZXQ7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja1NldCA9IFtdO1xuXG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSBhdWRpbyBncmFwaCBmb3IgdGhpcyBpbnN0cnVtZW50LlxuICAgICAgICAgICAgaWYgKHRoaXMuX291dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX291dC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgaW5pdHZvbHVtZSA9IHRoaXMuX291dC5nYWluLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZWluaXRpYWxpemUgdGhlIGF1ZGlvIGdyYXBoOiBhbGwgYXVkaW8gZm9yIHRoZSBpbnN0cnVtZW50XG4gICAgICAgICAgICAvLyBtdWx0aXBsZXhlcyB0aHJvdWdoIGEgc2luZ2xlIGdhaW4gbm9kZSB3aXRoIGEgbWFzdGVyIHZvbHVtZS5cbiAgICAgICAgICAgIHRoaXMuX2F0b3AgPSBVdGlscy5nZXRBdWRpb1RvcCgpO1xuICAgICAgICAgICAgdGhpcy5fb3V0ID0gdGhpcy5fYXRvcC5hYy5jcmVhdGVHYWluKCk7XG4gICAgICAgICAgICAvLyB0aGlzLl9vdXQuZ2Fpbi52YWx1ZSA9IGluaXR2b2x1bWU7IC8vIFJPTllFSCBSRU1PVkVEIERVRSBUTyBCVUcuXG4gICAgICAgICAgICB0aGlzLl9vdXQuZ2Fpbi5zZXRUYXJnZXRBdFRpbWUoaW5pdHZvbHVtZSwgdGhpcy5fYXRvcC5hYy5jdXJyZW50VGltZSwgMC4wMDEpOyAvLyBST05ZRUggQURERURcbiAgICAgICAgICAgIHRoaXMuX291dC5jb25uZWN0KHRoaXMuX2F0b3Aub3V0KTtcblxuICAgICAgICAgICAgLy8gQXMgYSBsYXN0IHN0ZXAsIGNhbGwgYWxsIHByb21pc2VkIG5vdGlmaWNhdGlvbnMuXG4gICAgICAgICAgICBmb3IgKGogaW4gZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmlnZ2VyKFwibm90ZW9mZlwiLCBmaW5pc2hlZFtqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2tzW2pdLmNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGdXR1cmUgbm90ZXMgYXJlIHNjaGVkdWxlZCByZWxhdGl2ZSB0byBub3coKSwgd2hpY2ggcHJvdmlkZXNcbiAgICAgICAgLy8gYWNjZXNzIHRvIGF1ZGlvQ3VycmVudFN0YXJ0VGltZSgpLCBhIHRpbWUgdGhhdCBob2xkcyBzdGVhZHlcbiAgICAgICAgLy8gdW50aWwgdGhlIHNjcmlwdCByZWxlYXNlcyB0byB0aGUgZXZlbnQgbG9vcC4gIFdoZW4gX25vdyBpc1xuICAgICAgICAvLyBub24tbnVsbCwgaXQgaW5kaWNhdGVzIHRoYXQgc2NoZWR1bGluZyBpcyBhbHJlYWR5IGluIHByb2dyZXNzLlxuICAgICAgICAvLyBUaGUgdGltZXItZHJpdmVuIF9kb1BvbGwgZnVuY3Rpb24gY2xlYXJzIHRoZSBjYWNoZWQgX25vdy5cbiAgICAgICAgbm93KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX25vdyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vdztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0UG9sbFRpbWVyKHRydWUpOyAvLyBwYXNzaW5nICh0cnVlKSBzZXRzIHRoaXMuX25vdy5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3c7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWdpc3RlciBhbiBldmVudCBoYW5kbGVyLiAgRG9uZSB3aXRob3V0IGpRdWVyeSB0byByZWR1Y2UgZGVwZW5kZW5jaWVzLlxuICAgICAgICBvbihldmVudG5hbWUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50bmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudG5hbWVdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyc1tldmVudG5hbWVdLnB1c2goY2IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVW5yZWdpc3RlciBhbiBldmVudCBoYW5kbGVyLiAgRG9uZSB3aXRob3V0IGpRdWVyeSB0byByZWR1Y2UgZGVwZW5kZW5jaWVzLlxuICAgICAgICBvZmYoZXZlbnRuYW1lLCBjYikge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2hhbmRsZXJzLmhhc093blByb3BlcnR5KGV2ZW50bmFtZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJzW2V2ZW50bmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaixcbiAgICAgICAgICAgICAgICAgICAgICAgIGh1bnQgPSB0aGlzLl9oYW5kbGVyc1tldmVudG5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgaHVudC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGh1bnRbal0gPT09IGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaHVudC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaiAtPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJpZ2dlciBhbiBldmVudCwgbm90aWZ5aW5nIGFueSByZWdpc3RlcmVkIGhhbmRsZXJzLlxuICAgICAgICBfdHJpZ2dlcihldmVudG5hbWUsIHJlY29yZCkge1xuICAgICAgICAgICAgdmFyIGNiID0gdGhpcy5faGFuZGxlcnNbZXZlbnRuYW1lXSxcbiAgICAgICAgICAgICAgICBqO1xuICAgICAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYi5sZW5ndGggPT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIFNwZWNpYWwsIGNvbW1vbiBjYXNlIG9mIG9uZSBoYW5kbGVyOiBubyBjb3B5IG5lZWRlZC5cbiAgICAgICAgICAgICAgICBjYlswXShyZWNvcmQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENvcHkgdGhlIGFycmF5IG9mIGNhbGxiYWNrcyBiZWZvcmUgaXRlcmF0aW5nLCBiZWNhdXNlIHRoZVxuICAgICAgICAgICAgLy8gbWFpbiB0aGlzLl9oYW5kbGVycyBjb3B5IGNvdWxkIGJlIGNoYW5nZWQgYnkgYSBoYW5kbGVyLlxuICAgICAgICAgICAgLy8gWW91IGdldCBub3RpZmllZCBpZi1hbmQtb25seS1pZiB5b3UgYXJlIHJlZ2lzdGVyZWRcbiAgICAgICAgICAgIC8vIGF0IHRoZSBzdGFydGluZyBtb21lbnQgb2YgX3RyaWdnZXIuXG4gICAgICAgICAgICBjYiA9IGNiLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY2IubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYltqXShyZWNvcmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGVsbHMgdGhlIFdlYkF1ZGlvIEFQSSB0byBwbGF5IGEgdG9uZSAobm93IG9yIHNvb24pLiAgVGhlIHBhc3NlZFxuICAgICAgICAvLyByZWNvcmQgc3BlY2lmaWVzIGEgc3RhcnQgdGltZSBhbmQgcmVsZWFzZSB0aW1lLCBhbiBBRFNSIGVudmVsb3BlLFxuICAgICAgICAvLyBhbmQgb3RoZXIgdGltYnJlIHBhcmFtZXRlcnMuICBUaGlzIGZ1bmN0aW9uIHNldHMgdXAgYSBXZWJBdWRpb1xuICAgICAgICAvLyBub2RlIGdyYXBoIGZvciB0aGUgdG9uZSBnZW5lcmF0b3JzIGFuZCBmaWx0ZXJzIGZvciB0aGUgdG9uZS5cbiAgICAgICAgX21ha2VTb3VuZChyZWNvcmQpIHtcbiAgICAgICAgICAgIHZhciB0aW1icmUgPSByZWNvcmQudGltYnJlIHx8IHRoaXMuX3RpbWJyZSxcbiAgICAgICAgICAgICAgICBzdGFydHRpbWUgPSByZWNvcmQudGltZSArIEluc3RydW1lbnQudGltZU9mZnNldCxcbiAgICAgICAgICAgICAgICByZWxlYXNldGltZSA9IHN0YXJ0dGltZSArIHJlY29yZC5kdXJhdGlvbixcbiAgICAgICAgICAgICAgICBhdHRhY2t0aW1lID0gTWF0aC5taW4ocmVsZWFzZXRpbWUsIHN0YXJ0dGltZSArIHRpbWJyZS5hdHRhY2spLFxuICAgICAgICAgICAgICAgIGRlY2F5dGltZSA9IHRpbWJyZS5kZWNheSAqIE1hdGgucG93KDQ0MCAvIHJlY29yZC5mcmVxdWVuY3ksIHRpbWJyZS5kZWNheWZvbGxvdyksXG4gICAgICAgICAgICAgICAgZGVjYXlzdGFydHRpbWUgPSBhdHRhY2t0aW1lLFxuICAgICAgICAgICAgICAgIHN0b3B0aW1lID0gcmVsZWFzZXRpbWUgKyB0aW1icmUucmVsZWFzZSxcbiAgICAgICAgICAgICAgICBkb3VibGVkID0gdGltYnJlLmRldHVuZSAmJiB0aW1icmUuZGV0dW5lICE9IDEuMCxcbiAgICAgICAgICAgICAgICBhbXAgPSB0aW1icmUuZ2FpbiAqIHJlY29yZC52ZWxvY2l0eSAqIChkb3VibGVkID8gMC41IDogMS4wKSxcbiAgICAgICAgICAgICAgICBhYyA9IHRoaXMuX2F0b3AuYWMsXG4gICAgICAgICAgICAgICAgZyxcbiAgICAgICAgICAgICAgICBmLFxuICAgICAgICAgICAgICAgIG8sXG4gICAgICAgICAgICAgICAgbzIsXG4gICAgICAgICAgICAgICAgcHdhdmUsXG4gICAgICAgICAgICAgICAgayxcbiAgICAgICAgICAgICAgICB3ZixcbiAgICAgICAgICAgICAgICBid2Y7XG4gICAgICAgICAgICAvLyBPbmx5IGhvb2sgdXAgdG9uZSBnZW5lcmF0b3JzIGlmIGl0IGlzIGFuIGF1ZGlibGUgc291bmQuXG4gICAgICAgICAgICBpZiAocmVjb3JkLmR1cmF0aW9uID4gMCAmJiByZWNvcmQudmVsb2NpdHkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZyA9IGFjLmNyZWF0ZUdhaW4oKTtcbiAgICAgICAgICAgICAgICBnLmdhaW4uc2V0VmFsdWVBdFRpbWUoMCwgc3RhcnR0aW1lKTtcbiAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoYW1wLCBhdHRhY2t0aW1lKTtcbiAgICAgICAgICAgICAgICAvLyBGb3IgdGhlIGJlZ2lubmluZyBvZiB0aGUgZGVjYXksIHVzZSBsaW5lYXJSYW1wVG9WYWx1ZSBpbnN0ZWFkXG4gICAgICAgICAgICAgICAgLy8gb2Ygc2V0VGFyZ2V0QXRUaW1lLCBiZWNhdXNlIGl0IGF2b2lkcyBodHRwOi8vY3JidWcuY29tLzI1NDk0Mi5cbiAgICAgICAgICAgICAgICB3aGlsZSAoZGVjYXlzdGFydHRpbWUgPCBhdHRhY2t0aW1lICsgMSAvIDMyICYmIGRlY2F5c3RhcnR0aW1lICsgMSAvIDI1NiA8IHJlbGVhc2V0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEp1c3QgdHJhY2Ugb3V0IHRoZSBjdXJ2ZSBpbiBpbmNyZW1lbnRzIG9mIDEvMjU2IHNlY1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgdXAgdG8gMS8zMiBzZWNvbmRzLlxuICAgICAgICAgICAgICAgICAgICBkZWNheXN0YXJ0dGltZSArPSAxIC8gMjU2O1xuICAgICAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoYW1wICogKHRpbWJyZS5zdXN0YWluICsgKDEgLSB0aW1icmUuc3VzdGFpbikgKiBNYXRoLmV4cCgoYXR0YWNrdGltZSAtIGRlY2F5c3RhcnR0aW1lKSAvIGRlY2F5dGltZSkpLCBkZWNheXN0YXJ0dGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgcmVzdCBvZiB0aGUgZGVjYXksIHVzZSBzZXRUYXJnZXRBdFRpbWUuXG4gICAgICAgICAgICAgICAgZy5nYWluLnNldFRhcmdldEF0VGltZShhbXAgKiB0aW1icmUuc3VzdGFpbiwgZGVjYXlzdGFydHRpbWUsIGRlY2F5dGltZSk7XG4gICAgICAgICAgICAgICAgLy8gVGhlbiBhdCByZWxlYXNlIHRpbWUsIG1hcmsgdGhlIHZhbHVlIGFuZCByYW1wIHRvIHplcm8uXG4gICAgICAgICAgICAgICAgZy5nYWluLnNldFZhbHVlQXRUaW1lKGFtcCAqICh0aW1icmUuc3VzdGFpbiArICgxIC0gdGltYnJlLnN1c3RhaW4pICogTWF0aC5leHAoKGF0dGFja3RpbWUgLSByZWxlYXNldGltZSkgLyBkZWNheXRpbWUpKSwgcmVsZWFzZXRpbWUpO1xuICAgICAgICAgICAgICAgIGcuZ2Fpbi5saW5lYXJSYW1wVG9WYWx1ZUF0VGltZSgwLCBzdG9wdGltZSk7XG4gICAgICAgICAgICAgICAgZy5jb25uZWN0KHRoaXMuX291dCk7XG4gICAgICAgICAgICAgICAgLy8gSG9vayB1cCBhIGxvdy1wYXNzIGZpbHRlciBpZiBjdXRvZmYgaXMgc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgIGlmICgoIXRpbWJyZS5jdXRvZmYgJiYgIXRpbWJyZS5jdXRmb2xsb3cpIHx8IHRpbWJyZS5jdXRvZmYgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZiA9IGc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgdGhlIGN1dG9mZiBmcmVxdWVuY3kgYWRqdXN0ZWQgdXNpbmcgY3V0Zm9sbG93LlxuICAgICAgICAgICAgICAgICAgICBmID0gYWMuY3JlYXRlQmlxdWFkRmlsdGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGYuZnJlcXVlbmN5LnZhbHVlID0gdGltYnJlLmN1dG9mZiArIHJlY29yZC5mcmVxdWVuY3kgKiB0aW1icmUuY3V0Zm9sbG93OyAvLyBST05ZRUggUkVNT1ZFRCBEVUUgVE8gQlVHLlxuICAgICAgICAgICAgICAgICAgICAvLyBmLlEudmFsdWUgPSB0aW1icmUucmVzb25hbmNlOyAvLyBST05ZRUggUkVNT1ZFRCBEVUUgVE8gQlVHLlxuICAgICAgICAgICAgICAgICAgICBmLmZyZXF1ZW5jeS5zZXRUYXJnZXRBdFRpbWUodGltYnJlLmN1dG9mZiArIHJlY29yZC5mcmVxdWVuY3kgKiB0aW1icmUuY3V0Zm9sbG93LCB0aGlzLl9hdG9wLmFjLmN1cnJlbnRUaW1lLCAwLjAwMSk7IC8vIFJPTllFSCBBRERFRFxuICAgICAgICAgICAgICAgICAgICBmLlEuc2V0VGFyZ2V0QXRUaW1lKHRpbWJyZS5yZXNvbmFuY2UsIHRoaXMuX2F0b3AuYWMuY3VycmVudFRpbWUsIDAuMDAxKTsgLy8gUk9OWUVIIEFEREVEXG4gICAgICAgICAgICAgICAgICAgIGYuY29ubmVjdChnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSG9vayB1cCB0aGUgbWFpbiBvc2NpbGxhdG9yLlxuICAgICAgICAgICAgICAgIG8gPSBVdGlscy5tYWtlT3NjaWxsYXRvcih0aGlzLl9hdG9wLCB0aW1icmUud2F2ZSwgcmVjb3JkLmZyZXF1ZW5jeSk7XG4gICAgICAgICAgICAgICAgby5jb25uZWN0KGYpO1xuICAgICAgICAgICAgICAgIG8uc3RhcnQoc3RhcnR0aW1lKTtcbiAgICAgICAgICAgICAgICBvLnN0b3Aoc3RvcHRpbWUpO1xuICAgICAgICAgICAgICAgIC8vIEhvb2sgdXAgYSBkZXR1bmVkIG9zY2lsbGF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGRvdWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbzIgPSBVdGlscy5tYWtlT3NjaWxsYXRvcih0aGlzLl9hdG9wLCB0aW1icmUud2F2ZSwgcmVjb3JkLmZyZXF1ZW5jeSAqIHRpbWJyZS5kZXR1bmUpO1xuICAgICAgICAgICAgICAgICAgICBvMi5jb25uZWN0KGYpO1xuICAgICAgICAgICAgICAgICAgICBvMi5zdGFydChzdGFydHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICBvMi5zdG9wKHN0b3B0aW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU3RvcmUgbm9kZXMgaW4gdGhlIHJlY29yZCBzbyB0aGF0IHRoZXkgY2FuIGJlIG1vZGlmaWVkXG4gICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgdG9uZSBpcyB0cnVuY2F0ZWQgbGF0ZXIuXG4gICAgICAgICAgICAgICAgcmVjb3JkLmdhaW5Ob2RlID0gZztcbiAgICAgICAgICAgICAgICByZWNvcmQub3NjaWxsYXRvcnMgPSBbb107XG4gICAgICAgICAgICAgICAgaWYgKGRvdWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkLm9zY2lsbGF0b3JzLnB1c2gobzIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZWNvcmQuY2xlYW51cHRpbWUgPSBzdG9wdGltZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW5hdWRpYmxlIHNvdW5kcyBhcmUgc2NoZWR1bGVkOiB0aGVpciBwdXJwb3NlIGlzIHRvIHRydW5jYXRlXG4gICAgICAgICAgICAgICAgLy8gYXVkaWJsZSB0b25lcyBhdCB0aGUgc2FtZSBwaXRjaC4gIEJ1dCBkdXJhdGlvbiBpcyBzZXQgdG8gemVyb1xuICAgICAgICAgICAgICAgIC8vIHNvIHRoYXQgdGhleSBhcmUgY2xlYW5lZCB1cCBxdWlja2x5LlxuICAgICAgICAgICAgICAgIHJlY29yZC5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zdGFydFNldC5wdXNoKHJlY29yZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ1bmNhdGVzIGEgc291bmQgcHJldmlvdXNseSBzY2hlZHVsZWQgYnkgX21ha2VTb3VuZCBieSB1c2luZ1xuICAgICAgICAvLyBjYW5jZWxTY2hlZHVsZWRWYWx1ZXMgYW5kIGRpcmVjdGx5IHJhbXBpbmcgZG93biB0byB6ZXJvLlxuICAgICAgICAvLyBDYW4gb25seSBiZSB1c2VkIHRvIHNob3J0ZW4gYSBzb3VuZC5cbiAgICAgICAgX3RydW5jYXRlU291bmQocmVjb3JkLCB0cnVuY2F0ZXRpbWUpIHtcbiAgICAgICAgICAgIGlmICh0cnVuY2F0ZXRpbWUgPCByZWNvcmQudGltZSArIHJlY29yZC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIHJlY29yZC5kdXJhdGlvbiA9IE1hdGgubWF4KDAsIHRydW5jYXRldGltZSAtIHJlY29yZC50aW1lKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmdhaW5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1icmUgPSByZWNvcmQudGltYnJlIHx8IHRoaXMuX3RpbWJyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0dGltZSA9IHJlY29yZC50aW1lICsgSW5zdHJ1bWVudC50aW1lT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZXRpbWUgPSB0cnVuY2F0ZXRpbWUgKyBJbnN0cnVtZW50LnRpbWVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRhY2t0aW1lID0gTWF0aC5taW4ocmVsZWFzZXRpbWUsIHN0YXJ0dGltZSArIHRpbWJyZS5hdHRhY2spLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVjYXl0aW1lID0gdGltYnJlLmRlY2F5ICogTWF0aC5wb3coNDQwIC8gcmVjb3JkLmZyZXF1ZW5jeSwgdGltYnJlLmRlY2F5Zm9sbG93KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3B0aW1lID0gcmVsZWFzZXRpbWUgKyB0aW1icmUucmVsZWFzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFudXB0aW1lID0gc3RvcHRpbWUgKyBJbnN0cnVtZW50LmNsZWFudXBEZWxheSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvdWJsZWQgPSB0aW1icmUuZGV0dW5lICYmIHRpbWJyZS5kZXR1bmUgIT0gMS4wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW1wID0gdGltYnJlLmdhaW4gKiByZWNvcmQudmVsb2NpdHkgKiAoZG91YmxlZCA/IDAuNSA6IDEuMCksXG4gICAgICAgICAgICAgICAgICAgICAgICBqLFxuICAgICAgICAgICAgICAgICAgICAgICAgZyA9IHJlY29yZC5nYWluTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FuY2VsIGFueSBlbnZlbG9wZSBwb2ludHMgYWZ0ZXIgdGhlIG5ldyByZWxlYXNldGltZS5cbiAgICAgICAgICAgICAgICAgICAgZy5nYWluLmNhbmNlbFNjaGVkdWxlZFZhbHVlcyhyZWxlYXNldGltZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxlYXNldGltZSA8PSBzdGFydHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbGVhc2UgYmVmb3JlIHN0YXJ0PyAgVG90YWxseSBzaWxlbmNlIHRoZSBub3RlLlxuICAgICAgICAgICAgICAgICAgICAgICAgZy5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHJlbGVhc2V0aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZWxlYXNldGltZSA8PSBhdHRhY2t0aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIGJlZm9yZSBhdHRhY2sgaXMgZG9uZT8gIEludGVycnVwdCByYW1wIHVwLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZy5nYWluLmxpbmVhclJhbXBUb1ZhbHVlQXRUaW1lKChhbXAgKiAocmVsZWFzZXRpbWUgLSBzdGFydHRpbWUpKSAvIChhdHRhY2t0aW1lIC0gc3RhcnR0aW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoKGFtcCAqIChyZWxlYXNldGltZSAtIHN0YXJ0dGltZSkpIC8gKGF0dGFja3RpbWUgLSBzdGFydHRpbWUpLCBzdGFydHRpbWUpOyAvLyBST05ZRUggQURERUQgU0VDT05EIFBBUkFNIFwic3RhcnR0aW1lXCIuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWxlYXNlIGR1cmluZyBkZWNheT8gIEludGVycnVwdCBkZWNheSBkb3duLlxuICAgICAgICAgICAgICAgICAgICAgICAgZy5nYWluLnNldFZhbHVlQXRUaW1lKGFtcCAqICh0aW1icmUuc3VzdGFpbiArICgxIC0gdGltYnJlLnN1c3RhaW4pICogTWF0aC5leHAoKGF0dGFja3RpbWUgLSByZWxlYXNldGltZSkgLyBkZWNheXRpbWUpKSwgcmVsZWFzZXRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZW4gcmFtcCBkb3duIHRvIHplcm8gYWNjb3JkaW5nIHRvIHJlY29yZC5yZWxlYXNlLlxuICAgICAgICAgICAgICAgICAgICBnLmdhaW4ubGluZWFyUmFtcFRvVmFsdWVBdFRpbWUoMCwgc3RvcHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZnRlciBzdG9wdGltZSwgc3RvcCB0aGUgb3NjaWxsYXRvcnMuICBUaGlzIGlzIG5lY2Vzc2FyeSB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBlbGltaW5hdGUgZXh0cmEgd29yayBmb3IgV2ViQXVkaW8gZm9yIG5vLWxvbmdlci1hdWRpYmxlIG5vdGVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLm9zY2lsbGF0b3JzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmVjb3JkLm9zY2lsbGF0b3JzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLm9zY2lsbGF0b3JzW2pdLnN0b3Aoc3RvcHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGRpc2Nvbm5lY3QuXG4gICAgICAgICAgICAgICAgICAgIHJlY29yZC5jbGVhbnVwdGltZSA9IGNsZWFudXB0aW1lO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgY29yZSBzY2hlZHVsaW5nIGxvb3AgaXMgbWFuYWdlZCBieSBJbnN0cnVtZW50Ll9kb1BvbGwuICBJdCByZWFkc1xuICAgICAgICAvLyB0aGUgYXVkaW9jb250ZXh0J3MgY3VycmVudCB0aW1lIGFuZCBwdXNoZXMgdG9uZSByZWNvcmRzIGZyb20gb25lXG4gICAgICAgIC8vIHN0YWdlIHRvIHRoZSBuZXh0LlxuICAgICAgICAvL1xuICAgICAgICAvLyAxLiBUaGUgZmlyc3Qgc3RhZ2UgaXMgdGhlIF9xdWV1ZSwgd2hpY2ggaGFzIHRvbmVzIHRoYXQgaGF2ZSBub3RcbiAgICAgICAgLy8gICAgeWV0IGJlZW4gZ2l2ZW4gdG8gV2ViQXVkaW8uIFRoaXMgbG9vcCBzY2FucyBfcXVldWUgdG8gZmluZFxuICAgICAgICAvLyAgICBub3RlcyB0aGF0IG5lZWQgdG8gYmVnaW4gaW4gdGhlIG5leHQgZmV3IHNlY29uZHM7IHRoZW4gaXRcbiAgICAgICAgLy8gICAgc2VuZHMgdGhvc2UgdG8gV2ViQWR1aW8gYW5kIG1vdmVzIHRoZW0gdG8gX3N0YXJ0U2V0LiBCZWNhdXNlXG4gICAgICAgIC8vICAgIHNjaGVkdWxlZCBzb25ncyBjYW4gYmUgbG9uZywgX3F1ZXVlIGNhbiBiZSBsYXJnZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gMi4gU2Vjb25kIGlzIF9zdGFydFNldCwgd2hpY2ggaGFzIHRvbmVzIHRoYXQgaGF2ZSBiZWVuIGdpdmVuIHRvXG4gICAgICAgIC8vICAgIFdlYkF1ZGlvLCBidXQgd2hvc2Ugc3RhcnQgdGltZXMgaGF2ZSBub3QgeWV0IGVsYXBzZWQuIFdoZW5cbiAgICAgICAgLy8gICAgdGhlIHRpbWUgYWR2YW5jZXMgcGFzdCB0aGUgc3RhcnQgdGltZSBvZiBhIHJlY29yZCwgYSAnbm90ZW9uJ1xuICAgICAgICAvLyAgICBub3RpZmljYXRpb24gaXMgZmlyZWQgZm9yIHRoZSB0b25lLCBhbmQgaXQgaXMgbW92ZWQgdG9cbiAgICAgICAgLy8gICAgX2ZpbmlzaFNldC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gMy4gX2ZpbmlzaFNldCByZXByZXNlbnRzIHRoZSBub3RlcyB0aGF0IGFyZSBjdXJyZW50bHkgc291bmRpbmcuXG4gICAgICAgIC8vICAgIFRoZSBwcm9ncmFtbWluZyBtb2RlbCBmb3IgSW5zdHJ1bWVudCBpcyB0aGF0IG9ubHkgb25lIHRvbmUgb2ZcbiAgICAgICAgLy8gICAgYSBzcGVjaWZpYyBmcmVxdWVuY3kgbWF5IGJlIHBsYXllZCBhdCBvbmNlIHdpdGhpbiBhIEluc3RydW1lbnQsXG4gICAgICAgIC8vICAgIHNvIG9ubHkgb25lIHRvbmUgb2YgYSBnaXZlbiBmcmVxdWVuY3kgbWF5IGV4aXN0IGluIF9maW5pc2hTZXRcbiAgICAgICAgLy8gICAgYXQgb25jZS4gIFdoZW4gdGhlcmUgaXMgYSBjb25mbGljdCwgdGhlIHNvb25lci10by1lbmQtbm90ZVxuICAgICAgICAvLyAgICBpcyB0cnVuY2F0ZWQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIDQuIEFmdGVyIGEgbm90ZSBpcyByZWxlYXNlZCwgaXQgbWF5IGhhdmUgYSBsaXRsZSByZWxlYXNlIHRpbWVcbiAgICAgICAgLy8gICAgKGRlcGVuZGluZyBvbiB0aW1icmUucmVsZWFzZSksIGFmdGVyIHdoaWNoIHRoZSBub2RlcyBjYW5cbiAgICAgICAgLy8gICAgYmUgdG90YWxseSBkaXNjb25uZWN0ZWQgYW5kIGNsZWFuZWQgdXAuICBfY2xlYW51cFNldCBob2xkc1xuICAgICAgICAvLyAgICBub3RlcyBmb3Igd2hpY2ggd2UgYXJlIGF3YWl0aW5nIGNsZWFudXAuXG4gICAgICAgIF9kb1BvbGwoKSB7XG4gICAgICAgICAgICB0aGlzLl9wb2xsVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5fbm93ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuaGFzT3duUHJvcGVydHkoXCJpbnRlcnJ1cHRlZFwiKSAmJiB3aW5kb3dbXCJpbnRlcnJ1cHRlZFwiXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lsZW5jZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoZSBzaG9ydGVzdCB0aW1lIHdlIGNhbiBkZWxheSBpcyAxIC8gMTAwMCBzZWNzLCBzbyBpZiBhbiBldmVudFxuICAgICAgICAgICAgLy8gaXMgd2l0aGluIHRoZSBuZXh0IDAuNSBtcywgbm93IGlzIHRoZSBjbG9zZXN0IG1vbWVudCwgYW5kIHdlIGdvXG4gICAgICAgICAgICAvLyBhaGVhZCBhbmQgcHJvY2VzcyBpdC5cbiAgICAgICAgICAgIHZhciBpbnN0YW50ID0gdGhpcy5fYXRvcC5hYy5jdXJyZW50VGltZSArIDEgLyAyMDAwLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrcyA9IFtdLFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgd29yayxcbiAgICAgICAgICAgICAgICB3aGVuLFxuICAgICAgICAgICAgICAgIGZyZXEsXG4gICAgICAgICAgICAgICAgcmVjb3JkLFxuICAgICAgICAgICAgICAgIGNvbmZsaWN0LFxuICAgICAgICAgICAgICAgIHNhdmUsXG4gICAgICAgICAgICAgICAgY2I7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGJhdGNoIG9mIG5vdGVzXG4gICAgICAgICAgICBpZiAodGhpcy5fbWluUXVldWVUaW1lIC0gaW5zdGFudCA8PSBJbnN0cnVtZW50LmJ1ZmZlclNlY3MpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdW5zb3J0ZWRRdWV1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS50aW1lICE9IGIudGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhLnRpbWUgLSBiLnRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5kdXJhdGlvbiAhPSBiLmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZHVyYXRpb24gLSBiLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEuZnJlcXVlbmN5IC0gYi5mcmVxdWVuY3k7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNvcnRlZFF1ZXVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9xdWV1ZS5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcXVldWVbal0udGltZSAtIGluc3RhbnQgPiBJbnN0cnVtZW50LmJ1ZmZlclNlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB3b3JrID0gdGhpcy5fcXVldWUuc3BsaWNlKDAsIGopO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgd29yay5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFrZVNvdW5kKHdvcmtbal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21pblF1ZXVlVGltZSA9IHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDAgPyB0aGlzLl9xdWV1ZVswXS50aW1lIDogSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGlzY29ubmVjdCBub3RlcyBmcm9tIHRoZSBjbGVhbnVwIHNldC5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9jbGVhbnVwU2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgcmVjb3JkID0gdGhpcy5fY2xlYW51cFNldFtqXTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmNsZWFudXB0aW1lIDwgaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmdhaW5Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIGV4cGxpY2l0IGRpc2Nvbm5lY3QgaXMgbmVlZGVkIG9yIGVsc2UgQ2hyb21lJ3MgV2ViQXVkaW9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0cyBnZXR0aW5nIG92ZXJsb2FkZWQgYWZ0ZXIgYSBjb3VwbGUgdGhvdXNhbmQgbm90ZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvcmQuZ2Fpbk5vZGUuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkLmdhaW5Ob2RlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwU2V0LnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaiAtPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGlmeSBhYm91dCBhbnkgbm90ZXMgZmluaXNoaW5nLlxuICAgICAgICAgICAgZm9yIChmcmVxIGluIHRoaXMuX2ZpbmlzaFNldCkge1xuICAgICAgICAgICAgICAgIHJlY29yZCA9IHRoaXMuX2ZpbmlzaFNldFtmcmVxXTtcbiAgICAgICAgICAgICAgICB3aGVuID0gcmVjb3JkLnRpbWUgKyByZWNvcmQuZHVyYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKHdoZW4gPD0gaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogW3doZW4sIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZjogdGhpcy5fdHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhOiBbXCJub3Rlb2ZmXCIsIHJlY29yZF0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb3JkLmNsZWFudXB0aW1lICE9IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwU2V0LnB1c2gocmVjb3JkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZmluaXNoU2V0W2ZyZXFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGwgYW55IHNwZWNpZmljIG9uZS10aW1lIGNhbGxiYWNrcyB0aGF0IHdlcmUgcmVnaXN0ZXJlZC5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9jYWxsYmFja1NldC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGNiID0gdGhpcy5fY2FsbGJhY2tTZXRbal07XG4gICAgICAgICAgICAgICAgd2hlbiA9IGNiLnRpbWU7XG4gICAgICAgICAgICAgICAgaWYgKHdoZW4gPD0gaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogW3doZW4sIDFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgZjogY2IuY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICB0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYTogW10sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja1NldC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3RpZnkgYWJvdXQgYW55IG5vdGVzIHN0YXJ0aW5nLlxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuX3N0YXJ0U2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3N0YXJ0U2V0W2pdLnRpbWUgPD0gaW5zdGFudCkge1xuICAgICAgICAgICAgICAgICAgICBzYXZlID0gcmVjb3JkID0gdGhpcy5fc3RhcnRTZXRbal07XG4gICAgICAgICAgICAgICAgICAgIGZyZXEgPSByZWNvcmQuZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgICAgICBjb25mbGljdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9maW5pc2hTZXQuaGFzT3duUHJvcGVydHkoZnJlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSBub3RlIGF0IHRoZSBzYW1lIGZyZXF1ZW5jeSBwbGF5aW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlbiByZWxlYXNlIHRoZSBvbmUgdGhhdCBzdGFydHMgZmlyc3QsIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmxpY3QgPSB0aGlzLl9maW5pc2hTZXRbZnJlcV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmxpY3QudGltZSA8IHJlY29yZC50aW1lIHx8IChjb25mbGljdC50aW1lID09IHJlY29yZC50aW1lICYmIGNvbmZsaWN0LmR1cmF0aW9uIDwgcmVjb3JkLmR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE91ciBuZXcgc291bmQgY29uZmxpY3RzIHdpdGggYW4gb2xkIG9uZTogZW5kIHRoZSBvbGQgb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIG5vdGlmeSBpbW1lZGlhdGVseSBvZiBpdHMgbm90ZW9mZiBldmVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90cnVuY2F0ZVNvdW5kKGNvbmZsaWN0LCByZWNvcmQudGltZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmRlcjogW3JlY29yZC50aW1lLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZjogdGhpcy5fdHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdDogdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogW1wibm90ZW9mZlwiLCBjb25mbGljdF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ZpbmlzaFNldFtmcmVxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSBjb25mbGljdCBmcm9tIHRoZSBmdXR1cmUgaGFzIGFscmVhZHkgc2NoZWR1bGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIG91ciBvd24gbm90ZSBzaG91bGRuJ3Qgc291bmQuICBUcnVuY2F0ZSBvdXJzZWx2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSwgYW5kIHN1cHByZXNzIG91ciBvd24gbm90ZW9uIGFuZCBub3Rlb2ZmLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RydW5jYXRlU291bmQocmVjb3JkLCBjb25mbGljdC50aW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25mbGljdCA9IHJlY29yZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFNldC5zcGxpY2UoaiwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGogLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY29yZC5kdXJhdGlvbiA+IDAgJiYgcmVjb3JkLnZlbG9jaXR5ID4gMCAmJiBjb25mbGljdCAhPT0gcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maW5pc2hTZXRbZnJlcV0gPSByZWNvcmQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFja3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXI6IFtyZWNvcmQudGltZSwgMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZjogdGhpcy5fdHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IFtcIm5vdGVvblwiLCByZWNvcmRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSB0aGUgbmV4dCBfZG9Qb2xsLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRQb2xsVGltZXIoKTtcblxuICAgICAgICAgICAgLy8gU29ydCBjYWxsYmFja3MgYWNjb3JkaW5nIHRvIHRoZSBcIm9yZGVyXCIgdHVwbGUsIHNvIGVhcmxpZXIgZXZlbnRzXG4gICAgICAgICAgICAvLyBhcmUgbm90aWZpZWQgZmlyc3QuXG4gICAgICAgICAgICBjYWxsYmFja3Muc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgICAgIGlmIChhLm9yZGVyWzBdICE9IGIub3JkZXJbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGEub3JkZXJbMF0gLSBiLm9yZGVyWzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyB0aWVicmVhayBieSBub3RpZnlpbmcgJ25vdGVvZmYnIGZpcnN0IGFuZCAnbm90ZW9uJyBsYXN0LlxuICAgICAgICAgICAgICAgIHJldHVybiBhLm9yZGVyWzFdIC0gYi5vcmRlclsxXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXQgdGhlIGVuZCwgY2FsbCBhbGwgdGhlIGNhbGxiYWNrcyB3aXRob3V0IGRlcGVuZGluZyBvbiBcInRoaXNcIiBzdGF0ZS5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjYWxsYmFja3MubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYiA9IGNhbGxiYWNrc1tqXTtcbiAgICAgICAgICAgICAgICBjYi5mLmFwcGx5KGNiLnQsIGNiLmEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFNjaGVkdWxlcyB0aGUgbmV4dCBfZG9Qb2xsIGNhbGwgYnkgZXhhbWluaW5nIHRpbWVzIGluIHRoZSB2YXJpb3VzXG4gICAgICAgIC8vIHNldHMgYW5kIGRldGVybWluaW5nIHRoZSBzb29uZXN0IGV2ZW50IHRoYXQgbmVlZHMgX2RvUG9sbCBwcm9jZXNzaW5nLlxuICAgICAgICBfc3RhcnRQb2xsVGltZXIoc2V0bm93OiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYWxyZWFkeSBkb25lIGEgXCJzZXRub3dcIiwgdGhlbiBwb2xsVGltZXIgaXMgemVyby10aW1lb3V0XG4gICAgICAgICAgICAvLyBhbmQgY2Fubm90IGJlIGZhc3Rlci5cbiAgICAgICAgICAgIGlmICh0aGlzLl9wb2xsVGltZXIgJiYgdGhpcy5fbm93ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgcG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZG9Qb2xsKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlYXJsaWVzdCA9IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIGosXG4gICAgICAgICAgICAgICAgZGVsYXk7XG4gICAgICAgICAgICBpZiAodGhpcy5fcG9sbFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgYW55IG9sZCB0aW1lclxuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9wb2xsVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BvbGxUaW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2V0bm93KSB7XG4gICAgICAgICAgICAgICAgLy8gV2hlbiBzY2hlZHVsaW5nIHRvbmVzLCBjYWNoZSBfbm93IGFuZCBrZWVwIGEgemVyby10aW1lb3V0IHBvbGwuXG4gICAgICAgICAgICAgICAgLy8gX25vdyB3aWxsIGJlIGNsZWFyZWQgdGhlIG5leHQgdGltZSB3ZSBleGVjdXRlIF9kb1BvbGwuXG4gICAgICAgICAgICAgICAgdGhpcy5fbm93ID0gVXRpbHMuYXVkaW9DdXJyZW50U3RhcnRUaW1lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcG9sbFRpbWVyID0gc2V0VGltZW91dChwb2xsLCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lciBkdWUgdG8gbm90ZXMgc3RhcnRpbmc6IHdha2UgdXAgZm9yICdub3Rlb24nIG5vdGlmaWNhdGlvbi5cbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLl9zdGFydFNldC5sZW5ndGg7ICsraikge1xuICAgICAgICAgICAgICAgIGVhcmxpZXN0ID0gTWF0aC5taW4oZWFybGllc3QsIHRoaXMuX3N0YXJ0U2V0W2pdLnRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGltZXIgZHVlIHRvIG5vdGVzIGZpbmlzaGluZzogd2FrZSB1cCBmb3IgJ25vdGVvZmYnIG5vdGlmaWNhdGlvbi5cbiAgICAgICAgICAgIGZvciAoaiBpbiB0aGlzLl9maW5pc2hTZXQpIHtcbiAgICAgICAgICAgICAgICBlYXJsaWVzdCA9IE1hdGgubWluKGVhcmxpZXN0LCB0aGlzLl9maW5pc2hTZXRbal0udGltZSArIHRoaXMuX2ZpbmlzaFNldFtqXS5kdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lciBkdWUgdG8gc2NoZWR1bGVkIGNhbGxiYWNrLlxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXMuX2NhbGxiYWNrU2V0Lmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgICAgICAgZWFybGllc3QgPSBNYXRoLm1pbihlYXJsaWVzdCwgdGhpcy5fY2FsbGJhY2tTZXRbal0udGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaW1lciBkdWUgdG8gY2xlYW51cDogYWRkIGEgc2Vjb25kIHRvIGdpdmUgc29tZSB0aW1lIHRvIGJhdGNoIHVwLlxuICAgICAgICAgICAgaWYgKHRoaXMuX2NsZWFudXBTZXQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGVhcmxpZXN0ID0gTWF0aC5taW4oZWFybGllc3QsIHRoaXMuX2NsZWFudXBTZXRbMF0uY2xlYW51cHRpbWUgKyAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRpbWVyIGR1ZSB0byBzZXF1ZW5jZXIgZXZlbnRzOiBzdWJ0cmFjdCBhIGxpdHRsZSB0aW1lIHRvIHN0YXkgYWhlYWQuXG4gICAgICAgICAgICBlYXJsaWVzdCA9IE1hdGgubWluKGVhcmxpZXN0LCB0aGlzLl9taW5RdWV1ZVRpbWUgLSBJbnN0cnVtZW50LmRlcXVldWVUaW1lKTtcblxuICAgICAgICAgICAgZGVsYXkgPSBNYXRoLm1heCgwLjAwMSwgZWFybGllc3QgLSB0aGlzLl9hdG9wLmFjLmN1cnJlbnRUaW1lKTtcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGZ1dHVyZSBldmVudHMsIHRoZW4gd2UgZG8gbm90IG5lZWQgYSB0aW1lci5cbiAgICAgICAgICAgIGlmIChpc05hTihkZWxheSkgfHwgZGVsYXkgPT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFVzZSB0aGUgSmF2YXNjcmlwdCB0aW1lciB0byB3YWtlIHVwIGF0IHRoZSByaWdodCBtb21lbnQuXG4gICAgICAgICAgICB0aGlzLl9wb2xsVGltZXIgPSBzZXRUaW1lb3V0KHBvbGwsIE1hdGgucm91bmQoZGVsYXkgKiAxMDAwKSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgbG93LWxldmVsIHRvbmUgZnVuY3Rpb24uXG4gICAgICAgIHRvbmUocGl0Y2gsIGR1cmF0aW9uLCB2ZWxvY2l0eSwgZGVsYXksIHRpbWJyZSwgb3JpZ2luKSB7XG4gICAgICAgICAgICAvLyBJZiBhdWRpbyBpcyBub3QgcHJlc2VudCwgdGhpcyBpcyBhIG5vLW9wLlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDYWxsZWQgd2l0aCBhbiBvYmplY3QgaW5zdGVhZCBvZiBsaXN0ZWQgYXJncy5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGl0Y2ggPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmICh2ZWxvY2l0eSA9PSBudWxsKSB2ZWxvY2l0eSA9IHBpdGNoLnZlbG9jaXR5O1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiA9PSBudWxsKSBkdXJhdGlvbiA9IHBpdGNoLmR1cmF0aW9uO1xuICAgICAgICAgICAgICAgIGlmIChkZWxheSA9PSBudWxsKSBkZWxheSA9IHBpdGNoLmRlbGF5O1xuICAgICAgICAgICAgICAgIGlmICh0aW1icmUgPT0gbnVsbCkgdGltYnJlID0gcGl0Y2gudGltYnJlO1xuICAgICAgICAgICAgICAgIGlmIChvcmlnaW4gPT0gbnVsbCkgb3JpZ2luID0gcGl0Y2gub3JpZ2luO1xuICAgICAgICAgICAgICAgIHBpdGNoID0gcGl0Y2gucGl0Y2g7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnZlcnQgcGl0Y2ggZnJvbSB2YXJpb3VzIGZvcm1hdHMgdG8gSHogZnJlcXVlbmN5IGFuZCBhIG1pZGkgbnVtLlxuICAgICAgICAgICAgdmFyIG1pZGksIGZyZXF1ZW5jeTtcbiAgICAgICAgICAgIGlmICghcGl0Y2gpIHtcbiAgICAgICAgICAgICAgICBwaXRjaCA9IFwiQ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzTmFOKHBpdGNoKSkge1xuICAgICAgICAgICAgICAgIG1pZGkgPSBVdGlscy5waXRjaFRvTWlkaShwaXRjaCk7XG4gICAgICAgICAgICAgICAgZnJlcXVlbmN5ID0gVXRpbHMubWlkaVRvRnJlcXVlbmN5KG1pZGkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmVxdWVuY3kgPSBOdW1iZXIocGl0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChmcmVxdWVuY3kgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1pZGkgPSAtZnJlcXVlbmN5O1xuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3kgPSBVdGlscy5taWRpVG9GcmVxdWVuY3kobWlkaSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWlkaSA9IFV0aWxzLmZyZXF1ZW5jeVRvTWlkaShmcmVxdWVuY3kpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aW1icmUpIHtcbiAgICAgICAgICAgICAgICB0aW1icmUgPSB0aGlzLl90aW1icmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIGN1c3RvbSB0aW1icmUsIHZhbGlkYXRlIGFuZCBjb3B5IGl0LlxuICAgICAgICAgICAgaWYgKHRpbWJyZSAhPT0gdGhpcy5fdGltYnJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdpdmVuID0gdGltYnJlLFxuICAgICAgICAgICAgICAgICAgICBrZXk7XG4gICAgICAgICAgICAgICAgdGltYnJlID0ge307XG4gICAgICAgICAgICAgICAgZm9yIChrZXkgaW4gVXRpbHMuZGVmYXVsdFRpbWJyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIGdpdmVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1icmVba2V5XSA9IGdpdmVuW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1icmVba2V5XSA9IFV0aWxzLmRlZmF1bHRUaW1icmVba2V5XTsgLy8gUk9OWUVIOiBUaGVyZSB3YXMgYSB0eXBvIGJ1ZyBpbiB0aGUgb3JpZ2luYWwgTXVzaWNhbC5qcy4gSXQgd2FzIGNhdWdodCBieSBvdXIgVHlwZVNjcmlwdCBjb21waWxlci5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSByZWNvcmQgZm9yIGEgdG9uZS5cbiAgICAgICAgICAgIHZhciBhYyA9IHRoaXMuX2F0b3AuYWMsXG4gICAgICAgICAgICAgICAgbm93ID0gdGhpcy5ub3coKSxcbiAgICAgICAgICAgICAgICB0aW1lID0gbm93ICsgKGRlbGF5IHx8IDApLFxuICAgICAgICAgICAgICAgIHJlY29yZCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGltZTogdGltZSxcbiAgICAgICAgICAgICAgICAgICAgb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBmcmVxdWVuY3k6IGZyZXF1ZW5jeSxcbiAgICAgICAgICAgICAgICAgICAgbWlkaTogbWlkaSxcbiAgICAgICAgICAgICAgICAgICAgdmVsb2NpdHk6IHZlbG9jaXR5ID09IG51bGwgPyAxIDogdmVsb2NpdHksXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbiA9PSBudWxsID8gSW5zdHJ1bWVudC50b25lTGVuZ3RoIDogZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIHRpbWJyZTogdGltYnJlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0cnVtZW50OiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBnYWluTm9kZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgb3NjaWxsYXRvcnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGNsZWFudXB0aW1lOiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBvcmlnaW4sIC8vIHNhdmUgdGhlIG9yaWdpbiBvZiB0aGUgdG9uZSBmb3IgdmlzaWJsZSBmZWVkYmFja1xuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmICh0aW1lIDwgbm93ICsgSW5zdHJ1bWVudC5idWZmZXJTZWNzKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIHRvbmUgc3RhcnRzIHNvb24hICBHaXZlIGl0IGRpcmVjdGx5IHRvIFdlYkF1ZGlvLlxuICAgICAgICAgICAgICAgIHRoaXMuX21ha2VTb3VuZChyZWNvcmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgdG9uZSBpcyBsYXRlcjogcXVldWUgaXQuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl91bnNvcnRlZFF1ZXVlICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCAmJiB0aW1lIDwgdGhpcy5fcXVldWVbdGhpcy5fcXVldWUubGVuZ3RoIC0gMV0udGltZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91bnNvcnRlZFF1ZXVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUucHVzaChyZWNvcmQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pblF1ZXVlVGltZSA9IE1hdGgubWluKHRoaXMuX21pblF1ZXVlVGltZSwgcmVjb3JkLnRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBsb3ctbGV2ZWwgY2FsbGJhY2sgc2NoZWR1bGluZyBtZXRob2QuXG4gICAgICAgIHNjaGVkdWxlKGRlbGF5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tTZXQucHVzaCh7IHRpbWU6IHRoaXMubm93KCkgKyBkZWxheSwgY2FsbGJhY2s6IGNhbGxiYWNrIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBoaWdoLWxldmVsIHNlcXVlbmNpbmcgbWV0aG9kLlxuICAgICAgICBwbGF5KGFiY3N0cmluZykge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBudWxsLFxuICAgICAgICAgICAgICAgIG9wdHMgPSB7fSxcbiAgICAgICAgICAgICAgICBzdWJmaWxlLFxuICAgICAgICAgICAgICAgIGFiY2ZpbGUsXG4gICAgICAgICAgICAgICAgYXJnaW5kZXgsXG4gICAgICAgICAgICAgICAgdGVtcG8sXG4gICAgICAgICAgICAgICAgdGltYnJlLFxuICAgICAgICAgICAgICAgIGssXG4gICAgICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICAgICAgbWF4ZGVsYXkgPSAwLFxuICAgICAgICAgICAgICAgIGF0dGVudWF0ZSxcbiAgICAgICAgICAgICAgICB2b2ljZW5hbWUsXG4gICAgICAgICAgICAgICAgc3RlbXMsXG4gICAgICAgICAgICAgICAgbmksXG4gICAgICAgICAgICAgICAgdm4sXG4gICAgICAgICAgICAgICAgaixcbiAgICAgICAgICAgICAgICBzdGVtLFxuICAgICAgICAgICAgICAgIG5vdGUsXG4gICAgICAgICAgICAgICAgYmVhdHNlY3MsXG4gICAgICAgICAgICAgICAgc2VjcyxcbiAgICAgICAgICAgICAgICB2LFxuICAgICAgICAgICAgICAgIGZpbGVzID0gW107XG4gICAgICAgICAgICAvLyBMb29rIGZvciBjb250aW51YXRpb24gYXMgbGFzdCBhcmd1bWVudC5cbiAgICAgICAgICAgIGlmIChhcmdzLmxlbmd0aCAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgICAgIGRvbmUgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLl9hdG9wKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb29rIGZvciBvcHRpb25zIGFzIGZpcnN0IG9iamVjdC5cbiAgICAgICAgICAgIGFyZ2luZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBvd24gcHJvcGVydGllcyBpbnRvIGFuIG9wdGlvbnMgb2JqZWN0LlxuICAgICAgICAgICAgICAgIGZvciAoayBpbiBhcmdzWzBdKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnc1swXS5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0c1trXSA9IGFyZ3NbMF1ba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhcmdpbmRleCA9IDE7XG4gICAgICAgICAgICAgICAgLy8gSWYgYSBzb25nIGlzIHN1cHBsaWVkIGJ5IG9wdGlvbnMgb2JqZWN0LCBwcm9jZXNzIGl0LlxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmhhc093blByb3BlcnR5KFwic29uZ1wiKSkge1xuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3B0c1tcInNvbmdcIl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIGFueSBudW1iZXIgb2YgQUJDIGZpbGVzIGFzIGlucHV0LlxuICAgICAgICAgICAgZm9yICg7IGFyZ2luZGV4IDwgYXJncy5sZW5ndGg7ICsrYXJnaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgc3BsaXR0aW5nIG9mIEFCQyBzdWJmaWxlcyBhdCBYOiBsaW5lcy5cbiAgICAgICAgICAgICAgICBzdWJmaWxlID0gYXJnc1thcmdpbmRleF0uc3BsaXQoL1xcbig/PVg6KS8pO1xuICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBzdWJmaWxlLmxlbmd0aDsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFiY2ZpbGUgPSBwYXJzZUFCQ0ZpbGUoc3ViZmlsZVtrXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWJjZmlsZSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRha2UgdGVtcG8gbWFya2luZ3MgZnJvbSB0aGUgZmlyc3QgZmlsZSwgYW5kIHNoYXJlIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIGlmICghb3B0cy5oYXNPd25Qcm9wZXJ0eShcInRlbXBvXCIpICYmIGFiY2ZpbGUudGVtcG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbXCJ0ZW1wb1wiXSA9IGFiY2ZpbGUudGVtcG87XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWJjZmlsZS51bml0YmVhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNbXCJ0ZW1wb1wiXSA9IChvcHRzW1widGVtcG9cIl0gKiBhYmNmaWxlLnVuaXRiZWF0KSAvIChhYmNmaWxlLnVuaXRub3RlIHx8IDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIElnbm9yZSBmaWxlcyB3aXRob3V0IHNvbmdzLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIWFiY2ZpbGUudm9pY2UpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBmaWxlcy5wdXNoKGFiY2ZpbGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdGVtcG8gdG8gMTIwIGlmIG5vdGhpbmcgZWxzZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICBpZiAoIW9wdHMuaGFzT3duUHJvcGVydHkoXCJ0ZW1wb1wiKSkge1xuICAgICAgICAgICAgICAgIG9wdHNbXCJ0ZW1wb1wiXSA9IDEyMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdm9sdW1lIHRvIDEgaWYgbm90aGluZyBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICBpZiAoIW9wdHMuaGFzT3duUHJvcGVydHkoXCJ2b2x1bWVcIikpIHtcbiAgICAgICAgICAgICAgICBvcHRzW1widm9sdW1lXCJdID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlYXRzZWNzID0gNjAuMCAvIG9wdHNbXCJ0ZW1wb1wiXTtcbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGFsbCBub3RlcyBmcm9tIGFsbCB0aGUgZmlsZXMuXG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgZmlsZXMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgICAgICAgICBhYmNmaWxlID0gZmlsZXNba107XG4gICAgICAgICAgICAgICAgLy8gRWFjaCBmaWxlIGNhbiBoYXZlIG11bHRpcGxlIHZvaWNlcyAoZS5nLiwgbGVmdCBhbmQgcmlnaHQgaGFuZHMpXG4gICAgICAgICAgICAgICAgZm9yICh2biBpbiBhYmNmaWxlLnZvaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVhY2ggdm9pY2UgY291bGQgaGF2ZSBhIHNlcGFyYXRlIHRpbWJyZS5cbiAgICAgICAgICAgICAgICAgICAgdGltYnJlID0gVXRpbHMubWFrZVRpbWJyZShvcHRzW1widGltYnJlXCJdIHx8IGFiY2ZpbGUudm9pY2Vbdm5dLnRpbWJyZSB8fCBhYmNmaWxlLnRpbWJyZSB8fCB0aGlzLl90aW1icmUsIHRoaXMuX2F0b3ApO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHZvaWNlIGhhcyBhIHNlcmllcyBvZiBzdGVtcyAobm90ZXMgb3IgY2hvcmRzKS5cbiAgICAgICAgICAgICAgICAgICAgc3RlbXMgPSBhYmNmaWxlLnZvaWNlW3ZuXS5zdGVtcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdGVtcykgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0YXJ0aW5nIGF0IGRlbGF5IHplcm8gKG5vdyksIHNjaGVkdWxlIGFsbCB0b25lcy5cbiAgICAgICAgICAgICAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKG5pID0gMDsgbmkgPCBzdGVtcy5sZW5ndGg7ICsrbmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW0gPSBzdGVtc1tuaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBdHRlbnVhdGUgY2hvcmRzIHRvIHJlZHVjZSBjbGlwcGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVudWF0ZSA9IDEgLyBNYXRoLnNxcnQoc3RlbS5ub3Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgZXZlcnkgbm90ZSBpbnNpZGUgYSBzdGVtLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IHN0ZW0ubm90ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RlID0gc3RlbS5ub3Rlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm90ZS5ob2xkb3Zlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTa2lwIGhvbGRvdmVyIG5vdGVzIGZyb20gdGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3MgPSAobm90ZS50aW1lIHx8IHN0ZW0udGltZSkgKiBiZWF0c2VjcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RlbS5zdGFjY2F0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTaG9ydGVuIHN0YWNjYXRvIG5vdGVzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWNzID0gTWF0aC5taW4oTWF0aC5taW4oc2VjcywgYmVhdHNlY3MgLyAxNiksIHRpbWJyZS5hdHRhY2sgKyB0aW1icmUuZGVjYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIW5vdGUuc2x1cnJlZCAmJiBzZWNzID49IDEgLyA4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlcGFyYXRlIHVuc2x1cnJlZCBub3RlcyBieSBhYm91dCBhIDMwdGggb2YgYSBzZWNvbmQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3MgLT0gMSAvIDMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ID0gKG5vdGUudmVsb2NpdHkgfHwgMSkgKiBhdHRlbnVhdGUgKiBvcHRzW1widm9sdW1lXCJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgaW5uc2VybW9zdCBwYXJ0IG9mIHRoZSBpbm5lciBsb29wIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudG9uZShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGxheSB0aGUgdG9uZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZS5waXRjaCwgLy8gYXQgdGhlIGdpdmVuIHBpdGNoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlY3MsIC8vIGZvciB0aGUgZ2l2ZW4gZHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdiwgLy8gd2l0aCB0aGUgZ2l2ZW4gdm9sdW1lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5LCAvLyBzdGFydGluZyBhdCB0aGUgcHJvcGVyIHRpbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltYnJlLCAvLyB3aXRoIHRoZSBzZWxlY3RlZCB0aW1icmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm90ZSAvLyB0aGUgb3JpZ2luIG9iamVjdCBmb3IgdmlzdWFsIGZlZWRiYWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGF5ICs9IHN0ZW0udGltZSAqIGJlYXRzZWNzOyAvLyBBZHZhbmNlIHRoZSBzZXF1ZW5jZWQgdGltZS5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBtYXhkZWxheSA9IE1hdGgubWF4KGRlbGF5LCBtYXhkZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWF4U2NoZWR1bGVkVGltZSA9IE1hdGgubWF4KHRoaXMuX21heFNjaGVkdWxlZFRpbWUsIHRoaXMubm93KCkgKyBtYXhkZWxheSk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgXCJkb25lXCIgY2FsbGJhY2sgYWZ0ZXIgYWxsIHNlcXVlbmNpbmcgaXMgY29tcGxldGUuXG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZShtYXhkZWxheSwgZG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEVORCBJTlNUUlVNRU5UXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbn1cblxuZXhwb3J0IGRlZmF1bHQgTXVzaWNhbDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./apps/shared/sound/Musical.ts\n");

/***/ })

})